0001   0000             ;**************************************************************
0002   0000             ;
0003   0000             ;                       The Z80 WestOS
0004   0000             ;
0005   0000             ;                 Operating System for Z80 board
0006   0000             ;                       West 17 Designs
0007   0000             ;
0008   0000             ;  Authors: Antti Partanen, <aehparta@cc.hut.fi>
0009   0000             ;
0010   0000             ;**************************************************************
0011   0000             ; Misc information:
0012   0000             ; The LCD-display mentioned in the code should be 2x20
0013   0000             ; characters LCD-display module using hd44780-based
0014   0000             ; controller.
0015   0000             ;
0016   0000             ;**************************************************************
0017   0000             
0018   0000             #define OS_FILE
0019   0000             
0020   0000             #include "OSdef.h"
0001+  0000             ;**************************************************************
0002+  0000             ;
0003+  0000             ; Defines & equs & routine addresses
0004+  0000             ;
0005+  0000             ;**************************************************************
0006+  0000             
0007+  0000             #define equ .equ
0008+  0000             
0009+  0000             #define CPU_AT_4MHZ
0010+  0000             
0011+  0000             ; Macros for using the LEDs
0012+  0000             #define led_reset(reset) ld a,(LEDs_state)\ or ~reset\ out (LEDs),a\ ld (LEDs_state),a
0013+  0000             #define led_set(set) ld a,(LEDs_state)\ and ~set\ out (LEDs),a\ ld (LEDs_state),a
0014+  0000             #define led_toggle(toggle) ld a,(LEDs_state)\ xor toggle\ out (LEDs),a\ ld (LEDs_state),a
0015+  0000             #define leds_load(load) ld a,load\ out (LEDs),a\ ld (LEDs_state),a
0016+  0000             
0017+  0000             ; Operating system reserves memory between $ea00-$ffff
0018+  0000             
0019+  0000             ; Stack Pointer start value,
0020+  0000             ; it reserves 256bytes ($ff00-$ffff)
0021+  0000             StackPointerOrigin: equ $fff0
0022+  0000             ; Variables
0023+  0000             SRM             equ $ea00       ; Here are OS's variables
0024+  0000             UMO             equ $e000       ; Here starts the 'User's Memory' (1KB)
0025+  0000             ; Temporary values
0026+  0000             T0              equ SRM+0       ; These values are bytes
0027+  0000             T1              equ SRM+1
0028+  0000             T2              equ SRM+2
0029+  0000             T3              equ SRM+3
0030+  0000             GT0             equ SRM+4
0031+  0000             GT1             equ SRM+5
0032+  0000             ; Hex editor
0033+  0000             w_he_address    equ SRM+6       ;word
0034+  0000             b_he_addset     equ SRM+8       ;byte
0035+  0000             b_he_undovalue  equ SRM+9       ;byte
0036+  0000             w_he_undoaddr   equ SRM+10      ;word
0037+  0000             b_he_undoset    equ SRM+12      ;byte
0038+  0000             b_he_nibble     equ SRM+13      ;byte
0039+  0000             b_he_output     equ SRM+14      ;byte
0040+  0000             b_he_input      equ SRM+15      ;byte
0041+  0000             w_he_jumpaddr   equ SRM+16      ;word
0042+  0000             b_he_calljump   equ SRM+18      ;byte
0043+  0000             w_he_calladdr   equ SRM+19      ;word
0044+  0000             ; key-routines
0045+  0000             key_pressed     equ SRM+30      ;byte
0046+  0000             key_timer       equ SRM+31      ;byte
0047+  0000             key_delay       equ SRM+32      ;byte
0048+  0000             key_press       equ SRM+33      ;byte
0049+  0000             key_repeatdelay equ SRM+34      ;word
0050+  0000             key_repeatrate  equ SRM+36      ;word
0051+  0000             key_rd          equ SRM+38      ;word
0052+  0000             key_rr          equ SRM+40      ;word
0053+  0000             key_rset        equ SRM+42      ;byte
0054+  0000             ; Default repeat delay and rate for keyboard
0055+  0000             RepeatDelay     equ SRM+50      ;word
0056+  0000             RepeatRate      equ SRM+52      ;word
0057+  0000             RepeatSet       equ SRM+54      ;byte
0058+  0000             ; Log id's and addresses
0059+  0000             logs_curid      equ SRM+60      ;byte
0060+  0000             logs_status     equ SRM+61      ;byte
0061+  0000             logs_cur        equ SRM+62      ;word
0062+  0000             logs_ids        equ SRM+64      ;9words=18bytes
0063+  0000             ;
0064+  0000             SystemLogId     equ SRM+127     ;byte
0065+  0000             ; Used by network
0066+  0000             network         equ SRM+128     ;reserves 256bytes
0067+  0000             ; Uptime counter               
0068+  0000             uptime          equ SRM+384     ;6bytes
0069+  0000             ; State of LEDs
0070+  0000             LEDs_state      equ SRM+390
0071+  0000             ; For logs
0072+  0000             logs            equ SRM+640     ;reserves 4KB
0073+  0000             
0074+  0000             ;**************************************************************
0075+  0000             ; LEDs, 7segments and keyboard io-addresses
0076+  0000             SSeg1           equ $01
0077+  0000             SSeg2           equ $02
0078+  0000             SSeg3           equ $03
0079+  0000             SSeg4           equ $04
0080+  0000             KeyS            equ $05
0081+  0000             KeyR            equ $06
0082+  0000             LEDs            equ $07
0083+  0000             ; 8255 PIO -chip registers
0084+  0000             ;  LCD-display
0085+  0000             PortA           equ $20
0086+  0000             PortB           equ $21
0087+  0000             PortC           equ $22
0088+  0000             PIOCtrl         equ $23
0089+  0000             LCDd            equ PortB
0090+  0000             LCDi            equ PortC
0091+  0000             ; Timer
0092+  0000             Counter0        equ $a0
0093+  0000             Counter1        equ $a1
0094+  0000             Counter2        equ $a2
0095+  0000             CounterC        equ $a3
0096+  0000             ; Other IOs
0097+  0000             ethcom          equ $c0
0098+  0000             flashcom        equ $c1
0099+  0000             ETHBASE         equ $e0
0100+  0000             
0101+  0000             
0102+  0000             ; Keyboard
0103+  0000             ; These values are returned by key-routines
0104+  0000             key0    equ $00
0105+  0000             key1    equ $01
0106+  0000             key2    equ $02
0107+  0000             key3    equ $03
0108+  0000             
0109+  0000             key4    equ $04
0110+  0000             key5    equ $05
0111+  0000             key6    equ $06
0112+  0000             key7    equ $07
0113+  0000             
0114+  0000             key8    equ $08
0115+  0000             key9    equ $09
0116+  0000             keya    equ $0a
0117+  0000             keyb    equ $0b
0118+  0000             
0119+  0000             keyc    equ $0c
0120+  0000             keyd    equ $0d
0121+  0000             keye    equ $0e
0122+  0000             keyf    equ $0f
0123+  0000             
0124+  0000             CK0     equ $10
0125+  0000             CK1     equ $11
0126+  0000             CK2     equ $12
0127+  0000             CK3     equ $13
0128+  0000             
0129+  0000             CK4     equ $14
0130+  0000             CK5     equ $15
0131+  0000             Shift   equ $16
0132+  0000             Enter   equ $17
0133+  0000             
0134+  0000             none    equ $ff
0135+  0000             
0136+  0000             ; defines
0137+  0000             #define Line1 $00
0138+  0000             #define Line2 $40
0139+  0000             #define EOL $17                 ; End Of Line, used with strings
0140+  0000             #define EOLOG $18               ; End Of LOG
0141+  0000             #define NOEOL $19
0142+  0000             #define LOGSP $ff
0143+  0000             #define log_adding $01          ; This flag is set in log_status when there is adding in progress
0144+  0000             #define MAX_LOGS 8
0145+  0000             #define LOG_MEMORY_SIZE 4096
0146+  0000             
0147+  0000             ; Next delay-values are relative to speed of CPU
0148+  0000~            #ifdef CPU_AT_2MHZ
0149+  0000~            _RepeatDelay    equ $0aff       ; default value
0150+  0000~            _RepeatRate     equ $00ff       ; default value
0151+  0000~            FastKeyDelay    equ $40
0152+  0000~            NormalKeyDelay  equ $a0
0153+  0000             #endif
0154+  0000             #ifdef CPU_AT_4MHZ
0155+  0000             _RepeatDelay    equ $0fff       ; default value
0156+  0000             _RepeatRate     equ $01ff       ; default value
0157+  0000             FastKeyDelay    equ $80
0158+  0000             NormalKeyDelay  equ $f0
0159+  0000             #endif
0160+  0000~            #ifdef CPU_AT_8MHZ
0161+  0000~            _RepeatDelay    equ $1fff       ; default value
0162+  0000~            _RepeatRate     equ $02ff       ; default value
0163+  0000~            FastKeyDelay    equ $c0
0164+  0000~            NormalKeyDelay  equ $f0
0165+  0000             #endif
0166+  0000             
0167+  0000             LCD_delay       equ $0002       ; Delay after actions when using
0168+  0000                                             ; LCD for 2ms
0169+  0000             
0170+  0000             ErrorMesg       equ 3000        ; Show error for 3secs
0171+  0000             NormalMesg      equ 1000        ; Show normal messages for 1,5secs
0172+  0000             FastMesg        equ 1000        ; Show fast messages for 1sec
0173+  0000             LongMesg        equ 4000        ; Show long message for 4secs
0174+  0000             LLongMesg       equ 7000        ; Show really long message for 7secs
0175+  0000             
0176+  0000             ; *****************
0177+  0000             ; Routine addresses
0178+  0000~            #ifndef OS_FILE
0179+  0000~            DelayBC         equ $0040
0180+  0000~            DelayDE         equ $0049
0181+  0000~            DelayHL         equ $0052
0182+  0000~            HALT            equ $006b
0183+  0000~            n_as_7seg       equ $009e
0184+  0000~            n_to_7seg       equ $00b1
0185+  0000~            b_to_7seg       equ $00cb
0186+  0000~            byte2lcd        equ $00fe
0187+  0000~            set_lcd         equ $0125
0188+  0000~            char2lcd        equ $013f
0189+  0000~            reset_lcd       equ $015b
0190+  0000~            clear_lcd       equ $017e
0191+  0000~            str2lcd         equ $0186
0192+  0000~            strn2lcd        equ $0197
0193+  0000~            strd2lcd        equ $01b3
0194+  0000~            setDDRAMa       equ $01c7
0195+  0000~            key_scan        equ $01d0
0196+  0000~            key_testshift   equ $026a
0197+  0000~            key_getkey      equ $0277
0198+  0000~            key_getbyte     equ $030a
0199+  0000~            key_getaddress  equ $03e1
0200+  0000~            key_getword     equ $03f7
0201+  0000~            Delayms         equ $0554
0202+  0000~            CreateLog       equ $0571
0203+  0000~            AddLog          equ $05bd
0204+  0000~            ViewLog         equ $0640
0205+  0000             #endif
0206+  0000             
0207+  0000             ; ************
0208+  0000             ; "Next level"
0209+  0000             ; (Network and such)
0210+  0000             
0211+  0000             ; These macros makes easier to use the NIC
0212+  0000             ; by adding the base address of NIC to the
0213+  0000             ; relative NIC register address
0214+  0000             ;#define einb(address) ld a,(ethbase)\ add a,address\ ld c,a\ in a,(c)
0215+  0000             ;#define eoutb(address) ex af,af'\ ld a,(ethbase)\ add a,address\ ld c,a\ ex af,af'\ out (c),a
0216+  0000             
0217+  0000             ; network variables
0218+  0000             ETHM            equ SRM+128     ;256bytes (must be equ to network
0219+  0000                                             ;in osXXX.asm)
0220+  0000             ;
0221+  0000             ethdetect       equ ETHM+1      ;byte
0222+  0000             ethtmp          equ ETHM+2      ;byte
0223+  0000             ethsaprom       equ ETHM+3      ;32 bytes
0224+  0000             ethhwaddr       equ ETHM+35      ;6 bytes
0225+  0000             ethpiomode      equ ETHM+41     ;byte
0226+  0000             ethaddr         equ ETHM+42     ;byte
0227+  0000             ethirqreg       equ ETHM+43     ;byte
0228+  0000             ethwrdlen       equ ETHM+44     ;byte
0229+  0000             ethT0           equ ETHM+45     ;byte
0230+  0000             ethT1           equ ETHM+46     ;byte
0231+  0000             ethT2           equ ETHM+47     ;byte
0232+  0000             ethT3           equ ETHM+48     ;byte
0233+  0000             etxStartPage    equ ETHM+49     ;byte
0234+  0000             erxStartPage    equ ETHM+50     ;byte
0235+  0000             ethStopPage     equ ETHM+51     ;byte
0236+  0000             ethCurrentPage  equ ETHM+52     ;byte
0237+  0000             NetLogId        equ ETHM+53     ;byte
0238+  0000             ; Jump-table
0239+  0000             ejProbe         equ ETHM+60     ;word
0240+  0000             ejReset         equ ETHM+62     ;word
0241+  0000             ejOpen          equ ETHM+64     ;word
0242+  0000             ejEnable        equ ETHM+66     ;word
0243+  0000             ejDisable       equ ETHM+68     ;word
0244+  0000             ejInterrupt     equ ETHM+70     ;word
0245+  0000             ejSend          equ ETHM+72     ;word
0246+  0000             ; Information for sending and receiving packets
0247+  0000             ethDataAddr     equ ETHM+80     ;word
0248+  0000             ethDataLen      equ ETHM+82     ;word
0249+  0000             ethDataPage     equ ETHM+84     ;word
0250+  0000             ; Error counters
0251+  0000             ethRxFrameErrs  equ ETHM+100    ;word frame errors
0252+  0000             ethRxCrcErrs    equ ETHM+102    ;word CRC errors
0253+  0000             ethRxMissedErrs equ ETHM+104    ;word missed-errors
0254+  0000             ethTxCarrErrs   equ ETHM+106    ;word tx carrier errors
0255+  0000             ethTxHBErrs     equ ETHM+108    ;word tx heartbeat errors
0256+  0000             ethTxWindow     equ ETHM+110    ;word tx window errors
0257+  0000             ethRxOverErrs   equ ETHM+112    ;word rx overrun errors
0258+  0000             ethRxErrs       equ ETHM+114    ;word rx errors
0259+  0000             ethRxFifoErrs   equ ETHM+116    ;word rx fifo errors
0260+  0000             ethRxLenErrs    equ ETHM+118    ;word rx lenght errors
0261+  0000             ethRxPackets    equ ETHM+120    ;dword rx packets counter
0262+  0000             ethTxPackets    equ ETHM+124    ;dword tx packets counter
0263+  0000             ethRxBytes      equ ETHM+128    ;dword rx bytes
0264+  0000             ethTxBytes      equ ETHM+132    ;dword tx bytes
0265+  0000             ethRxDropped    equ ETHM+136    ;word rx packets dropped
0266+  0000             ; Structures (ex. headers) and such
0267+  0000             ; receive packet header
0268+  0000             #define pkthdr_size 4
0269+  0000             pkthdr          equ ETHM+150    ;2 bytes+1 word=4 bytes
0270+  0000             pkthdr_stat     equ ETHM+150    ;byte
0271+  0000             pkthdr_next     equ ETHM+151    ;byte
0272+  0000             pkthdr_count    equ ETHM+152    ;word
0273+  0000             ; Ing:s :)
0274+  0000             #define XXXing 17
0275+  0000             ethRxing        equ ETHM+160    ;byte
0276+  0000             ethTxing        equ ETHM+161    ;byte
0277+  0000             
0278+  0000             ; Temporary values
0279+  0000             NT0             equ ETHM+252    ;byte
0280+  0000             NT1             equ ETHM+253    ;byte
0281+  0000             NT2             equ ETHM+254    ;byte
0282+  0000             NT3             equ ETHM+255    ;byte
0021   0000             
0022   0000             ;**************************************************************
0023   0000             ; Code origin
0024   0000             .org $0000
0025   0000             
0026   0000             ;**************************************************************
0027   0000             ; RST $00
0028   0000             ; Set the counters third counter's out to inactive state
0029   0000             ; becose nmi interrupt is not a good thing in here
0030   0000 3E 90        ld a,$90
0031   0002 D3 A3        out (CounterC),a
0032   0004 C3 50 07     jp RESET
0033   0007             ; RST $08
0034   0007             ; This RST jumps to HALT-routine
0035   0008             .org $0008
0036   0008 C3 6B 00     jp HALT
0037   000B             ; RST $10
0038   0010             .org $0010
0039   0010 76           halt
0040   0011 ED 4D        reti
0041   0013             ; RST $18
0042   0018             .org $0018
0043   0018 76           halt
0044   0019 ED 4D        reti
0045   001B             ; RST $20
0046   0020             .org $0020
0047   0020 76           halt
0048   0021 ED 4D        reti
0049   0023             ; RST $28
0050   0028             .org $0028
0051   0028 76           halt
0052   0029 ED 4D        reti
0053   002B             ; RST $30
0054   0030             .org $0030
0055   0030 76           halt
0056   0031 ED 4D        reti
0057   0033             ; RST $38 or /INT-signal in interrupt mode 1
0058   0033             ; INT is used by ethernet controller
0059   0038             .org $0038
0060   0038 F3           di
0061   0039             ; Handle the ethernet NIC's interrupt
0062   0039 CD 17 20     call ethInterrupt
0063   003C FB           ei
0064   003D ED 4D        reti
0065   003F             ;**************************************************************
0066   003F             ; Empty space for the NMI-interrupt point
0067   003F             ; Here are three default delay routines
0068   003F             ; and little string ;)
0069   003F             ; $40
0070   003F             ; $1000 loops in these delays takes about 16.428ms when
0071   003F             ; CPU runs @4MHz
0072   003F             ; @2MHz it takes 32.856ms
0073   003F             ; @8MHz it takes 8.214ms
0074   003F             ; (Interrupts are not included in these delays)
0075   0040             .org $0040
0076   0040             DelayBC:
0077   0040 04           inc b
0078   0041 0C           inc c
0079   0042             DelayBC0:
0080   0042 0D           dec c          ; 1byte    4 clocks / 1us / 2us
0081   0043 20 FD        jr nz,DelayBC0 ; 2bytes   12/7 clocks / 3us/1.75us / 6us/3.5us
0082   0045 05           dec b          ; 1byte    4 clocks / 1us / 2us
0083   0046 20 FA        jr nz,DelayBC0 ; 2bytes   12 clocks / 3us / 6us
0084   0048 C9           ret            ; 1byte
0085   0049             DelayDE:
0086   0049 14           inc d
0087   004A 1C           inc e
0088   004B             DelayDE0:
0089   004B 1D           dec e          ; 1byte
0090   004C 20 FD        jr nz,DelayDE0 ; 2bytes
0091   004E 15           dec d          ; 1byte
0092   004F 20 FA        jr nz,DelayDE0 ; 2bytes
0093   0051 C9           ret            ; 1byte
0094   0052             DelayHL:
0095   0052 24           inc h
0096   0053 2C           inc l
0097   0054             DelayHL0:
0098   0054 2D           dec l          ; 1byte
0099   0055 20 FD        jr nz,DelayHL0 ; 2bytes
0100   0057 25           dec h          ; 1byte
0101   0058 20 FA        jr nz,DelayHL0 ; 2bytes
0102   005A C9           ret            ; 1byte
0103   005B             ;
0104   005B             
0105   005B 627920447567.db "by Duge"
0105   0061 65
0106   0062             
0107   0062             ;**************************************************************
0108   0062             ; This is the point where the processor goes when NMI-interrupt
0109   0062             ; is signalled
0110   0062             ; 0066H or $66
0111   0066             .org $0066
0112   0066 C3 24 0F     jp HandleNMI
0113   0069 ED 45        retn
0114   006B             
0115   006B             ;**************************************************************
0116   006B             ; Here starts the 'REAL' code
0117   006B             ; First routines, then the main code
0118   006B             ; and then misc data like strings and such
0119   006B             ;**************************************************************
0120   006B             ; Routines
0121   006B             ;
0122   006B             ; Three delay routines have already been written in earlier
0123   006B             ; addresses
0124   006B             
0125   006B             ; *** HALT
0126   006B             ; Writes 'HALT' into 7segments, "CPU halted." into
0127   006B             ; system log and then halt's the cpu
0128   006B             ; /INT and /NMI signals can wake up the CPU
0129   006B             ; from halt-mode
0130   006B             HALT:
0131   006B F5           push af
0132   006C E5           push hl
0133   006D 3E A4        ld a,%10100100
0134   006F D3 01        out (SSeg1),a
0135   0071 3E A0        ld a,%10100000
0136   0073 D3 02        out (SSeg2),a
0137   0075 3E CD        ld a,%11001101
0138   0077 D3 03        out (SSeg3),a
0139   0079 3E E9        ld a,%11101001
0140   007B D3 04        out (SSeg4),a
0141   007D 3A 7F EA     ld a,(SystemLogId)
0142   0080 21 2E 14     ld hl,s_SysHalt
0143   0083 CD BD 05     call AddLog
0144   0086 3E FF        ld a,$ff
0145   0088 76           halt
0146   0089 D3 01        out (SSeg1),a
0147   008B D3 02        out (SSeg2),a
0148   008D D3 03        out (SSeg3),a
0149   008F D3 04        out (SSeg4),a
0150   0091 3A 7F EA     ld a,(SystemLogId)
0151   0094 21 3B 14     ld hl,s_SysHaltWake
0152   0097 CD BD 05     call AddLog
0153   009A E1           pop hl
0154   009B F1           pop af
0155   009C ED 4D        reti
0156   009E             ; end of HALT
0157   009E             
0158   009E             ; *** n_as_7seg
0159   009E             ; This routine converts the hex value of lower 4bits of reg a
0160   009E             ; as 7segment value and returns the result in reg a
0161   009E             ; The 7bit of reg a is leaved unchanged for use of dot
0162   009E             n_as_7seg:
0163   009E E5           push hl
0164   009F C5           push bc
0165   00A0             
0166   00A0 21 5A 14     ld hl,hexto7segment
0167   00A3 47           ld b,a
0168   00A4 E6 0F        and $0f
0169   00A6 4F           ld c,a
0170   00A7 78           ld a,b
0171   00A8 06 00        ld b,0
0172   00AA 09           add hl,bc
0173   00AB E6 80        and $80
0174   00AD A6           and (hl)
0175   00AE             
0176   00AE C1           pop bc
0177   00AF E1           pop hl
0178   00B0 C9           ret
0179   00B1             ; end of n_as_7seg
0180   00B1             
0181   00B1             ; *** n_to_7seg
0182   00B1             ; This routine outputs the hex value of lower 4bits of reg a
0183   00B1             ; into 7segment display which io-address is specified in
0184   00B1             ; reg c
0185   00B1             ; Carry flag defines if the dot is on or off
0186   00B1             ; reg a and flags are changed
0187   00B1             n_to_7seg:
0188   00B1 E5           push hl
0189   00B2 C5           push bc
0190   00B3             
0191   00B3 06 FF        ld b,$ff
0192   00B5 30 02        jr nc,nto7_nocarry
0193   00B7 CB B8        res 7,b
0194   00B9             nto7_nocarry:
0195   00B9 21 5A 14     ld hl,hexto7segment
0196   00BC C5           push bc
0197   00BD 06 00        ld b,0
0198   00BF E6 0F        and $0f
0199   00C1 4F           ld c,a
0200   00C2 09           add hl,bc
0201   00C3 C1           pop bc
0202   00C4 78           ld a,b
0203   00C5 A6           and (hl)
0204   00C6 ED 79        out (c),a
0205   00C8             
0206   00C8 C1           pop bc
0207   00C9 E1           pop hl
0208   00CA C9           ret
0209   00CB             ; end of n_to_7seg
0210   00CB             
0211   00CB             ; *** b_to_7seg
0212   00CB             ; This routine outputs the hex value of reg a into
0213   00CB             ; two 7segment display
0214   00CB             ; First display io-address is specified in reg c
0215   00CB             ; The most valuable nibble of reg a will be outed
0216   00CB             ; into the address of c, then c's value is increased
0217   00CB             ; and the lower nibble is outed into that address
0218   00CB             ; Carry flag defines if the dot is on or off
0219   00CB             ; flags are changed
0220   00CB             b_to_7seg:
0221   00CB F5           push af
0222   00CC E5           push hl
0223   00CD C5           push bc
0224   00CE             
0225   00CE 06 FF        ld b,$ff
0226   00D0 30 02        jr nc,bto7_nocarry
0227   00D2 CB B8        res 7,b
0228   00D4             bto7_nocarry:
0229   00D4             ; Upper 4bits of reg a
0230   00D4 21 5A 14     ld hl,hexto7segment
0231   00D7 F5           push af
0232   00D8 C5           push bc
0233   00D9 06 00        ld b,0
0234   00DB CB 3F        srl a
0235   00DD CB 3F        srl a
0236   00DF CB 3F        srl a
0237   00E1 CB 3F        srl a
0238   00E3 4F           ld c,a
0239   00E4 09           add hl,bc
0240   00E5 C1           pop bc
0241   00E6 7E           ld a,(hl)
0242   00E7 ED 79        out (c),a
0243   00E9 0C           inc c
0244   00EA F1           pop af
0245   00EB             ; Lower 4bits of reg a
0246   00EB C5           push bc
0247   00EC 21 5A 14     ld hl,hexto7segment
0248   00EF 06 00        ld b,0
0249   00F1 E6 0F        and $0f
0250   00F3 4F           ld c,a
0251   00F4 09           add hl,bc
0252   00F5 C1           pop bc
0253   00F6 78           ld a,b
0254   00F7 A6           and (hl)
0255   00F8 ED 79        out (c),a
0256   00FA             
0257   00FA C1           pop bc
0258   00FB E1           pop hl
0259   00FC F1           pop af
0260   00FD C9           ret
0261   00FE             ; end of b_to_7seg
0262   00FE             
0263   00FE             ; *** byte2lcd
0264   00FE             ; This routine outputs the hex value of reg a into
0265   00FE             ; LCD-display
0266   00FE             byte2lcd:
0267   00FE E5           push hl
0268   00FF C5           push bc
0269   0100             ; Upper 4bits of reg a
0270   0100 21 4A 14     ld hl,hextolcd
0271   0103 F5           push af
0272   0104 06 00        ld b,0
0273   0106 CB 3F        srl a
0274   0108 CB 3F        srl a
0275   010A CB 3F        srl a
0276   010C CB 3F        srl a
0277   010E 4F           ld c,a
0278   010F 09           add hl,bc
0279   0110 46           ld b,(hl)
0280   0111 CD 3F 01     call char2lcd
0281   0114 F1           pop af
0282   0115             ; Lower 4bits of reg a
0283   0115 21 4A 14     ld hl,hextolcd
0284   0118 06 00        ld b,0
0285   011A E6 0F        and $0f
0286   011C 4F           ld c,a
0287   011D 09           add hl,bc
0288   011E 46           ld b,(hl)
0289   011F CD 3F 01     call char2lcd
0290   0122             ;
0291   0122 C1           pop bc
0292   0123 E1           pop hl
0293   0124 C9           ret
0294   0125             ; end of byte2lcd
0295   0125             
0296   0125             ; *** set_lcd
0297   0125             ; Sets value to LCDs instruction register
0298   0125             set_lcd:
0299   0125 F5           push af
0300   0126 D5           push de
0301   0127 3E 01        ld a,%00000001
0302   0129 D3 22        out (LCDi),a
0303   012B 78           ld a,b
0304   012C D3 21        out (LCDd),a
0305   012E 3E 00        ld a,%00000000
0306   0130 D3 22        out (LCDi),a
0307   0132 11 02 00     ld de,LCD_delay
0308   0135 CD 54 05     call Delayms
0309   0138 3E 01        ld a,%00000001
0310   013A D3 22        out (LCDi),a
0311   013C D1           pop de
0312   013D F1           pop af
0313   013E C9           ret
0314   013F             ; end of set_lcd
0315   013F             
0316   013F             ; *** char2lcd
0317   013F             ; Outs character to LCD-display
0318   013F             char2lcd:
0319   013F F5           push af
0320   0140 C5           push bc
0321   0141 D5           push de
0322   0142 3E 05        ld a,%00000101
0323   0144 D3 22        out (LCDi),a
0324   0146 78           ld a,b
0325   0147 D3 21        out (LCDd),a
0326   0149 3E 04        ld a,%00000100
0327   014B D3 22        out (LCDi),a
0328   014D 11 02 00     ld de,LCD_delay
0329   0150 CD 54 05     call Delayms
0330   0153 3E 01        ld a,%00000001
0331   0155 D3 22        out (LCDi),a
0332   0157 D1           pop de
0333   0158 C1           pop bc
0334   0159 F1           pop af
0335   015A C9           ret
0336   015B             ; end of char2lcd
0337   015B             
0338   015B             ; *** reset_lcd
0339   015B             ; Resets the LCD-diplay
0340   015B             ; Clears the LCD, returns cursor to home, sets cursor move
0341   015B             ; direction to incremental, sets display shifting off,
0342   015B             ; sets dosplay on, cursor on, cursor blinking off, sets
0343   015B             ; cursor-move mode on, shift direction left, interface
0344   015B             ; data lenght to 8bits, number of display lines to 2lines
0345   015B             ; and character font to 5x7.
0346   015B             ; none of the regs or flags are changed
0347   015B             reset_lcd:
0348   015B F5           push af
0349   015C C5           push bc
0350   015D             
0351   015D 06 01        ld b,%00000001
0352   015F CD 25 01     call set_lcd
0353   0162 06 06        ld b,%00000110
0354   0164 CD 25 01     call set_lcd
0355   0167 06 0C        ld b,%00001100
0356   0169 CD 25 01     call set_lcd
0357   016C 06 10        ld b,%00010000
0358   016E CD 25 01     call set_lcd
0359   0171 06 38        ld b,%00111000
0360   0173 CD 25 01     call set_lcd
0361   0176 06 80        ld b,%10000000
0362   0178 CD 25 01     call set_lcd
0363   017B             
0364   017B C1           pop bc
0365   017C F1           pop af
0366   017D C9           ret
0367   017E             ; end of reset_lcd
0368   017E             
0369   017E             ; *** clear_lcd
0370   017E             ; Clears the LCD
0371   017E             clear_lcd:
0372   017E C5           push bc
0373   017F 06 01        ld b,%00000001
0374   0181 CD 25 01     call set_lcd
0375   0184 C1           pop bc
0376   0185 C9           ret
0377   0186             ; end of clear_lcd
0378   0186             
0379   0186             ; *** str2lcd
0380   0186             ; Outputs a string into LCD-display
0381   0186             ; The string start address should be stored into hl and
0382   0186             ; end of the string should be marked with EOL
0383   0186             ; The string is just added to displays previous
0384   0186             ; contents
0385   0186             ; hl and flags are changed
0386   0186             str2lcd:
0387   0186 F5           push af
0388   0187 C5           push bc
0389   0188 3E 17        ld a,EOL
0390   018A             s2l_loop:
0391   018A 46           ld b,(hl)
0392   018B B8           cp b
0393   018C 28 06        jr z,s2l_end
0394   018E CD 3F 01     call char2lcd
0395   0191 23           inc hl
0396   0192 18 F6        jr s2l_loop
0397   0194             s2l_end:
0398   0194 C1           pop bc
0399   0195 F1           pop af
0400   0196 C9           ret
0401   0197             ; end of str2lcd
0402   0197             
0403   0197             ; *** strn2lcd
0404   0197             ; Outputs a string into LCD-display
0405   0197             ; The string start address should be stored into hl and
0406   0197             ; lenght of the string should be in reg c
0407   0197             ; This routine also exits if it find EOL- or EOLOG-char and
0408   0197             ; returns that char in reg c, otherwise it returns NOEOL
0409   0197             ; The string is just added to displays previous
0410   0197             ; contents
0411   0197             ; none is changed
0412   0197             strn2lcd:
0413   0197 F5           push af
0414   0198 C5           push bc
0415   0199 0C           inc c
0416   019A             sn2l_loop:
0417   019A 3E 19        ld a,NOEOL
0418   019C 0D           dec c
0419   019D 28 10        jr z,sn2l_end
0420   019F 7E           ld a,(hl)
0421   01A0 FE 17        cp EOL
0422   01A2 28 0B        jr z,sn2l_end
0423   01A4 FE 18        cp EOLOG
0424   01A6 28 07        jr z,sn2l_end
0425   01A8 47           ld b,a
0426   01A9 CD 3F 01     call char2lcd
0427   01AC 23           inc hl
0428   01AD 18 EB        jr sn2l_loop
0429   01AF             sn2l_end:
0430   01AF C1           pop bc
0431   01B0 4F           ld c,a
0432   01B1 F1           pop af
0433   01B2 C9           ret
0434   01B3             ; end of strn2lcd
0435   01B3             
0436   01B3             ; *** strd2lcd
0437   01B3             ; Outputs a string into LCD-display with delay
0438   01B3             ; The string start address should be stored into hl,
0439   01B3             ; end of the string should be marked with EOL,
0440   01B3             ; delay between characters in de as milliseconds
0441   01B3             ; The string is just added to displays previous
0442   01B3             ; contents
0443   01B3             ; hl and flags are changed
0444   01B3             strd2lcd:
0445   01B3 F5           push af
0446   01B4 C5           push bc
0447   01B5 3E 17        ld a,EOL
0448   01B7             sd2l_loop:
0449   01B7 46           ld b,(hl)
0450   01B8 B8           cp b
0451   01B9 28 09        jr z,sd2l_end
0452   01BB CD 3F 01     call char2lcd
0453   01BE 23           inc hl
0454   01BF CD 54 05     call Delayms
0455   01C2 18 F3        jr sd2l_loop
0456   01C4             sd2l_end:
0457   01C4 C1           pop bc
0458   01C5 F1           pop af
0459   01C6 C9           ret
0460   01C7             ; end of strd2lcd
0461   01C7              
0462   01C7             ; *** setDDRAMa
0463   01C7             ; Sets LCDs DDRAM address
0464   01C7             setDDRAMa:
0465   01C7 C5           push bc
0466   01C8 F6 80        or $80
0467   01CA 47           ld b,a
0468   01CB CD 25 01     call set_lcd
0469   01CE C1           pop bc
0470   01CF C9           ret
0471   01D0             ; end of setDDRAMa
0472   01D0             
0473   01D0             ; *** key_scan
0474   01D0             ; Tests all keys on keyboard and if finds a pressed key
0475   01D0             ; then aborts the loop and returns that key's value
0476   01D0             ; in reg a
0477   01D0             key_scan:
0478   01D0 3E FE        ld a,%11111110
0479   01D2 D3 05        out (KeyS),a
0480   01D4 DB 06        in a,(KeyR)
0481   01D6 CB 47        bit 0,a
0482   01D8 CA 51 05     jp z,key_Enter
0483   01DB CB 4F        bit 1,a
0484   01DD CA 4B 05     jp z,key_CK5
0485   01E0 CB 57        bit 2,a
0486   01E2 CA 45 05     jp z,key_CK3
0487   01E5 CB 5F        bit 3,a
0488   01E7 CA 3F 05     jp z,key_CK1
0489   01EA 3E FD        ld a,%11111101
0490   01EC D3 05        out (KeyS),a
0491   01EE DB 06        in a,(KeyR)
0492   01F0             ; bit 0,a
0493   01F0             ; jp z,key_Shift
0494   01F0 CB 4F        bit 1,a
0495   01F2 CA 48 05     jp z,key_CK4
0496   01F5 CB 57        bit 2,a
0497   01F7 CA 42 05     jp z,key_CK2
0498   01FA CB 5F        bit 3,a
0499   01FC CA 3C 05     jp z,key_CK0
0500   01FF 3E FB        ld a,%11111011
0501   0201 D3 05        out (KeyS),a
0502   0203 DB 06        in a,(KeyR)
0503   0205 CB 47        bit 0,a
0504   0207 CA 39 05     jp z,key_f
0505   020A CB 4F        bit 1,a
0506   020C CA 2D 05     jp z,key_b
0507   020F CB 57        bit 2,a
0508   0211 CA 21 05     jp z,key_7
0509   0214 CB 5F        bit 3,a
0510   0216 CA 15 05     jp z,key_3
0511   0219 3E F7        ld a,%11110111
0512   021B D3 05        out (KeyS),a
0513   021D DB 06        in a,(KeyR)
0514   021F CB 47        bit 0,a
0515   0221 CA 36 05     jp z,key_e
0516   0224 CB 4F        bit 1,a
0517   0226 CA 2A 05     jp z,key_a
0518   0229 CB 57        bit 2,a
0519   022B CA 1E 05     jp z,key_6
0520   022E CB 5F        bit 3,a  
0521   0230 CA 12 05     jp z,key_2
0522   0233 3E EF        ld a,%11101111
0523   0235 D3 05        out (KeyS),a
0524   0237 DB 06        in a,(KeyR)
0525   0239 CB 47        bit 0,a
0526   023B CA 33 05     jp z,key_d
0527   023E CB 4F        bit 1,a
0528   0240 CA 27 05     jp z,key_9
0529   0243 CB 57        bit 2,a
0530   0245 CA 1B 05     jp z,key_5
0531   0248 CB 5F        bit 3,a
0532   024A CA 0F 05     jp z,key_1
0533   024D 3E DF        ld a,%11011111
0534   024F D3 05        out (KeyS),a
0535   0251 DB 06        in a,(KeyR)
0536   0253 CB 47        bit 0,a
0537   0255 CA 30 05     jp z,key_c
0538   0258 CB 4F        bit 1,a
0539   025A CA 24 05     jp z,key_8
0540   025D CB 57        bit 2,a
0541   025F CA 18 05     jp z,key_4
0542   0262 CB 5F        bit 3,a  
0543   0264 CA 0C 05     jp z,key_0
0544   0267             ; no key was pressed, load $ff into reg a
0545   0267             ; for mark of that
0546   0267 3E FF        ld a,$ff
0547   0269 C9           ret
0548   026A             ; end of key_scan
0549   026A             
0550   026A             ; *** key_testshift
0551   026A             ; Test Shift's current status
0552   026A             ; Result is returned in Z-flag
0553   026A             key_testshift:
0554   026A C5           push bc
0555   026B 47           ld b,a
0556   026C 3E FD        ld a,%11111101
0557   026E D3 05        out (KeyS),a
0558   0270 DB 06        in a,(KeyR)
0559   0272 CB 47        bit 0,a
0560   0274 78           ld a,b
0561   0275 C1           pop bc
0562   0276 C9           ret
0563   0277             ; end of key_testshift
0564   0277             
0565   0277             ; *** key_getkey
0566   0277             key_getkey:
0567   0277 E5           push hl
0568   0278 3A 20 EA     ld a,(key_delay)
0569   027B 32 1F EA     ld (key_timer),a
0570   027E 3A 2A EA     ld a,(key_rset)
0571   0281 FE FF        cp $ff
0572   0283 20 11        jr nz,gk_loop
0573   0285 3E 00        ld a,$00
0574   0287 32 2A EA     ld (key_rset),a
0575   028A 2A 22 EA     ld hl,(key_repeatdelay)
0576   028D 22 26 EA     ld (key_rd),hl
0577   0290 2A 24 EA     ld hl,(key_repeatrate)
0578   0293 22 28 EA     ld (key_rr),hl
0579   0296             gk_loop:
0580   0296 CD D0 01     call key_scan
0581   0299 FE FF        cp none
0582   029B 20 29        jr nz,gk_key        ; Some key was pressed
0583   029D 3A 1E EA     ld a,(key_pressed)
0584   02A0 FE FF        cp none
0585   02A2 28 F2        jr z,gk_loop
0586   02A4 2A 22 EA     ld hl,(key_repeatdelay)
0587   02A7 22 26 EA     ld (key_rd),hl
0588   02AA 2A 24 EA     ld hl,(key_repeatrate)
0589   02AD 22 28 EA     ld (key_rr),hl
0590   02B0 3A 1F EA     ld a,(key_timer)
0591   02B3 3D           dec a
0592   02B4 32 1F EA     ld (key_timer),a
0593   02B7 20 DD        jr nz,gk_loop
0594   02B9 3E FF        ld a,none
0595   02BB 32 1E EA     ld (key_pressed),a
0596   02BE 3A 20 EA     ld a,(key_delay)
0597   02C1 32 1F EA     ld (key_timer),a
0598   02C4 18 D0        jr gk_loop
0599   02C6             ;
0600   02C6             gk_key:
0601   02C6 32 21 EA     ld (key_press),a    ;
0602   02C9 3A 1E EA     ld a,(key_pressed)  ; Test if this key was pressed earlier
0603   02CC 21 21 EA     ld hl,key_press     ;
0604   02CF BE           cp (hl)             ;
0605   02D0 20 30        jr nz,gk_nkey
0606   02D2 2A 22 EA     ld hl,(key_repeatdelay)
0607   02D5 3E 00        ld a,0
0608   02D7 BC           cp h
0609   02D8 20 06        jr nz,gk_delay
0610   02DA BD           cp l
0611   02DB 20 03        jr nz,gk_delay
0612   02DD C3 96 02     jp gk_loop
0613   02E0             gk_delay:
0614   02E0 2A 26 EA     ld hl,(key_rd)
0615   02E3 BC           cp h
0616   02E4 20 0E        jr nz,gk_dntr
0617   02E6 BD           cp l
0618   02E7 20 0B        jr nz,gk_dntr
0619   02E9 2A 28 EA     ld hl,(key_rr)
0620   02EC BC           cp h
0621   02ED 20 0C        jr nz,gk_rntr
0622   02EF BD           cp l
0623   02F0 20 09        jr nz,gk_rntr
0624   02F2 18 0E        jr gk_nkey
0625   02F4             gk_dntr:
0626   02F4 2B           dec hl
0627   02F5 22 26 EA     ld (key_rd),hl
0628   02F8 C3 96 02     jp gk_loop
0629   02FB             gk_rntr:
0630   02FB 2B           dec hl
0631   02FC 22 28 EA     ld (key_rr),hl
0632   02FF C3 96 02     jp gk_loop
0633   0302             ;
0634   0302             gk_nkey:
0635   0302 3A 21 EA     ld a,(key_press)
0636   0305 32 1E EA     ld (key_pressed),a
0637   0308 E1           pop hl
0638   0309 C9           ret
0639   030A             ; end of key_getkey
0640   030A             
0641   030A             ; *** key_getbyte
0642   030A             ; Uses the LCD to get word-value from the user
0643   030A             ; Default value should be stored into b, value
0644   030A             ; given is also returned in b
0645   030A             ; In a is the key which was pressed to get here
0646   030A             key_getbyte:
0647   030A F5           push af
0648   030B E5           push hl
0649   030C CD 7E 01     call clear_lcd
0650   030F 3E 00        ld a,Line1
0651   0311 CD C7 01     call setDDRAMa
0652   0314 21 3D 13     ld hl,s_inputbyte
0653   0317 CD 86 01     call str2lcd
0654   031A E1           pop hl
0655   031B F1           pop af
0656   031C             ; If there is need for own start string, then
0657   031C             ; jump here after setting that
0658   031C             key_getbvalue:
0659   031C D5           push de
0660   031D E5           push hl
0661   031E 50           ld d,b
0662   031F 58           ld e,b
0663   0320 32 1E EA     ld (key_pressed),a
0664   0323 3E 40        ld a,Line2
0665   0325 CD C7 01     call setDDRAMa
0666   0328 06 3E        ld b,'>'
0667   032A CD 3F 01     call char2lcd
0668   032D 7A           ld a,d
0669   032E CD FE 00     call byte2lcd
0670   0331 3E 41        ld a,Line2+1
0671   0333 CD C7 01     call setDDRAMa
0672   0336 06 01        ld b,1
0673   0338 3E 80        ld a,FastKeyDelay
0674   033A 32 20 EA     ld (key_delay),a
0675   033D             ;
0676   033D             gb_loop:
0677   033D CD 77 02     call key_getkey
0678   0340             ;
0679   0340 FE 10        cp $10
0680   0342 DA 8B 03     jp c,gb_number
0681   0345 FE 17        cp Enter
0682   0347 20 06        jr nz,gb_nEnter
0683   0349 42           ld b,d
0684   034A 3E 17        ld a,Enter
0685   034C C3 DE 03     jp gb_end
0686   034F             gb_nEnter:
0687   034F FE 15        cp CK5
0688   0351 C2 5A 03     jp nz,gb_nundo
0689   0354 53           ld d,e
0690   0355 3E 15        ld a,CK5
0691   0357 C3 DE 03     jp gb_end
0692   035A             gb_nundo:
0693   035A FE 10        cp CK0
0694   035C CA 67 03     jp z,gb_left
0695   035F FE 11        cp CK1
0696   0361 CA 79 03     jp z,gb_right
0697   0364 C3 3D 03     jp gb_loop
0698   0367             ;
0699   0367             gb_left:
0700   0367 3E 01        ld a,1
0701   0369 B8           cp b
0702   036A CA 3D 03     jp z,gb_loop
0703   036D 04           inc b
0704   036E 3E 01        ld a,1
0705   0370 90           sub b
0706   0371 C6 41        add a,Line2+1
0707   0373 CD C7 01     call setDDRAMa
0708   0376 C3 3D 03     jp gb_loop
0709   0379             ;
0710   0379             gb_right:
0711   0379 3E 00        ld a,0
0712   037B B8           cp b
0713   037C CA 3D 03     jp z,gb_loop
0714   037F 05           dec b
0715   0380 3E 01        ld a,1
0716   0382 90           sub b
0717   0383 C6 41        add a,Line2+1
0718   0385 CD C7 01     call setDDRAMa
0719   0388 C3 3D 03     jp gb_loop
0720   038B             ;
0721   038B             gb_number:
0722   038B 6F           ld l,a
0723   038C 78           ld a,b
0724   038D             ;
0725   038D FE 01        cp 1
0726   038F 20 21        jr nz,gb_n1
0727   0391 7D           ld a,l
0728   0392 CB 27        sla a
0729   0394 CB 27        sla a
0730   0396 CB 27        sla a
0731   0398 CB 27        sla a
0732   039A E6 F0        and $f0
0733   039C 6F           ld l,a
0734   039D 7A           ld a,d
0735   039E E6 0F        and $0f
0736   03A0 B5           or l
0737   03A1 57           ld d,a
0738   03A2 7D           ld a,l
0739   03A3 CB 3F        srl a
0740   03A5 CB 3F        srl a
0741   03A7 CB 3F        srl a
0742   03A9 CB 3F        srl a
0743   03AB 05           dec b
0744   03AC CD CB 03     call gb_setadda
0745   03AF C3 3D 03     jp gb_loop
0746   03B2             ;
0747   03B2             gb_n1:
0748   03B2 FE 00        cp 0
0749   03B4 20 25        jr nz,gb_n0
0750   03B6 7D           ld a,l
0751   03B7 E6 0F        and $0f
0752   03B9 6F           ld l,a
0753   03BA 7A           ld a,d
0754   03BB E6 F0        and $f0
0755   03BD B5           or l
0756   03BE 57           ld d,a
0757   03BF 7D           ld a,l
0758   03C0 CD CB 03     call gb_setadda
0759   03C3 3E 42        ld a,Line2+2
0760   03C5 CD C7 01     call setDDRAMa
0761   03C8 C3 3D 03     jp gb_loop
0762   03CB             ;
0763   03CB             gb_setadda:
0764   03CB C5           push bc
0765   03CC 06 00        ld b,0
0766   03CE E5           push hl
0767   03CF 21 4A 14     ld hl,hextolcd
0768   03D2 4F           ld c,a
0769   03D3 09           add hl,bc
0770   03D4 46           ld b,(hl)
0771   03D5 CD 3F 01     call char2lcd
0772   03D8 E1           pop hl
0773   03D9 C1           pop bc
0774   03DA C9           ret
0775   03DB             ;
0776   03DB             gb_n0:
0777   03DB C3 DE 03     jp gb_end
0778   03DE             ;
0779   03DE             gb_end:
0780   03DE E1           pop hl
0781   03DF D1           pop de
0782   03E0 C9           ret
0783   03E1             ; end of key_getbyte
0784   03E1             
0785   03E1             ; *** key_getaddress
0786   03E1             ; Uses the LCD to get word-value from the user
0787   03E1             ; Default value should be stored into hl, value
0788   03E1             ; given is also returned in hl
0789   03E1             ; In a is the key which was pressed to get here
0790   03E1             key_getaddress:
0791   03E1 F5           push af
0792   03E2 E5           push hl
0793   03E3 CD 7E 01     call clear_lcd
0794   03E6 3E 00        ld a,Line1
0795   03E8 CD C7 01     call setDDRAMa
0796   03EB 21 24 13     ld hl,s_inputaddress
0797   03EE CD 86 01     call str2lcd
0798   03F1 E1           pop hl
0799   03F2 F1           pop af
0800   03F3 CD 09 04     call key_getwvalue
0801   03F6 C9           ret
0802   03F7             ; end of key_getaddress
0803   03F7             
0804   03F7             ; *** key_getword
0805   03F7             ; Uses the LCD to get word-value from the user
0806   03F7             ; Default value should be stored into hl, value
0807   03F7             ; given is also returned in hl
0808   03F7             ; In a is the key which was pressed to get here
0809   03F7             key_getword:
0810   03F7 F5           push af
0811   03F8 E5           push hl
0812   03F9 CD 7E 01     call clear_lcd
0813   03FC 3E 00        ld a,Line1
0814   03FE CD C7 01     call setDDRAMa
0815   0401 21 32 13     ld hl,s_inputword
0816   0404 CD 86 01     call str2lcd
0817   0407 E1           pop hl
0818   0408 F1           pop af
0819   0409             ; If there is need for own start string, then
0820   0409             ; jump here after setting that
0821   0409             key_getwvalue:
0822   0409 C5           push bc
0823   040A D5           push de
0824   040B 54           ld d,h
0825   040C 5D           ld e,l
0826   040D 32 1E EA     ld (key_pressed),a
0827   0410 3E 40        ld a,Line2
0828   0412 CD C7 01     call setDDRAMa
0829   0415 06 3E        ld b,'>'
0830   0417 CD 3F 01     call char2lcd
0831   041A 7C           ld a,h
0832   041B CD FE 00     call byte2lcd
0833   041E 7D           ld a,l
0834   041F CD FE 00     call byte2lcd
0835   0422 3E 41        ld a,Line2+1
0836   0424 CD C7 01     call setDDRAMa
0837   0427 06 03        ld b,3
0838   0429 3E 80        ld a,FastKeyDelay
0839   042B 32 20 EA     ld (key_delay),a
0840   042E             ;
0841   042E             gw_loop:
0842   042E CD 77 02     call key_getkey
0843   0431             ;
0844   0431 FE 10        cp $10
0845   0433 DA 7C 04     jp c,gw_number
0846   0436 FE 17        cp Enter
0847   0438 20 05        jr nz,gw_nEnter
0848   043A 3E 17        ld a,Enter
0849   043C C3 09 05     jp gw_end
0850   043F             gw_nEnter:
0851   043F FE 15        cp CK5
0852   0441 C2 4B 04     jp nz,gw_nundo
0853   0444 62           ld h,d
0854   0445 6B           ld l,e
0855   0446 3E 15        ld a,CK5
0856   0448 C3 09 05     jp gw_end
0857   044B             gw_nundo:
0858   044B FE 10        cp CK0
0859   044D CA 58 04     jp z,gw_left
0860   0450 FE 11        cp CK1
0861   0452 CA 6A 04     jp z,gw_right
0862   0455 C3 2E 04     jp gw_loop
0863   0458             ;
0864   0458             gw_left:
0865   0458 3E 03        ld a,3
0866   045A B8           cp b
0867   045B CA 2E 04     jp z,gw_loop
0868   045E 04           inc b
0869   045F 3E 03        ld a,3
0870   0461 90           sub b
0871   0462 C6 41        add a,Line2+1
0872   0464 CD C7 01     call setDDRAMa
0873   0467 C3 2E 04     jp gw_loop
0874   046A             ;
0875   046A             gw_right:
0876   046A 3E 00        ld a,0
0877   046C B8           cp b
0878   046D CA 2E 04     jp z,gw_loop
0879   0470 05           dec b
0880   0471 3E 03        ld a,3
0881   0473 90           sub b
0882   0474 C6 41        add a,Line2+1
0883   0476 CD C7 01     call setDDRAMa
0884   0479 C3 2E 04     jp gw_loop
0885   047C             ;
0886   047C             gw_number:
0887   047C 4F           ld c,a
0888   047D 78           ld a,b
0889   047E             ;
0890   047E FE 03        cp 3
0891   0480 20 21        jr nz,gw_n3
0892   0482 79           ld a,c
0893   0483 CB 27        sla a
0894   0485 CB 27        sla a
0895   0487 CB 27        sla a
0896   0489 CB 27        sla a
0897   048B E6 F0        and $f0
0898   048D 4F           ld c,a
0899   048E 7C           ld a,h
0900   048F E6 0F        and $0f
0901   0491 B1           or c
0902   0492 67           ld h,a
0903   0493 79           ld a,c
0904   0494 CB 3F        srl a
0905   0496 CB 3F        srl a
0906   0498 CB 3F        srl a
0907   049A CB 3F        srl a
0908   049C 05           dec b
0909   049D CD F6 04     call gw_setadda
0910   04A0 C3 2E 04     jp gw_loop
0911   04A3             ;
0912   04A3             gw_n3:
0913   04A3 FE 02        cp 2
0914   04A5 20 11        jr nz,gw_n2
0915   04A7 79           ld a,c
0916   04A8 E6 0F        and $0f
0917   04AA 4F           ld c,a
0918   04AB 7C           ld a,h
0919   04AC E6 F0        and $f0
0920   04AE B1           or c
0921   04AF 67           ld h,a
0922   04B0 79           ld a,c
0923   04B1 05           dec b
0924   04B2 CD F6 04     call gw_setadda
0925   04B5 C3 2E 04     jp gw_loop
0926   04B8             ;
0927   04B8             gw_n2:
0928   04B8 FE 01        cp 1
0929   04BA 20 21        jr nz,gw_n1
0930   04BC 79           ld a,c
0931   04BD CB 27        sla a
0932   04BF CB 27        sla a
0933   04C1 CB 27        sla a
0934   04C3 CB 27        sla a
0935   04C5 E6 F0        and $f0
0936   04C7 4F           ld c,a
0937   04C8 7D           ld a,l
0938   04C9 E6 0F        and $0f
0939   04CB B1           or c
0940   04CC 6F           ld l,a
0941   04CD 79           ld a,c
0942   04CE CB 3F        srl a
0943   04D0 CB 3F        srl a
0944   04D2 CB 3F        srl a
0945   04D4 CB 3F        srl a
0946   04D6 05           dec b
0947   04D7 CD F6 04     call gw_setadda
0948   04DA C3 2E 04     jp gw_loop
0949   04DD             ;
0950   04DD             gw_n1:
0951   04DD FE 00        cp 0
0952   04DF 20 25        jr nz,gw_n0
0953   04E1 79           ld a,c
0954   04E2 E6 0F        and $0f
0955   04E4 4F           ld c,a
0956   04E5 7D           ld a,l
0957   04E6 E6 F0        and $f0
0958   04E8 B1           or c
0959   04E9 6F           ld l,a
0960   04EA 79           ld a,c
0961   04EB CD F6 04     call gw_setadda
0962   04EE 3E 44        ld a,Line2+4
0963   04F0 CD C7 01     call setDDRAMa
0964   04F3 C3 2E 04     jp gw_loop
0965   04F6             ;
0966   04F6             gw_setadda:
0967   04F6 C5           push bc
0968   04F7 06 00        ld b,0
0969   04F9 E5           push hl
0970   04FA 21 4A 14     ld hl,hextolcd
0971   04FD 4F           ld c,a
0972   04FE 09           add hl,bc
0973   04FF 46           ld b,(hl)
0974   0500 CD 3F 01     call char2lcd
0975   0503 E1           pop hl
0976   0504 C1           pop bc
0977   0505 C9           ret
0978   0506             ;
0979   0506             gw_n0:
0980   0506 C3 09 05     jp gw_end
0981   0509             ;
0982   0509             gw_end:
0983   0509 D1           pop de
0984   050A C1           pop bc
0985   050B C9           ret
0986   050C             ; end of key_getword
0987   050C             
0988   050C             ; Jump-table for key-routines to get the key value into reg a
0989   050C             key_0:
0990   050C 3E 00        ld a,key0
0991   050E C9           ret
0992   050F             key_1:
0993   050F 3E 01        ld a,key1
0994   0511 C9           ret
0995   0512             key_2:
0996   0512 3E 02        ld a,key2
0997   0514 C9           ret
0998   0515             key_3:
0999   0515 3E 03        ld a,key3
1000   0517 C9           ret
1001   0518             key_4:
1002   0518 3E 04        ld a,key4
1003   051A C9           ret
1004   051B             key_5:
1005   051B 3E 05        ld a,key5
1006   051D C9           ret
1007   051E             key_6:
1008   051E 3E 06        ld a,key6
1009   0520 C9           ret
1010   0521             key_7:
1011   0521 3E 07        ld a,key7
1012   0523 C9           ret
1013   0524             key_8:
1014   0524 3E 08        ld a,key8
1015   0526 C9           ret
1016   0527             key_9:
1017   0527 3E 09        ld a,key9
1018   0529 C9           ret
1019   052A             key_a:
1020   052A 3E 0A        ld a,keya
1021   052C C9           ret
1022   052D             key_b:
1023   052D 3E 0B        ld a,keyb
1024   052F C9           ret
1025   0530             key_c:
1026   0530 3E 0C        ld a,keyc
1027   0532 C9           ret
1028   0533             key_d:
1029   0533 3E 0D        ld a,keyd
1030   0535 C9           ret
1031   0536             key_e:
1032   0536 3E 0E        ld a,keye
1033   0538 C9           ret
1034   0539             key_f:
1035   0539 3E 0F        ld a,keyf
1036   053B C9           ret
1037   053C             key_CK0:
1038   053C 3E 10        ld a,CK0
1039   053E C9           ret
1040   053F             key_CK1:
1041   053F 3E 11        ld a,CK1
1042   0541 C9           ret
1043   0542             key_CK2:
1044   0542 3E 12        ld a,CK2
1045   0544 C9           ret
1046   0545             key_CK3:
1047   0545 3E 13        ld a,CK3
1048   0547 C9           ret
1049   0548             key_CK4:
1050   0548 3E 14        ld a,CK4
1051   054A C9           ret
1052   054B             key_CK5:
1053   054B 3E 15        ld a,CK5
1054   054D C9           ret
1055   054E             key_Shift:
1056   054E 3E 16        ld a,Shift
1057   0550 C9           ret
1058   0551             key_Enter:
1059   0551 3E 17        ld a,Enter
1060   0553 C9           ret
1061   0554             ; end of key-jump-table
1062   0554             
1063   0554~            #ifdef CPU_AT_2MHZ
1064   0554~            ; *** Delayms
1065   0554~            ; This loop waits amount of milliseconds which is stored in de
1066   0554~            ; CPU should run @2MHz
1067   0554~            ; There is always spend some extra clocks when this delay is initialized
1068   0554~            ; and when it ends.
1069   0554~            Delayms:        ; Clocks spend in instructions and time
1070   0554~             push af        ; 11 / 
1071   0554~             push bc        ; 11 / 
1072   0554~             push de        ; 11 / 
1073   0554~             push ix        ; 15 / 
1074   0554~             xor a          ; 4 / 
1075   0554~             inc d          ; 4 / 
1076   0554~             ld bc,40|$100 ; 10 /
1077   0554~            Delayms0:       ; = 66 /
1078   0554~            ; Here should be used enough clocks that one loop
1079   0554~            ; would spend 1ms! NOP is not an option :)
1080   0554~             dec ix         ; 10 /
1081   0554~             nop            ; 4 /
1082   0554~             nop            ; 4 /
1083   0554~             nop            ; 4 /
1084   0554~             nop            ; 4 /
1085   0554~             dec bc         ; 6 /
1086   0554~             cp b           ; 4 / 
1087   0554~             jr nz,Delayms0 ; 12 /
1088   0554~                            ; = 48 / 24us
1089   0554~            ; There goes 984us and rest of the 1000us is spend here
1090   0554~             ld bc,40|$100 ; 10 / 
1091   0554~             dec de         ; 6 / 
1092   0554~             cp d           ; 4 / 
1093   0554~             jr nz,Delayms0 ; 12 / 
1094   0554~                            ; = 32 / 16us
1095   0554~             pop ix         ; 14 / 
1096   0554~             pop de         ; 10 / 
1097   0554~             pop bc         ; 10 / 
1098   0554~             pop af         ; 10 / 
1099   0554~             ret            ; 10 / 
1100   0554~                            ; = 54 / 
1101   0554~            ; end of Delayms
1102   0554             #endif
1103   0554             
1104   0554             #ifdef CPU_AT_4MHZ
1105   0554             ; *** Delayms
1106   0554             ; This loop waits amount of milliseconds which is stored in de
1107   0554             ; CPU should run @4MHz
1108   0554             ; There is always spend some extra clocks when this delay is initialized
1109   0554             ; and when it ends. These actions takes 30us+4.25us for calling
1110   0554             Delayms:        ; Clocks spend in instructions and time
1111   0554 F5           push af        ; 11 / 2.75us
1112   0555 C5           push bc        ; 11 / 2.75us
1113   0556 D5           push de        ; 11 / 2.75us
1114   0557 DD E5        push ix        ; 15 / 3.75us
1115   0559 AF           xor a          ; 4 / 1us
1116   055A 14           inc d          ; 4 / 1us , becose 1ms should be 1ms and so on...
1117   055B 01 7B 01     ld bc,123|$100 ; 10 / 2.5us
1118   055E             Delayms0:       ; = 66 / 16.5us
1119   055E             ; Here should be used enough clocks that one loop
1120   055E             ; would spend 1ms! NOP is not an option :)
1121   055E DD 2B        dec ix         ; 10 / 2.5us
1122   0560 0B           dec bc         ; 6 /1.5us
1123   0561 B8           cp b           ; 4 / 1us
1124   0562 20 FA        jr nz,Delayms0 ; 12 / 3us
1125   0564                             ; = 32 / 8us
1126   0564             ; There goes 992us and rest 8us of 1000us is spend here
1127   0564 01 7B 01     ld bc,123|$100 ; 10 / 2.5us
1128   0567 1B           dec de         ; 6 / 1.5us
1129   0568 BA           cp d           ; 4 / 1us
1130   0569 20 F3        jr nz,Delayms0 ; 12 / 3us
1131   056B                             ; = 32 / 8us
1132   056B DD E1        pop ix         ; 14 / 3.5us
1133   056D D1           pop de         ; 10 / 2.5us
1134   056E C1           pop bc         ; 10 / 2.5us
1135   056F F1           pop af         ; 10 / 2.5us
1136   0570 C9           ret            ; 10 / 2.5us
1137   0571                             ; = 54 / 13.5us
1138   0571             ; end of Delayms
1139   0571             #endif
1140   0571~            #ifdef CPU_AT_8MHZ
1141   0571~            ; *** Delayms
1142   0571~            ; This loop waits amount of milliseconds which is stored in de
1143   0571~            ; CPU should run @4MHz
1144   0571~            ; There is always spend some extra clocks when this delay is initialized
1145   0571~            ; and when it ends.
1146   0571~            Delayms:        ; Clocks spend in instructions and time
1147   0571~             push af        ; 11 / 1.375us
1148   0571~             push bc        ; 11 / 1.375us
1149   0571~             push de        ; 11 / 1.375us
1150   0571~             push ix        ; 15 / 1.875us
1151   0571~             xor a          ; 4 / 0.5us
1152   0571~             inc d          ; 4 / 0.5us , becose 1ms should be 1ms and so on...
1153   0571~             ld bc,199|$100 ; 10 / 1.25us
1154   0571~            Delayms0:       ; = 66 / 8.25us
1155   0571~            ; Here should be used enough clocks that one loop
1156   0571~            ; would spend 1ms! NOP is not an option :)
1157   0571~             nop            ; 4 / 0.5us
1158   0571~             nop            ; 4 / 0.5us
1159   0571~             dec ix         ; 10 / 1.25us
1160   0571~             dec bc         ; 6 / 0.75us
1161   0571~             cp b           ; 4 / 0.5us
1162   0571~             jr nz,Delayms0 ; 12 / 1.5us
1163   0571~                            ; = 40 / 5us
1164   0571~            ; There goes 995us and rest 5us of 1000us is spend here
1165   0571~             nop            ; 4 / 0.5us
1166   0571~             nop            ; 4 / 0.5us
1167   0571~             ld bc,199|$100 ; 10 / 1.25us
1168   0571~             dec de         ; 6 / 0.75us
1169   0571~             cp d           ; 4 / 0.5us
1170   0571~             jr nz,Delayms0 ; 12 / 1.5us
1171   0571~                            ; = 40 / 5us
1172   0571~             pop ix         ; 14 / 1.75us
1173   0571~             pop de         ; 10 / 1.25us
1174   0571~             pop bc         ; 10 / 1.25us
1175   0571~             pop af         ; 10 / 1.25us
1176   0571~             ret            ; 10 / 1.25us
1177   0571~                            ; = 54 / 6.625us
1178   0571~            ; end of Delayms
1179   0571             #endif
1180   0571             
1181   0571             ; *** CreateLog
1182   0571             ; Creates a log into log memory if there is enough space left
1183   0571             ; Log size in h as amount of 256B slices
1184   0571             ; Returns logs id in reg a, if a is 0 the there was no space left to create log
1185   0571             ; or there was too many logs
1186   0571             CreateLog:
1187   0571 3A 3C EA     ld a,(logs_curid)
1188   0574 FE 08        cp MAX_LOGS
1189   0576 3E 00        ld a,0
1190   0578 C8           ret z
1191   0579 BC           cp h
1192   057A C8           ret z
1193   057B 2E 00        ld l,0
1194   057D C5           push bc
1195   057E D5           push de
1196   057F E5           push hl
1197   0580 ED 5B 3E EA  ld de,(logs_cur)
1198   0584 01 00 F0     ld bc,$10000-LOG_MEMORY_SIZE
1199   0587 19           add hl,de
1200   0588 38 2F        jr c,cl_end
1201   058A 09           add hl,bc
1202   058B 38 2C        jr c,cl_end
1203   058D E1           pop hl
1204   058E E5           push hl 
1205   058F 19           add hl,de
1206   0590 22 3E EA     ld (logs_cur),hl
1207   0593 01 80 EC     ld bc,logs
1208   0596 09           add hl,bc
1209   0597 2B           dec hl
1210   0598 3E 18        ld a,EOLOG
1211   059A 77           ld (hl),a
1212   059B 2B           dec hl
1213   059C 3E 17        ld a,EOL
1214   059E 77           ld (hl),a
1215   059F             ; ex de,hl
1216   059F             ; add hl,bc
1217   059F             ; ld a,EOLOG
1218   059F             ; ld (hl),a
1219   059F 3A 3C EA     ld a,(logs_curid)
1220   05A2 3C           inc a
1221   05A3 32 3C EA     ld (logs_curid),a
1222   05A6 CB 27        sla a
1223   05A8 21 40 EA     ld hl,logs_ids
1224   05AB 06 00        ld b,0
1225   05AD 4F           ld c,a
1226   05AE 09           add hl,bc
1227   05AF ED 5B 3E EA  ld de,(logs_cur)
1228   05B3 73           ld (hl),e
1229   05B4 23           inc hl
1230   05B5 72           ld (hl),d
1231   05B6 3A 3C EA     ld a,(logs_curid)
1232   05B9             cl_end:
1233   05B9 E1           pop hl
1234   05BA D1           pop de
1235   05BB C1           pop bc
1236   05BC C9           ret
1237   05BD             ; end of CreateLog
1238   05BD             
1239   05BD             ; *** AddLog
1240   05BD             ; Logs id in reg a and add string's address in hl
1241   05BD             ; String lenght should not be more than 255 chars
1242   05BD             AddLog:
1243   05BD F5           push af
1244   05BE C5           push bc
1245   05BF D5           push de
1246   05C0 47           ld b,a
1247   05C1 3A 3C EA     ld a,(logs_curid)
1248   05C4 B8           cp b
1249   05C5 DA 34 06     jp c,al_end
1250   05C8 AF           xor a
1251   05C9 B8           cp b
1252   05CA CA 34 06     jp z,al_end
1253   05CD 3A 3D EA     ld a,(logs_status)
1254   05D0 FE 01        cp log_adding
1255   05D2 CA 34 06     jp z,al_end
1256   05D5 F6 01        or log_adding
1257   05D7 32 3D EA     ld (logs_status),a
1258   05DA             ; If string lenght is more than 255 chars this loop fails
1259   05DA             ; Failure is not fatal anyway, so let the 'user' do the checking
1260   05DA             ; for lenght of the string
1261   05DA 0E 00        ld c,0
1262   05DC             al_cnts:
1263   05DC 7E           ld a,(hl)
1264   05DD 23           inc hl
1265   05DE 0C           inc c
1266   05DF DA E7 05     jp c,al_cntover
1267   05E2 FE 17        cp EOL
1268   05E4 C2 DC 05     jp nz,al_cnts
1269   05E7             al_cntover:
1270   05E7 2B           dec hl
1271   05E8 2B           dec hl
1272   05E9 0D           dec c
1273   05EA CA 34 06     jp z,al_end
1274   05ED E5           push hl
1275   05EE C5           push bc
1276   05EF CB 20        sla b
1277   05F1 05           dec b
1278   05F2 05           dec b
1279   05F3 16 00        ld d,0
1280   05F5 58           ld e,b
1281   05F6 21 40 EA     ld hl,logs_ids
1282   05F9 19           add hl,de
1283   05FA 5E           ld e,(hl)
1284   05FB 23           inc hl
1285   05FC 56           ld d,(hl)
1286   05FD 23           inc hl
1287   05FE 79           ld a,c
1288   05FF 4E           ld c,(hl)
1289   0600 23           inc hl
1290   0601 46           ld b,(hl)
1291   0602 26 00        ld h,0
1292   0604 6F           ld l,a
1293   0605 19           add hl,de
1294   0606 E5           push hl
1295   0607 79           ld a,c
1296   0608 95           sub l
1297   0609 4F           ld c,a
1298   060A 78           ld a,b
1299   060B 9C           sbc a,h
1300   060C 47           ld b,a
1301   060D 21 80 EC     ld hl,logs
1302   0610 19           add hl,de
1303   0611 EB           ex de,hl
1304   0612 E1           pop hl
1305   0613 D5           push de
1306   0614 11 80 EC     ld de,logs
1307   0617 19           add hl,de
1308   0618 D1           pop de
1309   0619 ED B0        ldir
1310   061B C1           pop bc
1311   061C CB 20        sla b
1312   061E 16 00        ld d,0
1313   0620 58           ld e,b
1314   0621 21 40 EA     ld hl,logs_ids
1315   0624 19           add hl,de
1316   0625 5E           ld e,(hl)
1317   0626 23           inc hl
1318   0627 56           ld d,(hl)
1319   0628 21 80 EC     ld hl,logs
1320   062B 19           add hl,de
1321   062C 2B           dec hl
1322   062D 2B           dec hl
1323   062E EB           ex de,hl
1324   062F E1           pop hl
1325   0630 06 00        ld b,0
1326   0632 ED B8        lddr
1327   0634             al_end:
1328   0634 3A 3D EA     ld a,(logs_status)
1329   0637 E6 FE        and ~log_adding
1330   0639 32 3D EA     ld (logs_status),a
1331   063C D1           pop de
1332   063D C1           pop bc
1333   063E F1           pop af
1334   063F C9           ret
1335   0640             ; end of AddLog
1336   0640             
1337   0640             ; *** ViewLog
1338   0640             ; Log id in reg a
1339   0640             ViewLog:
1340   0640 F5           push af
1341   0641 C5           push bc
1342   0642 D5           push de
1343   0643 E5           push hl
1344   0644 4F           ld c,a
1345   0645 3A 3C EA     ld a,(logs_curid)
1346   0648 B9           cp c
1347   0649 DA 4B 07     jp c,vl_end
1348   064C AF           xor a
1349   064D B9           cp c
1350   064E CA 4B 07     jp z,vl_end
1351   0651 CB 21        sla c
1352   0653 0D           dec c
1353   0654 0D           dec c
1354   0655 06 00        ld b,0
1355   0657 21 40 EA     ld hl,logs_ids
1356   065A 09           add hl,bc
1357   065B 4E           ld c,(hl)
1358   065C 23           inc hl
1359   065D 46           ld b,(hl)
1360   065E 23           inc hl
1361   065F 5E           ld e,(hl)
1362   0660 23           inc hl
1363   0661 56           ld d,(hl)
1364   0662 7B           ld a,e
1365   0663 91           sub c
1366   0664 4F           ld c,a
1367   0665 7A           ld a,d
1368   0666 98           sbc a,b
1369   0667 47           ld b,a
1370   0668 3E 17        ld a,EOL
1371   066A 21 80 EC     ld hl,logs
1372   066D 19           add hl,de
1373   066E ED B9        cpdr
1374   0670 23           inc hl
1375   0671 23           inc hl
1376   0672 54           ld d,h
1377   0673 5D           ld e,l
1378   0674             ;
1379   0674 CD 5B 01     call reset_lcd
1380   0677 06 0C        ld b,%00001100         ; This sets cursor and cursor blinking off
1381   0679 CD 25 01     call set_lcd
1382   067C             ;
1383   067C CD F0 06     call vl_show
1384   067F             vl_start:
1385   067F 3E 17        ld a,Enter
1386   0681 32 1E EA     ld (key_pressed),a
1387   0684 3E 20        ld a,$20
1388   0686 32 20 EA     ld (key_delay),a
1389   0689 ED 4B 32 EA  ld bc,(RepeatDelay)
1390   068D ED 43 22 EA  ld (key_repeatdelay),bc
1391   0691 ED 4B 34 EA  ld bc,(RepeatRate)
1392   0695 ED 43 24 EA  ld (key_repeatrate),bc
1393   0699 3E FF        ld a,$ff
1394   069B 32 2A EA     ld (key_rset),a
1395   069E             ;
1396   069E             vl_loop:
1397   069E CD 77 02     call key_getkey
1398   06A1             ; Now test which key was pressed
1399   06A1 FE 17        cp Enter
1400   06A3 CA 4B 07     jp z,vl_end
1401   06A6 FE 11        cp CK1
1402   06A8 CA B3 06     jp z,vl_rollup
1403   06AB FE 13        cp CK3
1404   06AD CA D1 06     jp z,vl_rolldown
1405   06B0 C3 9E 06     jp vl_loop
1406   06B3             ;
1407   06B3             vl_rollup:
1408   06B3 7A           ld a,d
1409   06B4 BC           cp h
1410   06B5 20 0C        jr nz,vlu_dec
1411   06B7 7B           ld a,e
1412   06B8 BD           cp l
1413   06B9 20 08        jr nz,vlu_dec
1414   06BB CD F0 06     call vl_show
1415   06BE 3E 11        ld a,CK1
1416   06C0 C3 9E 06     jp vl_loop
1417   06C3             vlu_dec:
1418   06C3 3E 14        ld a,20
1419   06C5             vlu_dec20loop:
1420   06C5 2B           dec hl
1421   06C6 3D           dec a
1422   06C7 20 FC        jr nz,vlu_dec20loop;
1423   06C9 CD F0 06     call vl_show
1424   06CC 3E 11        ld a,CK1
1425   06CE C3 9E 06     jp vl_loop
1426   06D1             ;
1427   06D1             vl_rolldown:
1428   06D1 E5           push hl
1429   06D2 06 14        ld b,20
1430   06D4             vld_inc20loop:
1431   06D4 23           inc hl
1432   06D5 7E           ld a,(hl)
1433   06D6 FE 17        cp EOL
1434   06D8 28 10        jr z,vld_nroll
1435   06DA FE 18        cp EOLOG
1436   06DC 28 0C        jr z,vld_nroll
1437   06DE 05           dec b
1438   06DF 20 F3        jr nz,vld_inc20loop;
1439   06E1 CD F0 06     call vl_show
1440   06E4 3E 13        ld a,CK3
1441   06E6 C1           pop bc
1442   06E7 C3 9E 06     jp vl_loop
1443   06EA             vld_nroll:
1444   06EA 3E 13        ld a,CK3
1445   06EC E1           pop hl
1446   06ED C3 9E 06     jp vl_loop
1447   06F0             ;
1448   06F0             vl_show:
1449   06F0 E5           push hl
1450   06F1 0E 14        ld c,20
1451   06F3 3E 00        ld a,Line1
1452   06F5 CD C7 01     call setDDRAMa
1453   06F8 06 00        ld b,0
1454   06FA CD 97 01     call strn2lcd
1455   06FD 3E 19        ld a,NOEOL
1456   06FF B9           cp c
1457   0700 20 15        jr nz,vl_eolog
1458   0702 E5           push hl
1459   0703 0E 14        ld c,20
1460   0705 3E 40        ld a,Line2
1461   0707 CD C7 01     call setDDRAMa
1462   070A 06 01        ld b,1
1463   070C CD 97 01     call strn2lcd
1464   070F 3E 19        ld a,NOEOL
1465   0711 B9           cp c
1466   0712 20 03        jr nz,vl_eolog
1467   0714 E1           pop hl
1468   0715 E1           pop hl
1469   0716 C9           ret
1470   0717             vl_eolog:
1471   0717 AF           xor a
1472   0718 B8           cp b
1473   0719 28 16        jr z,vle_tend
1474   071B 3E 40        ld a,Line2
1475   071D CD C7 01     call setDDRAMa
1476   0720 21 04 10     ld hl,s_clearline
1477   0723 CD 86 01     call str2lcd
1478   0726 E1           pop hl 
1479   0727 3E 40        ld a,Line2
1480   0729 CD C7 01     call setDDRAMa
1481   072C CD 97 01     call strn2lcd
1482   072F E1           pop hl
1483   0730 C9           ret
1484   0731             vle_tend:
1485   0731 CD 7E 01     call clear_lcd
1486   0734 3E 00        ld a,Line1
1487   0736 CD C7 01     call setDDRAMa
1488   0739 E1           pop hl
1489   073A E5           push hl
1490   073B CD 97 01     call strn2lcd
1491   073E 3E 40        ld a,Line2
1492   0740 CD C7 01     call setDDRAMa
1493   0743 21 04 10     ld hl,s_clearline
1494   0746 CD 86 01     call str2lcd
1495   0749 E1           pop hl
1496   074A C9           ret
1497   074B             ;
1498   074B             vl_end:
1499   074B E1           pop hl
1500   074C D1           pop de
1501   074D C1           pop bc
1502   074E F1           pop af
1503   074F C9           ret
1504   0750             ; end of ViewLog
1505   0750             
1506   0750             ;**************************************************************
1507   0750             ; OS's main code start location
1508   0750             RESET:
1509   0750             ; After Reset we come here
1510   0750             ; Disable interrupts and couple of nops just for safe ;)
1511   0750 F3           di
1512   0751 00           nop
1513   0752 00           nop
1514   0753 00           nop
1515   0754              
1516   0754             ; Testing the 8kB RAM at address $e000-$ffff
1517   0754             ; Address $c000-$dfff also contains a 8kb RAM..
1518   0754             ; Should not be using stack in any way, becose don't
1519   0754             ; know if the memory is OK, or even exists really
1520   0754             ; The error test won't affect on running the os
1521   0754             ; really in any way. It just will inform the user
1522   0754             ; that there is bad memory in the system.
1523   0754 06 FF        ld b,$ff
1524   0756 21 00 20     ld hl,$2000
1525   0759 11 00 E0     ld de,$e000
1526   075C             ; Address pointer de and counter hl have now been set up
1527   075C             ; Start testing:
1528   075C             fill_loop0:
1529   075C 1A           ld a,(de)              ; store the original value into reg c
1530   075D 4F           ld c,a                 ;
1531   075E 3E AA        ld a,%10101010         ; first test pattern
1532   0760 12           ld (de),a
1533   0761 1A           ld a,(de)
1534   0762 FE AA        cp %10101010
1535   0764 79           ld a,c                 ; save the original value back
1536   0765 12           ld (de),a              ;
1537   0766 28 47        jr z,fill0             ; If OK then continue
1538   0768 7A           ld a,d                 ; Otherwise check where the error was found
1539   0769 E6 1C        and %00011100
1540   076B CB 3F        srl a
1541   076D CB 3F        srl a
1542   076F             ; Here is checked which 1kB page of the 8kB has faulty memory
1543   076F             ; The result is stored in register b
1544   076F FE 00        cp 0
1545   0771 28 1C        jr z,z00
1546   0773 FE 01        cp 1
1547   0775 28 1C        jr z,z01
1548   0777 FE 02        cp 2
1549   0779 28 1C        jr z,z02
1550   077B FE 03        cp 3
1551   077D 28 1C        jr z,z03
1552   077F FE 04        cp 4
1553   0781 28 1C        jr z,z04
1554   0783 FE 05        cp 5
1555   0785 28 1C        jr z,z05
1556   0787 FE 06        cp 6
1557   0789 28 1C        jr z,z06
1558   078B FE 07        cp 7
1559   078D 28 1C        jr z,z07
1560   078F             z00:
1561   078F CB 80        res 0,b
1562   0791 18 1C        jr fill0
1563   0793             z01:
1564   0793 CB 88        res 1,b
1565   0795 18 18        jr fill0
1566   0797             z02:
1567   0797 CB 90        res 2,b
1568   0799 18 14        jr fill0
1569   079B             z03:
1570   079B CB 98        res 3,b
1571   079D 18 10        jr fill0
1572   079F             z04:
1573   079F CB A0        res 4,b
1574   07A1 18 0C        jr fill0
1575   07A3             z05:
1576   07A3 CB A8        res 5,b
1577   07A5 18 08        jr fill0
1578   07A7             z06:
1579   07A7 CB B0        res 6,b
1580   07A9 18 04        jr fill0
1581   07AB             z07:
1582   07AB CB B8        res 7,b
1583   07AD 18 00        jr fill0
1584   07AF             
1585   07AF             fill0:
1586   07AF 1A           ld a,(de)              ; store the original value into reg c
1587   07B0 4F           ld c,a                 ;
1588   07B1 3E 55        ld a,%01010101         ; Second test pattern
1589   07B3 12           ld (de),a
1590   07B4 1A           ld a,(de)
1591   07B5 FE 55        cp %01010101
1592   07B7 79           ld a,c                 ; save the original value back
1593   07B8 12           ld (de),a              ;
1594   07B9 28 47        jr z,fill1             ; If OK then continue
1595   07BB 7A           ld a,d                 ; Otherwise check where the error was found
1596   07BC E6 1C        and %00011100
1597   07BE CB 3F        srl a
1598   07C0 CB 3F        srl a
1599   07C2             ; Again checking the 1kB page
1600   07C2 FE 00        cp 0
1601   07C4 28 1C        jr z,z10
1602   07C6 FE 01        cp 1
1603   07C8 28 1C        jr z,z11
1604   07CA FE 02        cp 2
1605   07CC 28 1C        jr z,z12
1606   07CE FE 03        cp 3
1607   07D0 28 1C        jr z,z13
1608   07D2 FE 04        cp 4
1609   07D4 28 1C        jr z,z14
1610   07D6 FE 05        cp 5
1611   07D8 28 1C        jr z,z15
1612   07DA FE 06        cp 6
1613   07DC 28 1C        jr z,z16
1614   07DE FE 07        cp 7
1615   07E0 28 1C        jr z,z17
1616   07E2             z10:
1617   07E2 CB 80        res 0,b
1618   07E4 18 1C        jr fill1
1619   07E6             z11:
1620   07E6 CB 88        res 1,b
1621   07E8 18 18        jr fill1
1622   07EA             z12:
1623   07EA CB 90        res 2,b
1624   07EC 18 14        jr fill1
1625   07EE             z13:
1626   07EE CB 98        res 3,b
1627   07F0 18 10        jr fill1
1628   07F2             z14:
1629   07F2 CB A0        res 4,b
1630   07F4 18 0C        jr fill1
1631   07F6             z15:
1632   07F6 CB A8        res 5,b
1633   07F8 18 08        jr fill1
1634   07FA             z16:
1635   07FA CB B0        res 6,b
1636   07FC 18 04        jr fill1
1637   07FE             z17:
1638   07FE CB B8        res 7,b
1639   0800 18 00        jr fill1
1640   0802              
1641   0802             fill1:
1642   0802 13           inc de
1643   0803 2D           dec l
1644   0804 C2 5C 07     jp nz,fill_loop0
1645   0807             ; Show the current position of test with the 8 LEDs
1646   0807             ; This just for fun ;)
1647   0807 78           ld a,b
1648   0808 CB 3F        srl a
1649   080A CB 3F        srl a
1650   080C CB 3F        srl a
1651   080E CB 3F        srl a
1652   0810 4F           ld c,a
1653   0811 78           ld a,b
1654   0812 CB 27        sla a
1655   0814 CB 27        sla a
1656   0816 CB 27        sla a
1657   0818 CB 27        sla a
1658   081A E6 F0        and $f0
1659   081C B1           or c
1660   081D 4F           ld c,a
1661   081E 7A           ld a,d
1662   081F E6 1C        and %00011100
1663   0821 CB 3F        srl a
1664   0823 CB 3F        srl a
1665   0825             ; Find out the 1kB page
1666   0825 FE 00        cp 0
1667   0827 28 2C        jr z,z24
1668   0829 FE 01        cp 1
1669   082B 28 2C        jr z,z25
1670   082D FE 02        cp 2
1671   082F 28 2C        jr z,z26
1672   0831 FE 03        cp 3
1673   0833 28 2C        jr z,z27
1674   0835 FE 04        cp 4
1675   0837 28 0C        jr z,z20
1676   0839 FE 05        cp 5
1677   083B 28 0C        jr z,z21
1678   083D FE 06        cp 6
1679   083F 28 0C        jr z,z22
1680   0841 FE 07        cp 7
1681   0843 28 0C        jr z,z23
1682   0845             z20:
1683   0845 CB 81        res 0,c
1684   0847 18 1C        jr test_position_end
1685   0849             z21:
1686   0849 CB 89        res 1,c
1687   084B 18 18        jr test_position_end
1688   084D             z22:
1689   084D CB 91        res 2,c
1690   084F 18 14        jr test_position_end
1691   0851             z23:
1692   0851 CB 99        res 3,c
1693   0853 18 10        jr test_position_end
1694   0855             z24:
1695   0855 CB A1        res 4,c
1696   0857 18 0C        jr test_position_end
1697   0859             z25:
1698   0859 CB A9        res 5,c
1699   085B 18 08        jr test_position_end
1700   085D             z26:
1701   085D CB B1        res 6,c
1702   085F 18 04        jr test_position_end
1703   0861             z27:
1704   0861 CB B9        res 7,c
1705   0863 18 00        jr test_position_end
1706   0865             
1707   0865             test_position_end:
1708   0865 79           ld a,c
1709   0866 D3 07        out (LEDs),a
1710   0868 25           dec h
1711   0869 C2 5C 07     jp nz,fill_loop0
1712   086C             
1713   086C             ; End of memory test
1714   086C             ; Show the result of the test with the 8 LEDs
1715   086C 78           ld a,b
1716   086D D3 07        out (LEDs),a
1717   086F             ; If there was found an error from memory in the test
1718   086F             ; then show 'EEEE'-string in the default 7segments
1719   086F FE FF        cp $ff
1720   0871 28 14        jr z,no_error_in_memory
1721   0873 3E C8        ld a,%11001000
1722   0875 D3 01        out (SSeg1),a
1723   0877 D3 02        out (SSeg2),a
1724   0879 D3 03        out (SSeg3),a
1725   087B D3 04        out (SSeg4),a
1726   087D 21 00 0C     ld hl,$0c00
1727   0880             error_delay_loop:
1728   0880 00           nop
1729   0881 2D           dec l
1730   0882 30 FC        jr nc,error_delay_loop
1731   0884 25           dec h
1732   0885 30 F9        jr nc,error_delay_loop
1733   0887             no_error_in_memory:
1734   0887             ; Now we set up the stack pointer
1735   0887 31 F0 FF     ld sp,StackPointerOrigin
1736   088A             ; Start by  initializing and blinking the default 7segments
1737   088A 3E FF        ld a,$ff
1738   088C D3 01        out (SSeg1),a
1739   088E D3 02        out (SSeg2),a
1740   0890 D3 03        out (SSeg3),a
1741   0892 D3 04        out (SSeg4),a
1742   0894             ; Also 'reset' the keyboard, just for safe
1743   0894 D3 05        out (KeyS),a
1744   0896             ; Let's do some blinking
1745   0896 11 F4 01     ld de,500      ; 500ms
1746   0899 CD 54 05     call Delayms   ; Wait a bit when the 7segments are off
1747   089C 3E 00        ld a,0
1748   089E D3 01        out (SSeg1),a
1749   08A0 D3 02        out (SSeg2),a
1750   08A2 D3 03        out (SSeg3),a
1751   08A4 D3 04        out (SSeg4),a
1752   08A6 11 F4 01     ld de,500
1753   08A9 CD 54 05     call Delayms   ; Wait a bit when the 7segments are on
1754   08AC 3E FF        ld a,$ff       ; Then reset the 7segments off
1755   08AE D3 01        out (SSeg1),a
1756   08B0 D3 02        out (SSeg2),a
1757   08B2 D3 03        out (SSeg3),a
1758   08B4 D3 04        out (SSeg4),a
1759   08B6             ; Now the memory error message in the LEDs should have been seeable
1760   08B6             ; enough long time so reset the LEDs also
1761   08B6 3E FF        leds_load($ff)
1761   08B8 D3 07       
1761   08BA 32 86 EB    
1762   08BD             ; Set up timer which creates NMI interrupt for system timing
1763   08BD             ; and clear uptime counter
1764   08BD             ; Set the NMI to happen every 1secs
1765   08BD             ; (Counter 0 clock must be 4MHz)
1766   08BD             ; Counter 0
1767   08BD 3E 37        ld a,%00110111
1768   08BF D3 A3        out (CounterC),a
1769   08C1 3E 00        ld a,$00
1770   08C3 D3 A0        out (Counter0),a
1771   08C5 3E 01        ld a,$01
1772   08C7 D3 A0        out (Counter0),a
1773   08C9             ; Counter 1
1774   08C9 3E 77        ld a,%01110111
1775   08CB D3 A3        out (CounterC),a
1776   08CD 3E 04        ld a,$04
1777   08CF D3 A1        out (Counter1),a
1778   08D1 3E 00        ld a,$00
1779   08D3 D3 A1        out (Counter1),a
1780   08D5             ; Counter 2
1781   08D5 3E B7        ld a,%10110111
1782   08D7 D3 A3        out (CounterC),a
1783   08D9 3E 96        ld a,$96
1784   08DB D3 A2        out (Counter2),a
1785   08DD 3E 99        ld a,$99
1786   08DF D3 A2        out (Counter2),a
1787   08E1             ; Uptime counter
1788   08E1 21 00 00     ld hl,0
1789   08E4 22 80 EB     ld (uptime),hl
1790   08E7 22 82 EB     ld (uptime+2),hl
1791   08EA 22 84 EB     ld (uptime+4),hl
1792   08ED             ; Set flash to page 0
1793   08ED AF           xor a
1794   08EE D3 C1        out (flashcom),a
1795   08F0             ; Reset logs and create system's default log
1796   08F0 AF           xor a
1797   08F1 32 3C EA     ld (logs_curid),a
1798   08F4 32 3D EA     ld (logs_status),a
1799   08F7 21 00 00     ld hl,0
1800   08FA 22 3E EA     ld (logs_cur),hl
1801   08FD 22 40 EA     ld (logs_ids),hl
1802   0900 21 00 04     ld hl,1024     ; 51,2 lines long, 20 characters per line, 1024bytes
1803   0903 CD 71 05     call CreateLog ; No checking if the log was even created
1804   0906 32 7F EA     ld (SystemLogId),a
1805   0909 3A 7F EA     ld a,(SystemLogId)
1806   090C 21 A7 13     ld hl,s_SysFirst
1807   090F CD BD 05     call AddLog
1808   0912 21 C2 13     ld hl,s_SysStartUp
1809   0915 CD BD 05     call AddLog
1810   0918             ; Set keyboard's default repeat delay and rate,
1811   0918             ; if not already set
1812   0918 3A 36 EA     ld a,(RepeatSet)
1813   091B FE 17        cp $17
1814   091D 28 11        jr z,j_RepeatSet
1815   091F 21 FF 0F     ld hl,_RepeatDelay
1816   0922 22 32 EA     ld (RepeatDelay),hl
1817   0925 21 FF 01     ld hl,_RepeatRate
1818   0928 22 34 EA     ld (RepeatRate),hl
1819   092B 3E 17        ld a,$17
1820   092D 32 36 EA     ld (RepeatSet),a
1821   0930             j_RepeatSet:
1822   0930             ; Some settings for hexedit
1823   0930 3E FF        ld a,$ff
1824   0932 32 0C EA     ld (b_he_undoset),a
1825   0935             ; Misc settings
1826   0935 AF           xor a
1827   0936 32 00 EA     ld (T0),a
1828   0939 32 01 EA     ld (T1),a
1829   093C 32 02 EA     ld (T2),a
1830   093F 32 03 EA     ld (T3),a
1831   0942 32 04 EA     ld (GT0),a
1832   0945 32 05 EA     ld (GT1),a
1833   0948             ; Set default interrupt mode
1834   0948 ED 56        im 1   ; INT is probably used by ethernet controller
1835   094A             ; Init 8255 PIO
1836   094A             ; Port B and port C lower 4bits to LCD-diplay
1837   094A             ; Port A and port C upper 4bits as inputs for now
1838   094A             ; Mode for 8255 is 0 for now
1839   094A 3E 98        ld a,%10011000
1840   094C D3 23        out (PIOCtrl),a
1841   094E 3E 00        ld a,$0
1842   0950 D3 21        out (LCDd),a
1843   0952 3E 01        ld a,%00000001
1844   0954 D3 22        out (LCDi),a
1845   0956             ; Init the LCD-display
1846   0956 CD 5B 01     call reset_lcd
1847   0959             ; Detect and init ethernet adapter
1848   0959             ; The ethernet adapter is not enabled here yet
1849   0959             ; Also init network and enable NIC
1850   0959 3A 7F EA     ld a,(SystemLogId)
1851   095C 21 D1 13     ld hl,s_SysProbeNIC
1852   095F CD BD 05     call AddLog
1853   0962             ; call ethInit
1854   0962 3E 69        ld a,$69
1855   0964 21 05 14     ld hl,s_SysNoNIC
1856   0967 FE 69        cp $69                 ; $69 should be NoNIC
1857   0969 28 06        jr z,sup_nonicfound
1858   096B CD 00 2A     call net_init
1859   096E 21 E9 13     ld hl,s_SysNICfound
1860   0971             sup_nonicfound:
1861   0971 3A 7F EA     ld a,(SystemLogId)
1862   0974 CD BD 05     call AddLog
1863   0977             ; Put a string to the LCD
1864   0977 CD 7E 01     call clear_lcd
1865   097A 06 0E        ld b,%00001110         ; This sets cursor on and cursor blinking off
1866   097C CD 25 01     call set_lcd
1867   097F 21 9F 0F     ld hl,s_OSstring
1868   0982 11 00 20     ld de,$2000
1869   0985 CD 86 01     call str2lcd
1870   0988 3E 40        ld a,Line2
1871   098A CD C7 01     call setDDRAMa
1872   098D 21 B3 0F     ld hl,s_version
1873   0990 11 00 20     ld de,$2000
1874   0993 CD 86 01     call str2lcd
1875   0996 06 0F        ld b,%00001111         ; This sets cursor and cursor blinking on
1876   0998 CD 25 01     call set_lcd
1877   099B 06 20        ld b,' '
1878   099D CD 3F 01     call char2lcd
1879   09A0             ; Wait for user to push Enter-button
1880   09A0 3E FE        ld a,%11111110
1881   09A2 D3 05        out (KeyS),a
1882   09A4             sup_waitEnter:
1883   09A4 DB 06        in a,(KeyR)
1884   09A6 CB 47        bit 0,a
1885   09A8 20 FA        jr nz,sup_waitEnter
1886   09AA             ; Start the default command prompt
1887   09AA 3A 7F EA     ld a,(SystemLogId)
1888   09AD 21 14 14     ld hl,s_SysModeS
1889   09B0 CD BD 05     call AddLog
1890   09B3 3E FF        ld a,none
1891   09B5 32 1E EA     ld (key_pressed),a
1892   09B8             mcp_start:
1893   09B8 CD 7E 01     call clear_lcd         ; This clears the LCD and returns cursor to home
1894   09BB 06 0F        ld b,%00001111         ; This sets cursor and cursor blinking on
1895   09BD CD 25 01     call set_lcd           ;
1896   09C0 3E 00        ld a,Line1
1897   09C2 CD C7 01     call setDDRAMa
1898   09C5 21 CD 0F     ld hl,s_defprompt
1899   09C8 CD 86 01     call str2lcd
1900   09CB 3E 40        ld a,Line2
1901   09CD CD C7 01     call setDDRAMa
1902   09D0 06 3E        ld b,'>'
1903   09D2 CD 3F 01     call char2lcd
1904   09D5             ; Wait for user to give a command
1905   09D5             mcp_command:
1906   09D5 3E 80        ld a,FastKeyDelay
1907   09D7 32 20 EA     ld (key_delay),a
1908   09DA 21 00 00     ld hl,$0000
1909   09DD 22 22 EA     ld (key_repeatdelay),hl
1910   09E0 21 00 00     ld hl,$0000
1911   09E3 22 24 EA     ld (key_repeatrate),hl
1912   09E6 3E FF        ld a,$ff
1913   09E8 32 2A EA     ld (key_rset),a
1914   09EB             ;
1915   09EB             mcp_comloop:
1916   09EB CD 77 02     call key_getkey
1917   09EE             ; Now test which key was pressed
1918   09EE FE 17        cp Enter
1919   09F0 CA 5B 0A     jp z,mcp_Enter
1920   09F3 FE 10        cp CK0
1921   09F5 C2 00 0A     jp nz,mcp_nhelp
1922   09F8 21 DD 0F     ld hl,s_help
1923   09FB 0E 10        ld c,CK0
1924   09FD C3 43 0A     jp mcp_str2lcd
1925   0A00             mcp_nhelp:
1926   0A00 FE 11        cp CK1
1927   0A02 C2 0D 0A     jp nz,mcp_nhexedit
1928   0A05 21 E3 0F     ld hl,s_hexedit
1929   0A08 0E 11        ld c,CK1
1930   0A0A C3 43 0A     jp mcp_str2lcd
1931   0A0D             mcp_nhexedit:
1932   0A0D FE 12        cp CK2
1933   0A0F C2 1A 0A     jp nz,mcp_nuptime
1934   0A12 21 F7 0F     ld hl,s_viewuptime
1935   0A15 0E 12        ld c,CK2
1936   0A17 C3 43 0A     jp mcp_str2lcd
1937   0A1A             mcp_nuptime:
1938   0A1A FE 13        cp CK3
1939   0A1C C2 27 0A     jp nz,mcp_nlogs
1940   0A1F 21 EC 0F     ld hl,s_viewlogs
1941   0A22 0E 13        ld c,CK3
1942   0A24 C3 43 0A     jp mcp_str2lcd
1943   0A27             mcp_nlogs:
1944   0A27             ;
1945   0A27 3E 40        ld a,Line2
1946   0A29 CD C7 01     call setDDRAMa
1947   0A2C 06 3E        ld b,'>'
1948   0A2E CD 3F 01     call char2lcd
1949   0A31 21 04 10     ld hl,s_clearline
1950   0A34 0E 13        ld c,19
1951   0A36 CD 97 01     call strn2lcd
1952   0A39 3E 41        ld a,Line2+1
1953   0A3B CD C7 01     call setDDRAMa
1954   0A3E 0E FF        ld c,none
1955   0A40 C3 EB 09     jp mcp_comloop
1956   0A43             ;
1957   0A43             mcp_str2lcd:
1958   0A43 EB           ex de,hl
1959   0A44 3E 40        ld a,Line2
1960   0A46 CD C7 01     call setDDRAMa
1961   0A49 21 04 10     ld hl,s_clearline
1962   0A4C CD 86 01     call str2lcd
1963   0A4F 3E 40        ld a,Line2
1964   0A51 CD C7 01     call setDDRAMa
1965   0A54 EB           ex de,hl
1966   0A55 CD 86 01     call str2lcd
1967   0A58 C3 EB 09     jp mcp_comloop
1968   0A5B             ; ***
1969   0A5B             mcp_Enter
1970   0A5B 79           ld a,c
1971   0A5C FE FF        cp none
1972   0A5E CA D5 09     jp z,mcp_command
1973   0A61 0E FF        ld c,none
1974   0A63 FE 10        cp CK0
1975   0A65 CA 7A 0A     jp z,mcp_help
1976   0A68 FE 11        cp CK1
1977   0A6A CA 83 0A     jp z,mcp_hexedit
1978   0A6D FE 12        cp CK2
1979   0A6F CA 89 0A     jp z,mcp_viewuptime
1980   0A72 FE 13        cp CK3
1981   0A74 CA 8F 0A     jp z,mcp_viewlogs
1982   0A77 C3 EB 09     jp mcp_comloop
1983   0A7A             ; ***
1984   0A7A             mcp_help:
1985   0A7A 21 43 10     ld hl,s_helptext
1986   0A7D CD 95 0A     call help_read
1987   0A80 C3 B8 09     jp mcp_start
1988   0A83             mcp_hexedit:
1989   0A83 CD 51 0B     call hexedit
1990   0A86 C3 B8 09     jp mcp_start
1991   0A89             mcp_viewuptime:
1992   0A89 CD B2 0E     call ViewUptime
1993   0A8C C3 B8 09     jp mcp_start
1994   0A8F             mcp_viewlogs:
1995   0A8F CD 29 0E     call ViewLogs
1996   0A92 C3 B8 09     jp mcp_start
1997   0A95             ; *** help_read
1998   0A95             ; Help reader
1999   0A95             help_read:
2000   0A95 CD 5B 01     call reset_lcd
2001   0A98 F5           push af
2002   0A99 D5           push de
2003   0A9A 22 00 EA     ld (T0),hl
2004   0A9D             ;
2005   0A9D 3E 00        ld a,Line1
2006   0A9F CD C7 01     call setDDRAMa
2007   0AA2 CD 86 01     call str2lcd
2008   0AA5 23           inc hl
2009   0AA6 7E           ld a,(hl)
2010   0AA7 16 02        ld d,$02
2011   0AA9 FE 17        cp $17
2012   0AAB 28 13        jr z,hr_start
2013   0AAD 3E 40        ld a,Line2
2014   0AAF CD C7 01     call setDDRAMa
2015   0AB2 CD 86 01     call str2lcd
2016   0AB5 23           inc hl
2017   0AB6 7E           ld a,(hl)
2018   0AB7 CD 47 0B     call hr_dec21hl
2019   0ABA FE 17        cp $17
2020   0ABC 28 02        jr z,hr_start
2021   0ABE 16 01        ld d,$01
2022   0AC0             hr_start:
2023   0AC0 3E 17        ld a,Enter
2024   0AC2 32 1E EA     ld (key_pressed),a
2025   0AC5 3E 20        ld a,$20
2026   0AC7 32 20 EA     ld (key_delay),a
2027   0ACA E5           push hl
2028   0ACB 2A 32 EA     ld hl,(RepeatDelay)
2029   0ACE 22 22 EA     ld (key_repeatdelay),hl
2030   0AD1 2A 34 EA     ld hl,(RepeatRate)
2031   0AD4 22 24 EA     ld (key_repeatrate),hl
2032   0AD7 E1           pop hl
2033   0AD8 3E FF        ld a,$ff
2034   0ADA 32 2A EA     ld (key_rset),a
2035   0ADD             ;
2036   0ADD             hr_loop:
2037   0ADD CD 77 02     call key_getkey
2038   0AE0             ; Now test which key was pressed
2039   0AE0 FE 17        cp Enter
2040   0AE2 CA 4E 0B     jp z,hr_end
2041   0AE5 FE 11        cp CK1
2042   0AE7 CA 2C 0B     jp z,hr_rollup
2043   0AEA FE 13        cp CK3
2044   0AEC CA F2 0A     jp z,hr_rolldown
2045   0AEF C3 DD 0A     jp hr_loop
2046   0AF2             ;
2047   0AF2             hr_rolldown:
2048   0AF2 3E 02        ld a,$02
2049   0AF4 BA           cp d
2050   0AF5 28 32        jr z,hr_rd_end
2051   0AF7             hr_rd_ru:
2052   0AF7 3E 00        ld a,Line1
2053   0AF9 CD C7 01     call setDDRAMa
2054   0AFC CD 86 01     call str2lcd
2055   0AFF 23           inc hl
2056   0B00 7E           ld a,(hl)
2057   0B01 16 02        ld d,$02
2058   0B03 FE 17        cp $17
2059   0B05 20 0F        jr nz,hr_rd_jp
2060   0B07 E5           push hl
2061   0B08 21 19 10     ld hl,s_endof
2062   0B0B 3E 40        ld a,Line2
2063   0B0D CD C7 01     call setDDRAMa
2064   0B10 CD 86 01     call str2lcd
2065   0B13 E1           pop hl
2066   0B14 18 13        jr hr_rd_end
2067   0B16             hr_rd_jp:
2068   0B16 3E 40        ld a,Line2
2069   0B18 CD C7 01     call setDDRAMa
2070   0B1B CD 86 01     call str2lcd
2071   0B1E 23           inc hl
2072   0B1F 7E           ld a,(hl)
2073   0B20 CD 47 0B     call hr_dec21hl
2074   0B23 FE 17        cp $17
2075   0B25 28 02        jr z,hr_rd_end
2076   0B27 16 01        ld d,$01
2077   0B29             hr_rd_end:
2078   0B29 C3 DD 0A     jp hr_loop
2079   0B2C             ;
2080   0B2C             hr_rollup:
2081   0B2C 1E 02        ld e,2
2082   0B2E             hr_ru_uploop:
2083   0B2E 3A 01 EA     ld a,(T1)
2084   0B31 BC           cp h
2085   0B32 20 07        jr nz,hr_ru_nu
2086   0B34 3A 00 EA     ld a,(T0)
2087   0B37 BD           cp l
2088   0B38 CA 44 0B     jp z,hr_ru_end
2089   0B3B             hr_ru_nu:
2090   0B3B CD 47 0B     call hr_dec21hl
2091   0B3E 1D           dec e
2092   0B3F 20 ED        jr nz,hr_ru_uploop
2093   0B41 C3 F7 0A     jp hr_rd_ru
2094   0B44             hr_ru_end:
2095   0B44 C3 DD 0A     jp hr_loop
2096   0B47             hr_dec21hl:
2097   0B47 3E 15        ld a,21
2098   0B49             hr_dec21hl_loop:
2099   0B49 2B           dec hl
2100   0B4A 3D           dec a
2101   0B4B 20 FC        jr nz,hr_dec21hl_loop
2102   0B4D C9           ret
2103   0B4E             ;
2104   0B4E             hr_end:
2105   0B4E D1           pop de
2106   0B4F F1           pop af
2107   0B50 C9           ret
2108   0B51             ; end of help_read
2109   0B51             
2110   0B51             ; *** hexedit
2111   0B51             ; Hex editor
2112   0B51             hexedit:
2113   0B51 F5           push af
2114   0B52 C5           push bc
2115   0B53 D5           push de
2116   0B54 E5           push hl
2117   0B55             ;
2118   0B55 3A 08 EA     ld a,(b_he_addset)
2119   0B58 FE 17        cp $17
2120   0B5A 28 1D        jr z,he_addset
2121   0B5C 21 00 E0     ld hl,UMO
2122   0B5F 22 10 EA     ld (w_he_jumpaddr),hl
2123   0B62 22 13 EA     ld (w_he_calladdr),hl
2124   0B65 2B           dec hl
2125   0B66 2B           dec hl
2126   0B67 22 06 EA     ld (w_he_address),hl
2127   0B6A 3E 17        ld a,$17
2128   0B6C 32 08 EA     ld (b_he_addset),a
2129   0B6F 3E 00        ld a,$00
2130   0B71 32 0F EA     ld (b_he_input),a
2131   0B74 3E 00        ld a,$00
2132   0B76 32 0E EA     ld (b_he_output),a
2133   0B79             he_addset:
2134   0B79 CD 7E 01     call clear_lcd
2135   0B7C 3E 00        ld a,Line1
2136   0B7E CD C7 01     call setDDRAMa
2137   0B81 21 0F 13     ld hl,s_he_string
2138   0B84 CD 86 01     call str2lcd
2139   0B87 3E 40        ld a,Line2
2140   0B89 CD C7 01     call setDDRAMa
2141   0B8C 21 2E 10     ld hl,s_enter
2142   0B8F CD 86 01     call str2lcd
2143   0B92             ; Wait for Enter-key be pressed
2144   0B92 3E 17        ld a,Enter
2145   0B94 32 1E EA     ld (key_pressed),a
2146   0B97 3E 10        ld a,$10
2147   0B99 32 20 EA     ld (key_delay),a
2148   0B9C 21 00 00     ld hl,$0000
2149   0B9F 22 22 EA     ld (key_repeatdelay),hl
2150   0BA2 21 00 00     ld hl,$0000
2151   0BA5 22 24 EA     ld (key_repeatrate),hl
2152   0BA8 3E FF        ld a,$ff
2153   0BAA 32 2A EA     ld (key_rset),a
2154   0BAD             he_swaitEnter:
2155   0BAD CD 77 02     call key_getkey
2156   0BB0 FE 17        cp Enter
2157   0BB2 20 F9        jr nz,he_swaitEnter
2158   0BB4 3E 17        ld a,Enter
2159   0BB6             he_start:
2160   0BB6 32 1E EA     ld (key_pressed),a
2161   0BB9 3E 01        ld a,1
2162   0BBB 32 0D EA     ld (b_he_nibble),a
2163   0BBE CD 7E 01     call clear_lcd
2164   0BC1 06 0E        ld b,%00001110         ; This sets cursor on and cursor blinking off
2165   0BC3 CD 25 01     call set_lcd
2166   0BC6 2A 06 EA     ld hl,(w_he_address)
2167   0BC9 CD C8 0D     call he_showmemory
2168   0BCC 3E 10        ld a,$10
2169   0BCE 32 20 EA     ld (key_delay),a
2170   0BD1 2A 32 EA     ld hl,(RepeatDelay)
2171   0BD4 22 22 EA     ld (key_repeatdelay),hl
2172   0BD7 2A 34 EA     ld hl,(RepeatRate)
2173   0BDA 22 24 EA     ld (key_repeatrate),hl
2174   0BDD 3E FF        ld a,$ff
2175   0BDF 32 2A EA     ld (key_rset),a
2176   0BE2             ;
2177   0BE2             he_loop:
2178   0BE2 CD 77 02     call key_getkey
2179   0BE5             ; Now test which key was pressed
2180   0BE5 FE 10        cp $10
2181   0BE7 DA 0D 0D     jp c,he_change
2182   0BEA FE 17        cp Enter
2183   0BEC CA 24 0E     jp z,he_end
2184   0BEF FE 10        cp CK0
2185   0BF1 C2 FD 0B     jp nz,he_nhelp
2186   0BF4 CD 6A 02     call key_testshift
2187   0BF7 CA AC 0C     jp z,he_help
2188   0BFA C3 8A 0D     jp he_setaddress
2189   0BFD             he_nhelp:
2190   0BFD FE 11        cp CK1
2191   0BFF C2 0B 0C     jp nz,he_nrollup
2192   0C02 CD 6A 02     call key_testshift
2193   0C05 CA DF 0C     jp z,he_rollup4
2194   0C08 C3 B7 0C     jp he_rollup
2195   0C0B             he_nrollup:
2196   0C0B FE 13        cp CK3
2197   0C0D C2 19 0C     jp nz,he_nrolldown
2198   0C10 CD 6A 02     call key_testshift
2199   0C13 CA F6 0C     jp z,he_rolldown4
2200   0C16 C3 CB 0C     jp he_rolldown
2201   0C19             he_nrolldown:
2202   0C19 FE 15        cp CK5
2203   0C1B CA 63 0D     jp z,he_undo
2204   0C1E FE 12        cp CK2
2205   0C20 C2 2C 0C     jp nz,he_noutput
2206   0C23 CD 6A 02     call key_testshift
2207   0C26 CA 9C 0D     jp z,he_jump
2208   0C29 C3 3D 0C     jp he_output
2209   0C2C             he_noutput:
2210   0C2C FE 14        cp CK4
2211   0C2E C2 3A 0C     jp nz,he_ninput
2212   0C31 CD 6A 02     call key_testshift
2213   0C34 CA A8 0D     jp z,he_call
2214   0C37 C3 73 0C     jp he_input
2215   0C3A             he_ninput:
2216   0C3A C3 E2 0B     jp he_loop
2217   0C3D             ; Ouput given value to given I/O-address
2218   0C3D             he_output:
2219   0C3D C5           push bc
2220   0C3E 4F           ld c,a
2221   0C3F 3A 0E EA     ld a,(b_he_output)
2222   0C42 47           ld b,a
2223   0C43 79           ld a,c
2224   0C44 F5           push af
2225   0C45 E5           push hl
2226   0C46 CD 7E 01     call clear_lcd
2227   0C49 3E 00        ld a,Line1
2228   0C4B CD C7 01     call setDDRAMa
2229   0C4E 21 48 13     ld hl,s_inputioaddr
2230   0C51 CD 86 01     call str2lcd
2231   0C54 E1           pop hl
2232   0C55 F1           pop af
2233   0C56 CD 1C 03     call key_getbvalue
2234   0C59 FE 15        cp CK5
2235   0C5B 28 12        jr z,he_op_end
2236   0C5D 48           ld c,b
2237   0C5E F5           push af
2238   0C5F 78           ld a,b
2239   0C60 32 0E EA     ld (b_he_output),a
2240   0C63 F1           pop af
2241   0C64 06 00        ld b,$00
2242   0C66 CD 0A 03     call key_getbyte
2243   0C69 FE 15        cp CK5
2244   0C6B 28 02        jr z,he_op_end
2245   0C6D ED 41        out (c),b
2246   0C6F             he_op_end:
2247   0C6F C1           pop bc
2248   0C70 C3 B6 0B     jp he_start
2249   0C73             ; Input value from given I/O-address
2250   0C73             he_input:
2251   0C73 C5           push bc
2252   0C74 4F           ld c,a
2253   0C75 3A 0F EA     ld a,(b_he_input)
2254   0C78 47           ld b,a
2255   0C79 79           ld a,c
2256   0C7A F5           push af
2257   0C7B E5           push hl
2258   0C7C CD 7E 01     call clear_lcd
2259   0C7F 3E 00        ld a,Line1
2260   0C81 CD C7 01     call setDDRAMa
2261   0C84 21 48 13     ld hl,s_inputioaddr
2262   0C87 CD 86 01     call str2lcd
2263   0C8A E1           pop hl
2264   0C8B F1           pop af
2265   0C8C CD 1C 03     call key_getbvalue
2266   0C8F FE 15        cp CK5
2267   0C91 28 15        jr z,he_ip_end
2268   0C93 48           ld c,b
2269   0C94 47           ld b,a
2270   0C95 79           ld a,c
2271   0C96 32 0F EA     ld (b_he_input),a
2272   0C99 ED 78        in a,(c)
2273   0C9B 0E 03        ld c,SSeg3
2274   0C9D B7           or a
2275   0C9E CD CB 00     call b_to_7seg
2276   0CA1 3E FF        ld a,$ff
2277   0CA3 D3 01        out (SSeg1),a
2278   0CA5 D3 02        out (SSeg2),a
2279   0CA7 78           ld a,b
2280   0CA8             he_ip_end:
2281   0CA8 C1           pop bc
2282   0CA9 C3 B6 0B     jp he_start
2283   0CAC             ; Show Hex editor's help
2284   0CAC             he_help:
2285   0CAC 21 6A 11     ld hl,s_he_help
2286   0CAF CD 95 0A     call help_read
2287   0CB2 3E 17        ld a,Enter
2288   0CB4 C3 B6 0B     jp he_start
2289   0CB7             ; Roll memory up
2290   0CB7             he_rollup:
2291   0CB7 E5           push hl
2292   0CB8 2A 06 EA     ld hl,(w_he_address)
2293   0CBB 2B           dec hl
2294   0CBC 22 06 EA     ld (w_he_address),hl
2295   0CBF 3E 01        ld a,1
2296   0CC1 32 0D EA     ld (b_he_nibble),a
2297   0CC4 CD C8 0D     call he_showmemory
2298   0CC7 E1           pop hl
2299   0CC8 C3 E2 0B     jp he_loop
2300   0CCB             ; Roll memory down
2301   0CCB             he_rolldown:
2302   0CCB E5           push hl
2303   0CCC 2A 06 EA     ld hl,(w_he_address)
2304   0CCF 23           inc hl
2305   0CD0 22 06 EA     ld (w_he_address),hl
2306   0CD3 3E 01        ld a,1
2307   0CD5 32 0D EA     ld (b_he_nibble),a
2308   0CD8 CD C8 0D     call he_showmemory
2309   0CDB E1           pop hl
2310   0CDC C3 E2 0B     jp he_loop
2311   0CDF             ; Roll memory up by 4
2312   0CDF             he_rollup4:
2313   0CDF E5           push hl
2314   0CE0 2A 06 EA     ld hl,(w_he_address)
2315   0CE3 2B           dec hl
2316   0CE4 2B           dec hl
2317   0CE5 2B           dec hl
2318   0CE6 2B           dec hl
2319   0CE7 22 06 EA     ld (w_he_address),hl
2320   0CEA 3E 01        ld a,1
2321   0CEC 32 0D EA     ld (b_he_nibble),a
2322   0CEF CD C8 0D     call he_showmemory
2323   0CF2 E1           pop hl
2324   0CF3 C3 E2 0B     jp he_loop
2325   0CF6             ; Roll memory down by 4
2326   0CF6             he_rolldown4:
2327   0CF6 E5           push hl
2328   0CF7 2A 06 EA     ld hl,(w_he_address)
2329   0CFA 23           inc hl
2330   0CFB 23           inc hl
2331   0CFC 23           inc hl
2332   0CFD 23           inc hl
2333   0CFE 22 06 EA     ld (w_he_address),hl
2334   0D01 3E 01        ld a,1
2335   0D03 32 0D EA     ld (b_he_nibble),a
2336   0D06 CD C8 0D     call he_showmemory
2337   0D09 E1           pop hl
2338   0D0A C3 E2 0B     jp he_loop
2339   0D0D             ; Change memory
2340   0D0D             he_change:
2341   0D0D E5           push hl
2342   0D0E C5           push bc
2343   0D0F 2A 06 EA     ld hl,(w_he_address)
2344   0D12 23           inc hl
2345   0D13 23           inc hl
2346   0D14 46           ld b,(hl)
2347   0D15 4F           ld c,a
2348   0D16             ;
2349   0D16 3A 0D EA     ld a,(b_he_nibble)
2350   0D19 FE 00        cp 0
2351   0D1B 20 18        jr nz,he_ch_n0
2352   0D1D 78           ld a,b
2353   0D1E 32 09 EA     ld (b_he_undovalue),a
2354   0D21 22 0A EA     ld (w_he_undoaddr),hl
2355   0D24 E6 F0        and $f0
2356   0D26 47           ld b,a
2357   0D27 79           ld a,c
2358   0D28 E6 0F        and $0f
2359   0D2A B0           or b
2360   0D2B 77           ld (hl),a
2361   0D2C 3E 01        ld a,1
2362   0D2E 32 0D EA     ld (b_he_nibble),a
2363   0D31 23           inc hl
2364   0D32 C3 51 0D     jp he_ch_end
2365   0D35             he_ch_n0:
2366   0D35 78           ld a,b
2367   0D36 32 09 EA     ld (b_he_undovalue),a
2368   0D39 22 0A EA     ld (w_he_undoaddr),hl
2369   0D3C E6 0F        and $0f
2370   0D3E 47           ld b,a
2371   0D3F 79           ld a,c
2372   0D40 CB 27        sla a
2373   0D42 CB 27        sla a
2374   0D44 CB 27        sla a
2375   0D46 CB 27        sla a
2376   0D48 E6 F0        and $f0
2377   0D4A B0           or b
2378   0D4B 77           ld (hl),a
2379   0D4C 3E 00        ld a,0
2380   0D4E 32 0D EA     ld (b_he_nibble),a
2381   0D51             he_ch_end:
2382   0D51 3E 00        ld a,$00
2383   0D53 32 0C EA     ld (b_he_undoset),a
2384   0D56 2B           dec hl
2385   0D57 2B           dec hl
2386   0D58 22 06 EA     ld (w_he_address),hl
2387   0D5B CD C8 0D     call he_showmemory
2388   0D5E C1           pop bc
2389   0D5F E1           pop hl
2390   0D60 C3 E2 0B     jp he_loop
2391   0D63             ; Undo
2392   0D63             he_undo
2393   0D63 E5           push hl
2394   0D64 2A 0A EA     ld hl,(w_he_undoaddr)
2395   0D67 3A 0C EA     ld a,(b_he_undoset)
2396   0D6A FE FF        cp $ff
2397   0D6C 28 10        jr z,he_un_end
2398   0D6E C5           push bc
2399   0D6F 3A 09 EA     ld a,(b_he_undovalue)
2400   0D72 46           ld b,(hl)
2401   0D73 77           ld (hl),a
2402   0D74 78           ld a,b
2403   0D75 32 09 EA     ld (b_he_undovalue),a
2404   0D78 3E 01        ld a,1
2405   0D7A 32 0D EA     ld (b_he_nibble),a
2406   0D7D C1           pop bc
2407   0D7E             he_un_end
2408   0D7E 2B           dec hl
2409   0D7F 2B           dec hl
2410   0D80 22 06 EA     ld (w_he_address),hl
2411   0D83 CD C8 0D     call he_showmemory
2412   0D86 E1           pop hl
2413   0D87 C3 E2 0B     jp he_loop
2414   0D8A             ; Set address
2415   0D8A             he_setaddress:
2416   0D8A E5           push hl
2417   0D8B 2A 06 EA     ld hl,(w_he_address)
2418   0D8E 23           inc hl
2419   0D8F 23           inc hl
2420   0D90 CD E1 03     call key_getaddress
2421   0D93 2B           dec hl
2422   0D94 2B           dec hl
2423   0D95 22 06 EA     ld (w_he_address),hl
2424   0D98 E1           pop hl
2425   0D99 C3 B6 0B     jp he_start
2426   0D9C             ; Jump to address
2427   0D9C             he_jump:
2428   0D9C 2A 10 EA     ld hl,(w_he_jumpaddr)
2429   0D9F CD E1 03     call key_getaddress
2430   0DA2 FE 15        cp CK5
2431   0DA4 CA B6 0B     jp z,he_start
2432   0DA7 E9           jp (hl)
2433   0DA8             ; Call to address
2434   0DA8             he_call:
2435   0DA8 F5           push af
2436   0DA9 E5           push hl
2437   0DAA 2A 13 EA     ld hl,(w_he_calladdr)
2438   0DAD CD E1 03     call key_getaddress
2439   0DB0 FE 15        cp CK5
2440   0DB2 28 0C        jr z,he_call_end
2441   0DB4 22 13 EA     ld (w_he_calladdr),hl
2442   0DB7 3A C5 0D     ld a,(he_call_jumpcmd)
2443   0DBA 32 12 EA     ld (b_he_calljump),a
2444   0DBD CD 12 EA     call b_he_calljump
2445   0DC0             he_call_end:
2446   0DC0 E1           pop hl
2447   0DC1 F1           pop af
2448   0DC2 C3 B6 0B     jp he_start
2449   0DC5             he_call_jumpcmd:
2450   0DC5 C3 00 00     jp $0000
2451   0DC8             ; Show 4bytes of memory contents, start address in hl
2452   0DC8             he_showmemory:
2453   0DC8 F5           push af
2454   0DC9 C5           push bc
2455   0DCA             ;
2456   0DCA CD 7E 01     call clear_lcd
2457   0DCD 3E 00        ld a,Line1
2458   0DCF CD C7 01     call setDDRAMa
2459   0DD2 CD F6 0D     call he_sm_show
2460   0DD5 2B           dec hl
2461   0DD6 2B           dec hl
2462   0DD7 46           ld b,(hl)
2463   0DD8 CD 3F 01     call char2lcd
2464   0DDB 23           inc hl
2465   0DDC 46           ld b,(hl)
2466   0DDD CD 3F 01     call char2lcd
2467   0DE0 23           inc hl
2468   0DE1 46           ld b,(hl)
2469   0DE2 CD 3F 01     call char2lcd
2470   0DE5 23           inc hl
2471   0DE6 46           ld b,(hl)
2472   0DE7 CD 3F 01     call char2lcd
2473   0DEA 2B           dec hl
2474   0DEB             
2475   0DEB 3E 40        ld a,Line2
2476   0DED CD C7 01     call setDDRAMa
2477   0DF0 CD F6 0D     call he_sm_show
2478   0DF3             
2479   0DF3 C3 13 0E     jp he_sm_end
2480   0DF6             ;
2481   0DF6             he_sm_show:
2482   0DF6 0E 02        ld c,2
2483   0DF8             he_sm_loop:
2484   0DF8 7C           ld a,h
2485   0DF9 CD FE 00     call byte2lcd
2486   0DFC 7D           ld a,l
2487   0DFD CD FE 00     call byte2lcd
2488   0E00 06 3A        ld b,':'
2489   0E02 CD 3F 01     call char2lcd
2490   0E05 7E           ld a,(hl)
2491   0E06 CD FE 00     call byte2lcd
2492   0E09 06 20        ld b,' '
2493   0E0B CD 3F 01     call char2lcd
2494   0E0E 23           inc hl
2495   0E0F 0D           dec c
2496   0E10 20 E6        jr nz,he_sm_loop
2497   0E12 C9           ret
2498   0E13             ;
2499   0E13             he_sm_end
2500   0E13 3A 0D EA     ld a,(b_he_nibble)
2501   0E16 47           ld b,a
2502   0E17 3E 46        ld a,Line2+6
2503   0E19 90           sub b
2504   0E1A CD C7 01     call setDDRAMa
2505   0E1D 2B           dec hl
2506   0E1E 2B           dec hl
2507   0E1F 2B           dec hl
2508   0E20 2B           dec hl
2509   0E21 C1           pop bc
2510   0E22 F1           pop af
2511   0E23 C9           ret
2512   0E24             ;
2513   0E24             he_end:
2514   0E24 E1           pop hl
2515   0E25 D1           pop de
2516   0E26 C1           pop bc
2517   0E27 F1           pop af
2518   0E28 C9           ret
2519   0E29             ; end of hexedit
2520   0E29             
2521   0E29             ; *** ViewLogs
2522   0E29             ViewLogs:
2523   0E29 F5           push af
2524   0E2A E5           push hl
2525   0E2B C5           push bc
2526   0E2C 3E 80        ld a,FastKeyDelay
2527   0E2E 32 20 EA     ld (key_delay),a
2528   0E31 CD 7E 01     call clear_lcd
2529   0E34 06 0C        ld b,%00001100         ; This sets cursor and cursor blinking off
2530   0E36 CD 25 01     call set_lcd
2531   0E39 3A 3C EA     ld a,(logs_curid)
2532   0E3C FE 00        cp 0
2533   0E3E C2 52 0E     jp nz,vil_logsexist
2534   0E41 21 8C 13     ld hl,s_nologs
2535   0E44 CD 86 01     call str2lcd
2536   0E47             vil_nwait:
2537   0E47 CD 77 02     call key_getkey
2538   0E4A FE 17        cp Enter
2539   0E4C C2 47 0E     jp nz,vil_nwait
2540   0E4F C3 AE 0E     jp vil_end
2541   0E52             vil_logsexist:
2542   0E52 3E 00        ld a,Line1
2543   0E54 CD C7 01     call setDDRAMa
2544   0E57 21 9D 13     ld hl,s_viewslog
2545   0E5A CD 86 01     call str2lcd
2546   0E5D 3E 40        ld a,Line2
2547   0E5F CD C7 01     call setDDRAMa
2548   0E62 21 85 13     ld hl,s_lognumber
2549   0E65 CD 86 01     call str2lcd
2550   0E68 0E 01        ld c,1
2551   0E6A             vil_selectloop:
2552   0E6A 3E 46        ld a,Line2+6
2553   0E6C CD C7 01     call setDDRAMa
2554   0E6F 06 30        ld b,'0'
2555   0E71 79           ld a,c
2556   0E72 80           add a,b
2557   0E73 47           ld b,a
2558   0E74 CD 3F 01     call char2lcd
2559   0E77 CD 77 02     call key_getkey
2560   0E7A FE 11        cp CK1
2561   0E7C C2 87 0E     jp nz,vil_nCK1
2562   0E7F 0D           dec c
2563   0E80 C2 6A 0E     jp nz,vil_selectloop
2564   0E83 0C           inc c
2565   0E84 C3 6A 0E     jp vil_selectloop
2566   0E87             vil_nCK1:
2567   0E87 FE 13        cp CK3
2568   0E89 C2 97 0E     jp nz,vil_nCK3
2569   0E8C 3A 3C EA     ld a,(logs_curid)
2570   0E8F B9           cp c
2571   0E90 CA 6A 0E     jp z,vil_selectloop
2572   0E93 0C           inc c
2573   0E94 C3 6A 0E     jp vil_selectloop
2574   0E97             vil_nCK3:
2575   0E97 FE 15        cp CK5
2576   0E99 C2 9F 0E     jp nz,vil_nCK5
2577   0E9C C3 AE 0E     jp vil_end
2578   0E9F             vil_nCK5:
2579   0E9F FE 17        cp Enter
2580   0EA1 C2 6A 0E     jp nz,vil_selectloop
2581   0EA4 79           ld a,c
2582   0EA5 CD 40 06     call ViewLog
2583   0EA8 CD 7E 01     call clear_lcd
2584   0EAB C3 52 0E     jp vil_logsexist
2585   0EAE             vil_end:
2586   0EAE C1           pop bc
2587   0EAF E1           pop hl
2588   0EB0 F1           pop af
2589   0EB1 C9           ret
2590   0EB2             ; end of ViewLogs
2591   0EB2             
2592   0EB2             ; *** ViewUptime
2593   0EB2             ViewUptime:
2594   0EB2 F5           push af
2595   0EB3 E5           push hl
2596   0EB4 C5           push bc
2597   0EB5 CD 7E 01     call clear_lcd
2598   0EB8 06 0C        ld b,%00001100         ; This sets cursor and cursor blinking off
2599   0EBA CD 25 01     call set_lcd
2600   0EBD 3E 00        ld a,Line1
2601   0EBF CD C7 01     call setDDRAMa
2602   0EC2 21 66 13     ld hl,s_uptime1
2603   0EC5 CD 86 01     call str2lcd
2604   0EC8             vu_wait:
2605   0EC8 3E 40        ld a,Line2
2606   0ECA CD C7 01     call setDDRAMa
2607   0ECD 3A 85 EB     ld a,(uptime+5)
2608   0ED0 CD FE 00     call byte2lcd
2609   0ED3 3A 84 EB     ld a,(uptime+4)
2610   0ED6 CD FE 00     call byte2lcd
2611   0ED9 3A 83 EB     ld a,(uptime+3)
2612   0EDC CD FE 00     call byte2lcd
2613   0EDF 06 64        ld b,'d'
2614   0EE1 CD 3F 01     call char2lcd
2615   0EE4 3A 82 EB     ld a,(uptime+2)
2616   0EE7 CD FE 00     call byte2lcd
2617   0EEA 06 68        ld b,'h'
2618   0EEC CD 3F 01     call char2lcd
2619   0EEF 3A 81 EB     ld a,(uptime+1)
2620   0EF2 CD FE 00     call byte2lcd
2621   0EF5 06 6D        ld b,'m'
2622   0EF7 CD 3F 01     call char2lcd
2623   0EFA 3A 80 EB     ld a,(uptime+0)
2624   0EFD CD FE 00     call byte2lcd
2625   0F00 06 73        ld b,'s'
2626   0F02 CD 3F 01     call char2lcd
2627   0F05 CD D0 01     call key_scan
2628   0F08 21 1E EA     ld hl,key_pressed
2629   0F0B BE           cp (hl)
2630   0F0C CA C8 0E     jp z,vu_wait
2631   0F0F 32 1E EA     ld (key_pressed),a
2632   0F12 FE 17        cp Enter
2633   0F14 C2 C8 0E     jp nz,vu_wait
2634   0F17 C1           pop bc
2635   0F18 E1           pop hl
2636   0F19 F1           pop af
2637   0F1A C9           ret
2638   0F1B             ; end of ViewUptime
2639   0F1B             
2640   0F1B             ; *** System
2641   0F1B             System:
2642   0F1B F5           push af
2643   0F1C C5           push bc
2644   0F1D D5           push de
2645   0F1E E5           push hl
2646   0F1F             
2647   0F1F E1           pop hl
2648   0F20 D1           pop de
2649   0F21 C1           pop bc
2650   0F22 F1           pop af
2651   0F23 C9           ret
2652   0F24             ; end of System
2653   0F24             
2654   0F24             ; *** HandleNMI
2655   0F24             HandleNMI:
2656   0F24 F3           di
2657   0F25 F5           push af
2658   0F26 C5           push bc
2659   0F27 E5           push hl
2660   0F28 3E B1        ld a,%10110001
2661   0F2A D3 A3        out (CounterC),a
2662   0F2C 3E 97        ld a,$97
2663   0F2E D3 A2        out (Counter2),a
2664   0F30 3E 99        ld a,$99
2665   0F32 D3 A2        out (Counter2),a
2666   0F34 3A 80 EB     ld a,(uptime)
2667   0F37 C6 01        add a,1
2668   0F39 27           daa
2669   0F3A 32 80 EB     ld (uptime),a
2670   0F3D FE 60        cp $60
2671   0F3F C2 8F 0F     jp nz,hn_incupend
2672   0F42 AF           xor a
2673   0F43 32 80 EB     ld (uptime),a
2674   0F46 3A 81 EB     ld a,(uptime+1)
2675   0F49 C6 01        add a,1
2676   0F4B 27           daa
2677   0F4C 32 81 EB     ld (uptime+1),a
2678   0F4F FE 60        cp $60
2679   0F51 C2 8F 0F     jp nz,hn_incupend
2680   0F54 AF           xor a
2681   0F55 32 81 EB     ld (uptime+1),a
2682   0F58 3A 82 EB     ld a,(uptime+2)
2683   0F5B C6 01        add a,1
2684   0F5D 27           daa
2685   0F5E 32 82 EB     ld (uptime+2),a
2686   0F61 FE 24        cp $24
2687   0F63 C2 8F 0F     jp nz,hn_incupend
2688   0F66 AF           xor a
2689   0F67 32 82 EB     ld (uptime+2),a
2690   0F6A 3A 83 EB     ld a,(uptime+3)
2691   0F6D C6 01        add a,1
2692   0F6F 27           daa
2693   0F70 32 83 EB     ld (uptime+3),a
2694   0F73 FE 00        cp $00
2695   0F75 C2 8F 0F     jp nz,hn_incupend
2696   0F78 3A 84 EB     ld a,(uptime+4)
2697   0F7B C6 01        add a,1
2698   0F7D 27           daa
2699   0F7E 32 84 EB     ld (uptime+4),a
2700   0F81 FE 00        cp $00
2701   0F83 C2 8F 0F     jp nz,hn_incupend
2702   0F86 3A 85 EB     ld a,(uptime+5)
2703   0F89 C6 01        add a,1
2704   0F8B 27           daa
2705   0F8C 32 85 EB     ld (uptime+5),a
2706   0F8F             hn_incupend:
2707   0F8F             ;
2708   0F8F 3A 86 EB     led_toggle(%00010000)
2708   0F92 EE 10       
2708   0F94 D3 07       
2708   0F96 32 86 EB    
2709   0F99 E1           pop hl
2710   0F9A C1           pop bc
2711   0F9B F1           pop af
2712   0F9C FB           ei
2713   0F9D ED 45        retn
2714   0F9F             ; end of HandleNMI
2715   0F9F             
2716   0F9F             ;**************************************************************
2717   0F9F             ; Misc data, example character strings
2718   0F9F 5A3830205765s_OSstring      .db "Z80 WestOS, by Duge",EOL
2718   0FA5 73744F532C206279204475676517
2719   0FB3 76657273696Fs_version       .db "version b0.70",EOL
2719   0FB9 6E2062302E373017
2720   0FC1 435055206861s_halted        .db "CPU halted.",EOL
2720   0FC7 6C7465642E17
2721   0FCD 496E70757420s_defprompt     .db "Input  command:",EOL
2721   0FD3 20636F6D6D616E643A17
2722   0FDD 3E68656C7017s_help          .db ">help",EOL
2723   0FE3 3E6865786564s_hexedit       .db ">hexedit",EOL
2723   0FE9 697417
2724   0FEC 3E7669657720s_viewlogs      .db ">view logs",EOL
2724   0FF2 6C6F677317
2725   0FF7 3E7669657720s_viewuptime    .db ">view uptime",EOL
2725   0FFD 757074696D6517
2726   1004 202020202020s_clearline     .db "                    ",EOL
2726   100A 202020202020202020202020202017
2727   1019 2A2D2D2D2D2Ds_endof         .db "*-------end--------*",EOL
2727   101F 2D2D656E642D2D2D2D2D2D2D2D2A17
2728   102E 507265737320s_enter         .db "Press Enter.........",EOL
2728   1034 456E7465722E2E2E2E2E2E2E2E2E17
2729   1043 235573652043s_helptext      .db "#Use CK1 and CK3 to ",EOL
2729   1049 4B3120616E6420434B3320746F2017
2730   1058 23726F6C6C20                .db "#roll up and down   ",EOL
2730   105E 757020616E6420646F776E20202017
2731   106D 434B303A2048                .db "CK0: Help           ",EOL
2731   1073 656C70202020202020202020202017
2732   1082 53686F772074                .db "Show this help      ",EOL
2732   1088 6869732068656C7020202020202017
2733   1097 434B313A2048                .db "CK1: Hexedit        ",EOL
2733   109D 657865646974202020202020202017
2734   10AC 4D656D6F7279                .db "Memory hex editor   ",EOL
2734   10B2 2068657820656469746F7220202017
2735   10C1 416C736F2066                .db "Also for I/O-usage  ",EOL
2735   10C7 6F7220492F4F2D7573616765202017
2736   10D6 434B323A2056                .db "CK2: View uptime    ",EOL
2736   10DC 69657720757074696D652020202017
2737   10EB 434B333A2056                .db "CK3: View logs      ",EOL
2737   10F1 696577206C6F677320202020202017
2738   1100 53686966743A                .db "Shift:              ",EOL
2738   1106 202020202020202020202020202017
2739   1115 557361676520                .db "Usage of Shift is   ",EOL
2739   111B 6F6620536869667420697320202017
2740   112A 6D61726B6564                .db "marked with ^X,     ",EOL
2740   1130 2077697468205E582C202020202017
2741   113F 776865726520                .db "where X is some key ",EOL
2741   1145 5820697320736F6D65206B65792017
2742   1154 235072657373                .db "#Press Enter to exit",EOL
2742   115A 20456E74657220746F206578697417
2743   1169 17                          .db EOL
2744   116A 2355703A434Bs_he_help       .db "#Up:CK1 Down:CK3    ",EOL
2744   1170 3120446F776E3A434B332020202017
2745   117F 456E7465723A                .db "Enter: Exit hexedit ",EOL
2745   1185 204578697420686578656469742017
2746   1194 434B303A2043                .db "CK0: Choose address ",EOL
2746   119A 686F6F736520616464726573732017
2747   11A9 434B323A2049                .db "CK2: I/O output     ",EOL
2747   11AF 2F4F206F7574707574202020202017
2748   11BE 5E434B323A20                .db "^CK2: Jump to n     ",EOL
2748   11C4 4A756D7020746F206E202020202017
2749   11D3 434B343A2049                .db "CK4: I/O input      ",EOL
2749   11D9 2F4F20696E70757420202020202017
2750   11E8 5E434B343A20                .db "^CK4: Call to n     ",EOL
2750   11EE 43616C6C20746F206E202020202017
2751   11FD 416674657220                .db "After this command  ",EOL
2751   1203 7468697320636F6D6D616E64202017
2752   1212 746865207661                .db "the value read from ",EOL
2752   1218 6C756520726561642066726F6D2017
2753   1227 676976656E20                .db "given port is seen  ",EOL
2753   122D 706F7274206973207365656E202017
2754   123C 696E20377365                .db "in 7segments as hex.",EOL
2754   1242 676D656E7473206173206865782E17
2755   1251 434B313A2052                .db "CK1: Roll memory up ",EOL
2755   1257 6F6C6C206D656D6F72792075702017
2756   1266 5E434B313A20                .db "^CK1: Up by 4       ",EOL
2756   126C 557020627920342020202020202017
2757   127B 434B333A2052                .db "CK3: Roll mem. down ",EOL
2757   1281 6F6C6C206D656D2E20646F776E2017
2758   1290 5E434B333A20                .db "^CK3: Down by 4     ",EOL
2758   1296 446F776E2062792034202020202017
2759   12A5 434B353A2055                .db "CK5: Undo           ",EOL
2759   12AB 6E646F202020202020202020202017
2760   12BA 556E646F2069                .db "Undo in most cases. ",EOL
2760   12C0 6E206D6F73742063617365732E2017
2761   12CF 302D463A2043                .db "0-F: Change memory  ",EOL
2761   12D5 68616E6765206D656D6F7279202017
2762   12E4 5E434B303A20                .db "^CK0: Help          ",EOL
2762   12EA 48656C702020202020202020202017
2763   12F9 235072657373                .db "#Press Enter to exit",EOL
2763   12FF 20456E74657220746F206578697417
2764   130E 17                          .db EOL
2765   130F 576573744F53s_he_string     .db "WestOS Hexedit v0.25",EOL
2765   1315 20486578656469742076302E323517
2766   1324 476976652061s_inputaddress  .db "Give address:",EOL
2766   132A 6464726573733A17
2767   1332 476976652077s_inputword     .db "Give word:",EOL
2767   1338 6F72643A17
2768   133D 476976652062s_inputbyte     .db "Give byte:",EOL
2768   1343 7974653A17
2769   1348 476976652049s_inputioaddr   .db "Give I/O-address:",EOL
2769   134E 2F4F2D616464726573733A17
2770   135A 476976652064s_inputdelay    .db "Give delay:",EOL
2770   1360 656C61793A17
2771   1366 53797374656Ds_uptime1       .db "System uptime:",EOL
2771   136C 20757074696D653A17
2772   1375 303030303064s_uptime2       .db "00000d00h00m00s",EOL
2772   137B 30306830306D30307317
2773   1385 3E4C6F672023s_lognumber     .db ">Log #",EOL
2773   138B 17
2774   138C 4E6F206C6F67s_nologs        .db "No logs created.",EOL
2774   1392 7320637265617465642E17
2775   139D 56696577206Cs_viewslog      .db "View log:",EOL
2775   13A3 6F673A17
2776   13A7 5A3830205765s_SysFirst      .db "Z80 WestOS b0.70 by Duge.",LOGSP,EOL
2776   13AD 73744F532062302E373020627920447567652EFF17
2777   13C2 537461727469s_SysStartUp    .db "Starting up..",LOGSP,EOL
2777   13C8 6E672075702E2EFF17
2778   13D1 50726F62696Es_SysProbeNIC   .db "Probing for NIC @ISA..",LOGSP,EOL
2778   13D7 6720666F72204E494320404953412E2EFF17
2779   13E9 4E494320666Fs_SysNICfound   .db "NIC found, see Net log(1).",LOGSP,EOL
2779   13EF 756E642C20736565204E6574206C6F672831292EFF17
2780   1405 4E6F204E4943s_SysNoNIC      .db "No NIC found.",LOGSP,EOL
2780   140B 20666F756E642EFF17
2781   1414 476F696E6720s_SysModeS      .db "Going to start up-mode..",LOGSP,EOL
2781   141A 746F2073746172742075702D6D6F64652E2EFF17
2782   142E 435055206861s_SysHalt       .db "CPU halted.",LOGSP,EOL
2782   1434 6C7465642EFF17
2783   143B 435055207761s_SysHaltWake   .db "CPU waked up.",LOGSP,EOL
2783   1441 6B65642075702EFF17
2784   144A 303132333435hextolcd        .db '0','1','2','3','4','5','6','7','8','9'
2784   1450 36373839
2785   1454 414243444546                .db 'A','B','C','D','E','F'
2786   145A 81 B7 C2 92 hexto7segment   .db %10000001,%10110111,%11000010,%10010010
2787   145E B4 98 88 B3                 .db %10110100,%10011000,%10001000,%10110011
2788   1462 80 90 A0 8C                 .db %10000000,%10010000,%10100000,%10001100
2789   1466 C9 86 C8 E8                 .db %11001001,%10000110,%11001000,%11101000
2790   146A             ;**************************************************************
2791   146A             
2792   146A             #include "drivers.asm"
0001+  146A             ;**************************************************************
0002+  146A             ; Drivers
0003+  2000             .org $2000
0004+  2000             
0005+  2000             ; Enable some of these to use LEDs and 7segments for debugging
0006+  2000             ;#define DEBUG_DRIVERS   ; DEBUG when running drivers code
0007+  2000             
0008+  2000             ; Call-table for applications
0009+  2000             ethInit:
0010+  2000 C3 8D 20     jp ethNICInit
0011+  2003             ethReset:
0012+  2003 E5           push hl
0013+  2004 2A BE EA     ld hl,(ejReset)
0014+  2007 E9           jp (hl)
0015+  2008             ethOpen:
0016+  2008 E5           push hl
0017+  2009 2A C0 EA     ld hl,(ejOpen)
0018+  200C E9           jp (hl)
0019+  200D             ethEnable:
0020+  200D E5           push hl
0021+  200E 2A C2 EA     ld hl,(ejEnable)
0022+  2011 E9           jp (hl)
0023+  2012             ethDisable:
0024+  2012 E5           push hl
0025+  2013 2A C4 EA     ld hl,(ejDisable)
0026+  2016 E9           jp (hl)
0027+  2017             ethInterrupt:
0028+  2017 E5           push hl
0029+  2018 2A C6 EA     ld hl,(ejInterrupt)
0030+  201B E9           jp (hl)
0031+  201C             ethSend:
0032+  201C E5           push hl
0033+  201D 2A C8 EA     ld hl,(ejSend)
0034+  2020 E9           jp (hl)
0035+  2021             ;
0036+  2021             
0037+  2021             ; *******************************
0038+  2021             ; misc
0039+  2021             ; *******************************
0040+  2021             
0041+  2021             ; Ethernet NICs ID's
0042+  2021             NE1comp         equ $01
0043+  2021             NE2comp         equ $02
0044+  2021             NECcomp         equ $03
0045+  2021             NEBcomp         equ $04
0046+  2021             ; Coming... maybe.
0047+  2021             SMCultra        equ $11
0048+  2021             SMCEtherEZ      equ $12
0049+  2021             c3c509b         equ $21
0050+  2021             ;
0051+  2021             noNIC           equ $69
0052+  2021             
0053+  2021             eSending        equ $26
0054+  2021             eSended         equ $17
0055+  2021             eTimedOut       equ $69
0056+  2021             
0057+  2021             MAX_INTERRUPT_SERVICE   equ 10
0058+  2021             MAX_RECEIVE_SERVICE     equ 10
0059+  2021             MIN_ETH_PACKET_SIZE     equ 60
0060+  2021             MAX_ETH_PACKET_SIZE     equ 256
0061+  2021             
0062+  2021~            #ifdef CPU_AT_2MHZ
0063+  2021~            WaitForTimeout          equ 2800        ; Should be about 20ms
0064+  2021             #endif
0065+  2021             #ifdef CPU_AT_4MHZ
0066+  2021             WaitForTimeout          equ 5600        ; Should be about 20ms
0067+  2021             #endif
0068+  2021~            #ifdef CPU_AT_8MHZ
0069+  2021~            WaitForTimeout          equ 11200       ; Should be about 20ms
0070+  2021             #endif
0071+  2021             
0072+  2021 4E6F20457468s_NoNIC         .db "No Ethernet NIC",EOL
0072+  2027 65726E6574204E494317
0073+  2031 666F756E642E                .db "found.",EOL
0073+  2037 17
0074+  2038 50726F62696Es_NetProbeNIC   .db "Probing NIC...",EOL
0074+  203E 67204E49432E2E2E17
0075+  2047 4E6574204C6Fs_NetLogFirst   .db "Net Log Created.",LOGSP,EOL
0075+  204D 6720437265617465642EFF17
0076+  2059 FF 17       s_LOGSP         .db LOGSP,EOL 
0077+  205B FFFFFFFFFFFFtest_packet     .db $ff,$ff,$ff,$ff,$ff,$ff
0078+  2061 004033389A42                .db $00,$40,$33,$38,$9a,$42
0079+  2067 546573742070                .db "Test packet."
0079+  206D 61636B65742E
0080+  2073 53656E642062                .db "Send by Duge's Z80!!"
0080+  2079 7920447567652773205A38302121
0081+  2087 010000000217HWADDRESS       .db $01,$00,$00,$00,$02,$17
0082+  208D             
0083+  208D             ; *********************************
0084+  208D             ; some default routines for network
0085+  208D             ; *********************************
0086+  208D             ; ethNICInit
0087+  208D             ethNICInit:
0088+  208D F3           di
0089+  208E 21 00 04     ld hl,1024
0090+  2091 CD 71 05     call CreateLog
0091+  2094 32 B5 EA     ld (NetLogId),a
0092+  2097 21 47 20     ld hl,s_NetLogFirst
0093+  209A CD BD 05     call AddLog
0094+  209D             ; Clear error counters
0095+  209D 21 00 00     ld hl,0
0096+  20A0 22 E4 EA     ld (ethRxFrameErrs),hl ; rx frame errors
0097+  20A3 22 E6 EA     ld (ethRxCrcErrs),hl   ; rx CRC errors
0098+  20A6 22 E8 EA     ld (ethRxMissedErrs),hl; rx missed-errors
0099+  20A9 22 EA EA     ld (ethTxCarrErrs),hl  ; tx carrier errors
0100+  20AC 22 EC EA     ld (ethTxHBErrs),hl    ; tx heartbeat errors
0101+  20AF 22 EE EA     ld (ethTxWindow),hl    ; tx window errors
0102+  20B2 22 F0 EA     ld (ethRxOverErrs),hl  ; rx overrun errors
0103+  20B5 22 F2 EA     ld (ethRxErrs),hl      ; rx errors      
0104+  20B8 22 F4 EA     ld (ethRxFifoErrs),hl  ; rx fifo errors      
0105+  20BB 22 F6 EA     ld (ethRxLenErrs),hl   ; rx fifo errors
0106+  20BE 22 08 EB     ld (ethRxDropped),hl   ; rx dropped packets
0107+  20C1             ;
0108+  20C1 22 F8 EA     ld (ethRxPackets),hl   
0109+  20C4 22 FA EA     ld (ethRxPackets+2),hl  
0110+  20C7 22 FC EA     ld (ethTxPackets),hl      
0111+  20CA 22 FE EA     ld (ethTxPackets+2),hl    
0112+  20CD 22 00 EB     ld (ethRxBytes),hl    
0113+  20D0 22 02 EB     ld (ethRxBytes+2),hl    
0114+  20D3 22 04 EB     ld (ethTxBytes),hl
0115+  20D6 22 06 EB     ld (ethTxBytes+2),hl
0116+  20D9             ;
0117+  20D9 22 20 EB     ld (ethRxing),hl
0118+  20DC             ; Show search-text in LCD
0119+  20DC 3A B5 EA     ld a,(NetLogId)
0120+  20DF 21 38 20     ld hl,s_NetProbeNIC
0121+  20E2 CD BD 05     call AddLog
0122+  20E5 21 59 20     ld hl,s_LOGSP
0123+  20E8 CD BD 05     call AddLog
0124+  20EB CD 7E 01     call clear_lcd
0125+  20EE 21 38 20     ld hl,s_NetProbeNIC
0126+  20F1 CD 86 01     call str2lcd
0127+  20F4 11 E8 03     ld de,NormalMesg
0128+  20F7 CD 54 05     call Delayms
0129+  20FA 3E 69        ld a,noNIC
0130+  20FC 32 81 EA     ld (ethdetect),a
0131+  20FF             ; Probe the NIC
0132+  20FF CD 2E 23     call ne_probe           ; NEx000-compatible cards
0133+  2102 FE 69        cp noNIC
0134+  2104 20 05        jr nz,ie_nicfound
0135+  2106             ; call smc_probe
0136+  2106             ; cp noNIC
0137+  2106             ; jr nz,ie_nicfound
0138+  2106 21 21 20     ld hl,s_NoNIC
0139+  2109 3E 69        ld a,noNIC
0140+  210B             ie_nicfound:
0141+  210B 32 81 EA     ld (ethdetect),a
0142+  210E 3A B5 EA     ld a,(NetLogId)
0143+  2111 E5           push hl
0144+  2112 CD BD 05     call AddLog
0145+  2115 21 59 20     ld hl,s_LOGSP
0146+  2118 CD BD 05     call AddLog
0147+  211B CD 7E 01     call clear_lcd
0148+  211E E1           pop hl
0149+  211F CD 86 01     call str2lcd
0150+  2122 3E 40        ld a,Line2
0151+  2124 CD C7 01     call setDDRAMa
0152+  2127 23           inc hl
0153+  2128 CD 86 01     call str2lcd
0154+  212B 11 E8 03     ld de,NormalMesg
0155+  212E CD 54 05     call Delayms
0156+  2131 CD 7E 01     call clear_lcd
0157+  2134             ; Enable the NIC
0158+  2134 3A 81 EA     ld a,(ethdetect)
0159+  2137 FE 69        cp noNIC
0160+  2139 CA 40 21     jp z,ie_nonic
0161+  213C CD 08 20     call ethOpen
0162+  213F FB           ei
0163+  2140             ie_nonic:
0164+  2140 AF           xor a
0165+  2141 32 82 EA     ld (ethtmp),a
0166+  2144 CD 7E 01     call clear_lcd
0167+  2147 3A 81 EA     ld a,(ethdetect)
0168+  214A C9           ret
0169+  214B             ; end of ethNICInit
0170+  214B             
0171+  214B             ;**************************************************************
0172+  214B             ;
0173+  214B             ; Drivers
0174+  214B             ; 
0175+  214B             ;**************************************************************
0176+  214B             
0177+  214B             
0178+  214B             ;**************************************************************
0179+  214B             ; Some routines used by 8390-compatible NICs
0180+  214B             
0181+  214B             ; Some generic ethernet register configurations.
0182+  214B             E8390_TX_IRQ_MASK	equ $a	; For register EN0_ISR 
0183+  214B             E8390_RX_IRQ_MASK	equ $5
0184+  214B             E8390_RXCONFIG		equ $4	; EN0_RXCR: broadcasts, no multicast,errors 
0185+  214B             E8390_RXOFF		equ $20	; EN0_RXCR: Accept no packets 
0186+  214B             E8390_TXCONFIG		equ $00	; EN0_TXCR: Normal transmit mode 
0187+  214B             E8390_TXOFF		equ $02	; EN0_TXCR: Transmitter off 
0188+  214B             
0189+  214B             ; Register accessed at EN_CMD, the 8390 base addr.  
0190+  214B             E8390_STOP	equ $01	; Stop and reset the chip 
0191+  214B             E8390_START	equ $02	; Start the chip, clear reset 
0192+  214B             E8390_TRANS	equ $04	; Transmit a frame 
0193+  214B             E8390_RREAD	equ $08	; Remote read 
0194+  214B             E8390_RWRITE	equ $10	; Remote write  
0195+  214B             E8390_NODMA	equ $20	; Remote DMA 
0196+  214B             E8390_PAGE0	equ $00	; Select page chip registers 
0197+  214B             E8390_PAGE1	equ $40	; using the two high-order bits 
0198+  214B             E8390_PAGE2	equ $80	; Page 3 is invalid. 
0199+  214B              
0200+  214B             E8390_CMD	equ $00  ; The command register (for all pages 
0201+  214B             ; Page 0 register offsets. 
0202+  214B             EN0_CLDALO	equ $01	; Low byte of current local dma addr  RD 
0203+  214B             EN0_STARTPG	equ $01	; Starting page of ring bfr WR 
0204+  214B             EN0_CLDAHI	equ $02	; High byte of current local dma addr  RD 
0205+  214B             EN0_STOPPG	equ $02	; Ending page +1 of ring bfr WR 
0206+  214B             EN0_BOUNDARY	equ $03	; Boundary page of ring bfr RD WR 
0207+  214B             EN0_TSR		equ $04	; Transmit status reg RD 
0208+  214B             EN0_TPSR	equ $04	; Transmit starting page WR 
0209+  214B             EN0_NCR		equ $05	; Number of collision reg RD 
0210+  214B             EN0_TCNTLO	equ $05	; Low  byte of tx byte count WR 
0211+  214B             EN0_FIFO	equ $06	; FIFO RD 
0212+  214B             EN0_TCNTHI	equ $06	; High byte of tx byte count WR 
0213+  214B             EN0_ISR		equ $07	; Interrupt status reg RD WR 
0214+  214B             EN0_CRDALO	equ $08	; low byte of current remote dma address RD 
0215+  214B             EN0_RSARLO	equ $08	; Remote start address reg 0 
0216+  214B             EN0_CRDAHI	equ $09	; high byte, current remote dma address RD 
0217+  214B             EN0_RSARHI	equ $09	; Remote start address reg 1 
0218+  214B             EN0_RCNTLO	equ $0a	; Remote byte count reg WR 
0219+  214B             EN0_RCNTHI	equ $0b	; Remote byte count reg WR 
0220+  214B             EN0_RSR		equ $0c	; rx status reg RD 
0221+  214B             EN0_RXCR	equ $0c	; RX configuration reg WR 
0222+  214B             EN0_TXCR	equ $0d	; TX configuration reg WR 
0223+  214B             EN0_COUNTER0	equ $0d	; Rcv alignment error counter RD 
0224+  214B             EN0_DCFG	equ $0e	; Data configuration reg WR 
0225+  214B             EN0_COUNTER1	equ $0e	; Rcv CRC error counter RD 
0226+  214B             EN0_IMR		equ $0f	; Interrupt mask reg WR 
0227+  214B             EN0_COUNTER2	equ $0f	; Rcv missed frame error counter RD 
0228+  214B             
0229+  214B             ; Bits in EN0_ISR - Interrupt status register 
0230+  214B             ENISR_RX	equ $01	; Receiver, no error 
0231+  214B             ENISR_TX	equ $02	; Transmitter, no error 
0232+  214B             ENISR_RX_ERR	equ $04	; Receiver, with error 
0233+  214B             ENISR_TX_ERR	equ $08	; Transmitter, with error 
0234+  214B             ENISR_OVER	equ $10	; Receiver overwrote the ring 
0235+  214B             ENISR_COUNTERS	equ $20	; Counters need emptying 
0236+  214B             ENISR_RDC	equ $40	; remote dma complete 
0237+  214B             ENISR_RESET	equ $80	; Reset completed 
0238+  214B             ENISR_ALL	equ $3f	; Interrupts we will enable 
0239+  214B             
0240+  214B             ; Bits in EN0_DCFG - Data config register 
0241+  214B             ENDCFG_WTS	equ $01	; word transfer mode selection 
0242+  214B             ENDCFG_BOS	equ $02	; byte order selection 
0243+  214B             
0244+  214B             ; Page 1 register offsets. 
0245+  214B             EN1_PHYS   equ $01	; This board's physical enet addr RD WR 
0246+  214B             ;EN1_PHYS_SHIFT(i  equ i+1 ; Get and set mac address 
0247+  214B             EN1_CURPAG equ $07	; Current memory page RD WR 
0248+  214B             EN1_MULT   equ $08	; Multicast filter mask array (8 bytes RD WR 
0249+  214B             ;EN1_MULT_SHIFT(i  equ 8+i ; Get and set multicast filter 
0250+  214B             
0251+  214B             ; Bits in received packet status byte and EN0_RSR
0252+  214B             ENRSR_RXOK	equ $01	; Received a good packet 
0253+  214B             ENRSR_CRC	equ $02	; CRC error 
0254+  214B             ENRSR_FAE	equ $04	; frame alignment error 
0255+  214B             ENRSR_FO	equ $08	; FIFO overrun 
0256+  214B             ENRSR_MPA	equ $10	; missed pkt 
0257+  214B             ENRSR_PHY	equ $20	; physical/multicast address 
0258+  214B             ENRSR_DIS	equ $40	; receiver disable. set in monitor mode 
0259+  214B             ENRSR_DEF	equ $80	; deferring 
0260+  214B             
0261+  214B             ; Transmitted packet status, EN0_TSR. 
0262+  214B             ENTSR_PTX equ $01	; Packet transmitted without error 
0263+  214B             ENTSR_ND  equ $02	; The transmit wasn't deferred. 
0264+  214B             ENTSR_COL equ $04	; The transmit collided at least once. 
0265+  214B             ENTSR_ABT equ $08  ; The transmit collided 16 times, and was deferred. 
0266+  214B             ENTSR_CRS equ $10	; The carrier sense was lost. 
0267+  214B             ENTSR_FU  equ $20  ; A "FIFO underrun" occurred during transmit. 
0268+  214B             ENTSR_CDH equ $40	; The collision detect "heartbeat" signal was lost. 
0269+  214B             ENTSR_OWC equ $80  ; There was an out-of-window collision. 
0270+  214B             
0271+  214B             ; Something from Writing drivers for DP8390 -datasheet
0272+  214B             ;command                 equ ethbase+$00
0273+  214B             ;pagestart               equ ethbase+$01
0274+  214B             ;pagestop                equ ethbase+$02
0275+  214B             ;boundary                equ ethbase+$03
0276+  214B             ;transmitstatus          equ ethbase+$04
0277+  214B             ;transmitpage            equ ethbase+$04
0278+  214B             ;transmitbytecount0      equ ethbase+$05
0279+  214B             ;ncr                     equ ethbase+$05
0280+  214B             ;transmitbytecount1      equ ethbase+$06
0281+  214B             ;interruptstatus         equ ethbase+$07
0282+  214B             ;current                 equ ethbase+$07
0283+  214B             ;remotestartaddress0     equ ethbase+$08
0284+  214B             ;crdma0                  equ ethbase+$08
0285+  214B             ;remotestartaddress1     equ ethbase+$09
0286+  214B             ;crdma1                  equ ethbase+$09
0287+  214B             ;remotebytecount0        equ ethbase+$0a
0288+  214B             ;remotebytecount1        equ ethbase+$0b
0289+  214B             ;receivestatus           equ ethbase+$0c
0290+  214B             ;receiveconfiguration    equ ethbase+$0c
0291+  214B             ;transmitconfiguration   equ ethbase+$0d
0292+  214B             ;fae_tally               equ ethbase+$0d
0293+  214B             ;dataconfiguration       equ ethbase+$0e
0294+  214B             ;crc_tally               equ ethbase+$0e
0295+  214B             ;interruptmask           equ ethbase+$0f
0296+  214B             ;miss_pkt_tally          equ ethbase+$0f
0297+  214B             ;ioport                  equ ethbase+$10
0298+  214B             
0299+  214B             ; *******************************
0300+  214B             ; DP8390_init
0301+  214B             ; Init 8390 registers to "default"
0302+  214B             
0303+  214B 383339302068dp_HWsavebad .db "8390 hw-address",$17
0303+  2151 772D6164647265737317
0304+  215B 736176652066             .db "save failed.",$17
0304+  2161 61696C65642E17
0305+  2168             
0306+  2168             ;
0307+  2168             jDP8390_init:
0308+  2168 E1           pop hl
0309+  2169             DP8390_init:
0310+  2169 F5           push af
0311+  216A C5           push bc
0312+  216B D5           push de
0313+  216C E5           push hl
0314+  216D 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0315+  216F D3 E0        out (ETHBASE+E8390_CMD),a
0316+  2171 3A AC EA     ld a,(ethwrdlen)
0317+  2174 FE 02        cp 2
0318+  2176 3E 48        ld a,$48
0319+  2178 20 02        jr nz,dp_bytelen
0320+  217A 3E 49        ld a,$49
0321+  217C             dp_bytelen:
0322+  217C D3 EE        out (ETHBASE+EN0_DCFG),a
0323+  217E AF           xor a
0324+  217F D3 EA        out (ETHBASE+EN0_RCNTLO),a
0325+  2181 D3 EB        out (ETHBASE+EN0_RCNTHI),a
0326+  2183 3E 20        ld a,E8390_RXOFF
0327+  2185 D3 EC        out (ETHBASE+EN0_RXCR),a
0328+  2187 3E 02        ld a,E8390_TXOFF
0329+  2189 D3 ED        out (ETHBASE+EN0_TXCR),a
0330+  218B             ;
0331+  218B 3A B1 EA     ld a,(etxStartPage)
0332+  218E D3 E4        out (ETHBASE+EN0_TPSR),a
0333+  2190 3A B2 EA     ld a,(erxStartPage)
0334+  2193 D3 E1        out (ETHBASE+EN0_STARTPG),a
0335+  2195 3A B3 EA     ld a,(ethStopPage)
0336+  2198 3D           dec a
0337+  2199 D3 E3        out (ETHBASE+EN0_BOUNDARY),a
0338+  219B 3C           inc a
0339+  219C D3 E2        out (ETHBASE+EN0_STOPPG),a
0340+  219E 3E FF        ld a,$ff
0341+  21A0 D3 E7        out (ETHBASE+EN0_ISR),a
0342+  21A2 AF           xor a
0343+  21A3 D3 EF        out (ETHBASE+EN0_IMR),a
0344+  21A5             ;
0345+  21A5 3E 61        ld a,E8390_NODMA+E8390_PAGE1+E8390_STOP
0346+  21A7 D3 E0        out (ETHBASE+E8390_CMD),a
0347+  21A9             ; Set hardware address
0348+  21A9 AF           xor a
0349+  21AA 32 B0 EA     ld (ethT3),a
0350+  21AD 06 06        ld b,6
0351+  21AF 0E E1        ld c,ETHBASE+EN1_PHYS
0352+  21B1 21 87 20     ld hl,HWADDRESS
0353+  21B4             dp_hwset:
0354+  21B4 7E           ld a,(hl)
0355+  21B5 ED 79        out (c),a
0356+  21B7 57           ld d,a
0357+  21B8 ED 78        in a,(c)
0358+  21BA 23           inc hl
0359+  21BB 0C           inc c
0360+  21BC BA           cp d
0361+  21BD 28 05        jr z,dp_hwgood
0362+  21BF 3E 69        ld a,$69
0363+  21C1 32 B0 EA     ld (ethT3),a
0364+  21C4             dp_hwgood:
0365+  21C4 05           dec b
0366+  21C5 20 ED        jr nz,dp_hwset
0367+  21C7             ;
0368+  21C7 3A B0 EA     ld a,(ethT3)
0369+  21CA FE 00        cp 0
0370+  21CC 28 1B        jr z,dp_hwallgood
0371+  21CE CD 7E 01     call clear_lcd
0372+  21D1 21 4B 21     ld hl,dp_HWsavebad
0373+  21D4 CD 86 01     call str2lcd
0374+  21D7 3E 40        ld a,Line2
0375+  21D9 CD C7 01     call setDDRAMa
0376+  21DC 23           inc hl
0377+  21DD CD 86 01     call str2lcd
0378+  21E0 11 E8 03     ld de,FastMesg
0379+  21E3 CD 54 05     call Delayms
0380+  21E6 CD 7E 01     call clear_lcd
0381+  21E9             dp_hwallgood:
0382+  21E9 3A B2 EA     ld a,(erxStartPage)
0383+  21EC D3 E7        out (ETHBASE+EN1_CURPAG),a
0384+  21EE 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0385+  21F0 D3 E0        out (ETHBASE+E8390_CMD),a
0386+  21F2             ;
0387+  21F2 E1           pop hl
0388+  21F3 D1           pop de
0389+  21F4 C1           pop bc
0390+  21F5 F1           pop af
0391+  21F6 C9           ret
0392+  21F7             ; end of DP8390_init
0393+  21F7             
0394+  21F7             ; *******************************
0395+  21F7             ; DP8390_enable
0396+  21F7             jDP8390_enable:
0397+  21F7 E1           pop hl
0398+  21F8             DP8390_enable:
0399+  21F8 F5           push af
0400+  21F9 C5           push bc
0401+  21FA 3E FF        ld a,$ff
0402+  21FC D3 E7        out (ETHBASE+EN0_ISR),a
0403+  21FE 3E 3F        ld a,ENISR_ALL
0404+  2200 D3 EF        out (ETHBASE+EN0_IMR),a
0405+  2202 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0406+  2204 D3 E0        out (ETHBASE+E8390_CMD),a
0407+  2206 3E 00        ld a,E8390_TXCONFIG
0408+  2208 D3 ED        out (ETHBASE+EN0_TXCR),a
0409+  220A 3E 04        ld a,E8390_RXCONFIG
0410+  220C D3 EC        out (ETHBASE+EN0_RXCR),a
0411+  220E C1           pop bc
0412+  220F F1           pop af
0413+  2210 C9           ret
0414+  2211             ; end of DP8390_enable
0415+  2211             ;**************************************************************
0416+  2211             
0417+  2211             
0418+  2211             ;**************************************************************
0419+  2211             ; Drivers for NE1000/NE2000 (DP8390) compatible adapters
0420+  2211             ; Mostly copied from linux 2.4.5 kernels NE1000/NE2000 (8390) drivers
0421+  2211             ; (written by Donald Becker)
0422+  2211             
0423+  2211 4E4578303030ne_copyright .db "NEx000 drivers      ",$17
0423+  2217 206472697665727320202020202017
0424+  2226 427920447567             .db "By Duge. Mostly     ",$17
0424+  222C 652E204D6F73746C79202020202017
0425+  223B 636F70696564             .db "copied from linux   ",$17
0425+  2241 2066726F6D206C696E757820202017
0426+  2250 6B65726E656C             .db "kernel drivers      ",$17
0426+  2256 206472697665727320202020202017
0427+  2265 777269747465             .db "written by          ",$17
0427+  226B 6E2062792020202020202020202017
0428+  227A 446F6E616C64             .db "Donald Becker.      ",$17,$17
0428+  2280 204265636B65722E2020202020201717
0429+  2290 4E6F204E455Bne_nodev     .db "No NE[1,2]000 found.",$17,$17
0429+  2296 312C325D30303020666F756E642E1717
0430+  22A6 526573657420ne_noreset   .db "Reset failed on",$17
0430+  22AC 6661696C6564206F6E17
0431+  22B6 4E455B312C32             .db "NE[1,2]000-NIC.",$17
0431+  22BC 5D3030302D4E49432E17
0432+  22C6 4E4531303030ne1_detected .db "NE1000-NIC",$17
0432+  22CC 2D4E494317
0433+  22D1 646574656374             .db "detected.",$17
0433+  22D7 65642E17
0434+  22DB 4E4532303030ne2_detected .db "NE2000-NIC",$17
0434+  22E1 2D4E494317
0435+  22E6 646574656374             .db "detected.",$17
0435+  22EC 65642E17
0436+  22F0 4E452D636F6DneC_detected .db "NE-compatible Ctron-",$17
0436+  22F6 70617469626C65204374726F6E2D17
0437+  2305 4E4943206465             .db "NIC detected.",$17
0437+  230B 7465637465642E17
0438+  2313 426164204E45ne_badclone  .db "Bad NEx000 clone",$17
0438+  2319 7830303020636C6F6E6517
0439+  2324 646574656374             .db "detected.",$17
0439+  232A 65642E17
0440+  232E             
0441+  232E             ; #define's
0442+  232E             ;
0443+  232E             ; Weird stuff, but have no reason to change this 'grab' from
0444+  232E             ; the linux kernel, so leaving it like this
0445+  232E             ;
0446+  232E             #define TX_2X_PAGES 12
0447+  232E             #define TX_1X_PAGES 6
0448+  232E             ; Should always use two Tx slots to get back-to-back transmits.
0449+  232E             #define EI_PINGPONG
0450+  232E             #ifdef EI_PINGPONG
0451+  232E             #define TX_PAGES TX_2X_PAGES
0452+  232E~            #else
0453+  232E~            #define TX_PAGES TX_1X_PAGES
0454+  232E             #endif
0455+  232E             ;
0456+  232E             
0457+  232E             NE_BASE                 equ $00
0458+  232E             NE_CMD                  equ $00
0459+  232E             NE_DATAPORT             equ $10    ; NatSemi-defined port window offset. 
0460+  232E             NE_RESET                equ $1f    ; Issue a read to reset, a write to clear. 
0461+  232E             NE_IO_EXTENT            equ $20
0462+  232E             
0463+  232E             NE1SM_START_PG          equ $20    ; First page of TX buffer 
0464+  232E             NE1SM_STOP_PG           equ $40    ; Last page +1 of RX ring 
0465+  232E             NESM_START_PG           equ $40    ; First page of TX buffer 
0466+  232E             NESM_STOP_PG            equ $80    ; Last page +1 of RX ring 
0467+  232E             
0468+  232E             ; *******************************
0469+  232E             ; ne_probe
0470+  232E             ; Let's probe for NEx000-based card
0471+  232E             ne_probe:
0472+  232E DB E0        in a,(ETHBASE+0)
0473+  2330 32 AE EA     ld (ethT1),a
0474+  2333 FE FF        cp $ff
0475+  2335 20 03        jr nz,nepb_maybe0
0476+  2337 C3 81 24     jp nepb_nodev
0477+  233A             nepb_maybe0:
0478+  233A 3E 61        ld a,E8390_NODMA+E8390_PAGE1+E8390_STOP
0479+  233C D3 E0        out (ETHBASE+E8390_CMD),a
0480+  233E DB ED        in a,(ETHBASE+$0d)
0481+  2340 32 AD EA     ld (ethT0),a
0482+  2343 3E FF        ld a,$ff
0483+  2345 D3 ED        out (ETHBASE+$0d),a
0484+  2347 3E 20        ld a,E8390_NODMA+E8390_PAGE0
0485+  2349 D3 E0        out (ETHBASE+E8390_CMD),a
0486+  234B DB ED        in a,(ETHBASE+EN0_COUNTER0)
0487+  234D FE 00        cp 0
0488+  234F 28 0D        jr z,nepb_possibly0
0489+  2351 3A AE EA     ld a,(ethT1)
0490+  2354 D3 E0        out (ETHBASE+0),a
0491+  2356 3A AD EA     ld a,(ethT0)
0492+  2359 D3 ED        out (ETHBASE+$0d),a
0493+  235B C3 81 24     jp nepb_nodev
0494+  235E             nepb_possibly0:
0495+  235E~            #ifdef DEBUG_DRIVERS
0496+  235E~             led_set($01)
0496+  235E~             led_set($01)
0496+  235E~             led_set($01)
0496+  235E~             led_set($01)
0497+  235E             #endif
0498+  235E CD 11 28     call ne_reset          ; Reset
0499+  2361 FE 17        cp $17                 ; See if reset successful
0500+  2363 28 1B        jr z,nepb_resets       ;
0501+  2365 21 A6 22     ld hl,ne_noreset
0502+  2368 CD 7E 01     call clear_lcd
0503+  236B CD 86 01     call str2lcd
0504+  236E 3E 40        ld a,Line2
0505+  2370 CD C7 01     call setDDRAMa
0506+  2373 23           inc hl
0507+  2374 CD 86 01     call str2lcd
0508+  2377 11 B8 0B     ld de,ErrorMesg
0509+  237A CD 54 05     call Delayms
0510+  237D CD 7E 01     call clear_lcd
0511+  2380             nepb_resets:
0512+  2380~            #ifdef DEBUG_DRIVERS
0513+  2380~             led_set($02)
0513+  2380~             led_set($02)
0513+  2380~             led_set($02)
0513+  2380~             led_set($02)
0514+  2380             #endif
0515+  2380 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0516+  2382 D3 E0        out (ETHBASE+E8390_CMD),a
0517+  2384 3E 48        ld a,$48
0518+  2386 D3 EE        out (ETHBASE+EN0_DCFG),a
0519+  2388 AF           xor a
0520+  2389 D3 EA        out (ETHBASE+EN0_RCNTLO),a
0521+  238B D3 EB        out (ETHBASE+EN0_RCNTHI),a
0522+  238D D3 EF        out (ETHBASE+EN0_IMR),a
0523+  238F 3E FF        ld a,$ff
0524+  2391 D3 E7        out (ETHBASE+EN0_ISR),a
0525+  2393 3E 20        ld a,E8390_RXOFF
0526+  2395 D3 EC        out (ETHBASE+EN0_RXCR),a
0527+  2397 3E 02        ld a,E8390_TXOFF
0528+  2399 D3 ED        out (ETHBASE+EN0_TXCR),a
0529+  239B 3E 20        ld a,32
0530+  239D D3 EA        out (ETHBASE+EN0_RCNTLO),a
0531+  239F AF           xor a
0532+  23A0 D3 EB        out (ETHBASE+EN0_RCNTHI),a
0533+  23A2 D3 E8        out (ETHBASE+EN0_RSARLO),a
0534+  23A4 D3 E9        out (ETHBASE+EN0_RSARHI),a
0535+  23A6 3E 0A        ld a,E8390_RREAD+E8390_START
0536+  23A8 D3 E0        out (ETHBASE+E8390_CMD),a
0537+  23AA             ; Read station address PROM (SAPROM)
0538+  23AA 3E 02        ld a,2
0539+  23AC 32 AC EA     ld (ethwrdlen),a
0540+  23AF 06 10        ld b,16
0541+  23B1 21 83 EA     ld hl,ethsaprom
0542+  23B4             nepb_readsaprom:
0543+  23B4 DB F0        in a,(ETHBASE+NE_DATAPORT)
0544+  23B6 77           ld (hl),a
0545+  23B7 23           inc hl
0546+  23B8 57           ld d,a
0547+  23B9 DB F0        in a,(ETHBASE+NE_DATAPORT)
0548+  23BB 77           ld (hl),a
0549+  23BC 23           inc hl
0550+  23BD BA           cp d
0551+  23BE 28 05        jr z,nepb_wrdlen2
0552+  23C0~            #ifdef DEBUG_DRIVERS
0553+  23C0~             push bc
0554+  23C0~             ld c,SSeg1
0555+  23C0~             call b_to_7seg
0556+  23C0~             ld a,d
0557+  23C0~             ld c,SSeg3
0558+  23C0~             call b_to_7seg
0559+  23C0~             pop bc
0560+  23C0~             ld de,1000
0561+  23C0~             call Delayms
0562+  23C0             #endif
0563+  23C0 3E 01        ld a,1
0564+  23C2 32 AC EA     ld (ethwrdlen),a
0565+  23C5             nepb_wrdlen2:
0566+  23C5 05           dec b
0567+  23C6 20 EC        jr nz,nepb_readsaprom
0568+  23C8             ; Do some settings depending on if the NIC was detected as
0569+  23C8             ; 16bit or 8bit card
0570+  23C8 20 25        jr nz,nepb_byte
0571+  23CA~            #ifdef DEBUG_DRIVERS
0572+  23CA~             led_set($03)
0572+  23CA~             led_set($03)
0572+  23CA~             led_set($03)
0572+  23CA~             led_set($03)
0573+  23CA             #endif
0574+  23CA 01 83 EA     ld bc,ethsaprom
0575+  23CD 21 83 EA     ld hl,ethsaprom
0576+  23D0 16 10        ld d,16
0577+  23D2             nepb_wsaset:
0578+  23D2 7E           ld a,(hl)
0579+  23D3 02           ld (bc),a
0580+  23D4 03           inc bc
0581+  23D5 23           inc hl
0582+  23D6 23           inc hl
0583+  23D7 15           dec d
0584+  23D8 20 F8        jr nz,nepb_wsaset
0585+  23DA             ;
0586+  23DA 3E 49        ld a,$49
0587+  23DC D3 EE        out (ETHBASE+EN0_DCFG),a
0588+  23DE 3E 40        ld a,NESM_START_PG
0589+  23E0 32 B1 EA     ld (etxStartPage),a
0590+  23E3 C6 0C        add a,TX_PAGES
0591+  23E5 32 B2 EA     ld (erxStartPage),a
0592+  23E8 3E 80        ld a,NESM_STOP_PG
0593+  23EA 32 B3 EA     ld (ethStopPage),a
0594+  23ED 18 0F        jr nepb_jbyte
0595+  23EF             nepb_byte:
0596+  23EF~            #ifdef DEBUG_DRIVERS
0597+  23EF~             led_set($02)
0597+  23EF~             led_set($02)
0597+  23EF~             led_set($02)
0597+  23EF~             led_set($02)
0598+  23EF             #endif
0599+  23EF 3E 20        ld a,NE1SM_START_PG
0600+  23F1 32 B1 EA     ld (etxStartPage),a
0601+  23F4 C6 0C        add a,TX_PAGES
0602+  23F6 32 B2 EA     ld (erxStartPage),a
0603+  23F9 3E 40        ld a,NE1SM_STOP_PG
0604+  23FB 32 B3 EA     ld (ethStopPage),a
0605+  23FE             nepb_jbyte:
0606+  23FE             ; Save hardware-address
0607+  23FE 16 06        ld d,6
0608+  2400 21 83 EA     ld hl,ethsaprom
0609+  2403 01 A3 EA     ld bc,ethhwaddr
0610+  2406             nepb_hwsave:
0611+  2406 7E           ld a,(hl)
0612+  2407 02           ld (bc),a
0613+  2408 23           inc hl
0614+  2409 03           inc bc
0615+  240A 15           dec d
0616+  240B 20 F9        jr nz,nepb_hwsave
0617+  240D CD 69 21     call DP8390_init
0618+  2410             ; Set up jump-table which is called by applications
0619+  2410 21 10 28     ld hl,jne_reset
0620+  2413 22 BE EA     ld (ejReset),hl
0621+  2416 21 89 24     ld hl,jne_open
0622+  2419 22 C0 EA     ld (ejOpen),hl
0623+  241C 21 F7 21     ld hl,jDP8390_enable
0624+  241F 22 C2 EA     ld (ejEnable),hl
0625+  2422 21 68 21     ld hl,jDP8390_init
0626+  2425 22 C4 EA     ld (ejDisable),hl
0627+  2428 21 96 24     ld hl,jne_interrupt
0628+  242B 22 C6 EA     ld (ejInterrupt),hl
0629+  242E 21 52 27     ld hl,jne_send
0630+  2431 22 C8 EA     ld (ejSend),hl
0631+  2434             ; Save the NIC's ID
0632+  2434 3A 91 EA     ld a,(ethsaprom+14)
0633+  2437 47           ld b,a
0634+  2438 3A 92 EA     ld a,(ethsaprom+15)
0635+  243B B8           cp b
0636+  243C 20 17        jr nz,nepb_nonex
0637+  243E FE 57        cp $57                 ; Check for NEx000-card
0638+  2440 20 38        jr nz,nepb_badclone
0639+  2442             nepb_copam:             ; If NE-compatible copam-card
0640+  2442 3A AC EA     ld a,(ethwrdlen)
0641+  2445 FE 02        cp 2                   ; Check if 16bit
0642+  2447 3E 02        ld a,NE2comp
0643+  2449 21 DB 22     ld hl,ne2_detected
0644+  244C 28 3A        jr z,nepb_end          ; Jump, if was 16bit card (NE2000)
0645+  244E 3E 01        ld a,NE1comp           ; in other case 8bit (NE1000)
0646+  2450 21 C6 22     ld hl,ne1_detected
0647+  2453 18 33        jr nepb_end
0648+  2455             nepb_nonex:
0649+  2455 FE 00        cp $0
0650+  2457 20 05        jr nz,nepb_notcopam
0651+  2459 78           ld a,b
0652+  245A FE 49        cp $49
0653+  245C 28 E4        jr z,nepb_copam        ; Card was detected as 'copam' NEx000-compatible
0654+  245E             nepb_notcopam:
0655+  245E 3A 83 EA     ld a,(ethsaprom+0)
0656+  2461 FE 00        cp $0
0657+  2463 20 15        jr nz,nepb_badclone
0658+  2465 3A 84 EA     ld a,(ethsaprom+1)
0659+  2468 FE 00        cp $0
0660+  246A 20 0E        jr nz,nepb_badclone
0661+  246C 3A 85 EA     ld a,(ethsaprom+2)
0662+  246F FE 1D        cp $1d
0663+  2471 20 07        jr nz,nepb_badclone
0664+  2473 3E 03        ld a,NECcomp           ; Ctron 8- or 16-bit NEx000-compatible card
0665+  2475 21 F0 22     ld hl,neC_detected     ; Detection between 8- and 16-bits left out
0666+  2478 18 0E        jr nepb_end            ; becose there no use for that information
0667+  247A             nepb_badclone:
0668+  247A 21 13 23     ld hl,ne_badclone
0669+  247D 3E 04        ld a,NEBcomp
0670+  247F 18 07        jr nepb_end
0671+  2481             nepb_nodev:
0672+  2481 3E 69        ld a,noNIC
0673+  2483 21 90 22     ld hl,ne_nodev
0674+  2486 18 00        jr nepb_end
0675+  2488             ;
0676+  2488             nepb_end:
0677+  2488 C9           ret
0678+  2489             ; end of ne_probe
0679+  2489             
0680+  2489             ; *******************************
0681+  2489             ; ne_open
0682+  2489             jne_open:
0683+  2489 E1           pop hl
0684+  248A             ne_open:
0685+  248A CD 11 28     call ne_reset
0686+  248D CD 69 21     call DP8390_init
0687+  2490 CD F8 21     call DP8390_enable
0688+  2493 F5           push af
0689+  2494 F1           pop af
0690+  2495 C9           ret
0691+  2496             ; end of ne_open
0692+  2496             
0693+  2496             ; *******************************
0694+  2496             ; ne_interrupt
0695+  2496             jne_interrupt:
0696+  2496 E1           pop hl
0697+  2497             ne_interrupt:
0698+  2497 F5           push af
0699+  2498 E5           push hl
0700+  2499 C5           push bc
0701+  249A D5           push de
0702+  249B 3E 20        ld a,E8390_NODMA+E8390_PAGE0
0703+  249D D3 E0        out (ETHBASE+NE_CMD),a
0704+  249F 3E 0A        ld a,MAX_INTERRUPT_SERVICE
0705+  24A1 32 7E EB     ld (NT2),a
0706+  24A4~            #ifdef DEBUG_DRIVERS
0707+  24A4~             ld a,$ff
0708+  24A4~             out (LEDs),a
0709+  24A4~             out (SSeg1),a
0710+  24A4~             out (SSeg2),a
0711+  24A4~             out (SSeg3),a
0712+  24A4~             out (SSeg4),a
0713+  24A4~             xor a
0714+  24A4~             push af
0715+  24A4             #endif
0716+  24A4             nei_rloop:
0717+  24A4~            #ifdef DEBUG_DRIVERS
0718+  24A4~             pop af
0719+  24A4~             inc a
0720+  24A4~             push af
0721+  24A4~             or 1
0722+  24A4~             xor $ff
0723+  24A4~            ; out (LEDs),a
0724+  24A4             #endif
0725+  24A4 3A 7E EB     ld a,(NT2)
0726+  24A7 3D           dec a
0727+  24A8 CA E6 24     jp z,nei_end
0728+  24AB 32 7E EB     ld (NT2),a
0729+  24AE DB E7        in a,(ETHBASE+EN0_ISR)
0730+  24B0 FE 00        cp 0
0731+  24B2 CA E6 24     jp z,nei_end
0732+  24B5 47           ld b,a
0733+  24B6 E6 10        and ENISR_OVER
0734+  24B8 C2 07 25     jp nz,nei_over
0735+  24BB 78           ld a,b
0736+  24BC E6 01        and ENISR_RX
0737+  24BE C2 EB 24     jp nz,nei_rx
0738+  24C1 78           ld a,b
0739+  24C2 E6 04        and ENISR_RX_ERR
0740+  24C4 C2 EB 24     jp nz,nei_rxwitherr
0741+  24C7 78           ld a,b
0742+  24C8 E6 02        and ENISR_TX
0743+  24CA C2 F1 24     jp nz,nei_tx
0744+  24CD 78           ld a,b
0745+  24CE E6 08        and ENISR_TX_ERR
0746+  24D0 C2 FC 24     jp nz,nei_txwitherr
0747+  24D3 78           ld a,b
0748+  24D4 E6 40        and ENISR_RDC
0749+  24D6 C2 51 25     jp nz,nei_enisr
0750+  24D9 78           ld a,b
0751+  24DA E6 20        and ENISR_COUNTERS
0752+  24DC C2 58 25     jp nz,nei_counters
0753+  24DF             nei_loop:
0754+  24DF 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0755+  24E1 D3 E0        out (ETHBASE+E8390_CMD),a
0756+  24E3 C3 A4 24     jp nei_rloop
0757+  24E6             nei_end:
0758+  24E6~            #ifdef DEBUG_DRIVERS
0759+  24E6~             pop af
0760+  24E6~             ld a,$ff
0761+  24E6~            ; out (LEDs),a
0762+  24E6             #endif
0763+  24E6 D1           pop de
0764+  24E7 C1           pop bc
0765+  24E8 E1           pop hl
0766+  24E9 F1           pop af
0767+  24EA C9           ret
0768+  24EB             ;
0769+  24EB             nei_rx:
0770+  24EB             nei_rxwitherr:
0771+  24EB~            #ifdef DEBUG_DRIVERS
0772+  24EB~             ld a,0
0773+  24EB~             ld c,SSeg1
0774+  24EB~             call n_to_7seg
0775+  24EB             #endif
0776+  24EB CD 86 25     call ne_receive
0777+  24EE C3 DF 24     jp nei_loop
0778+  24F1             nei_tx:
0779+  24F1~            #ifdef DEBUG_DRIVERS
0780+  24F1~             ld a,1
0781+  24F1~             ld c,SSeg1
0782+  24F1~             call n_to_7seg
0783+  24F1             #endif
0784+  24F1 AF           xor a
0785+  24F2 32 21 EB     ld (ethTxing),a
0786+  24F5 3E 02        ld a,ENISR_TX
0787+  24F7 D3 E7        out (ETHBASE+EN0_ISR),a
0788+  24F9 C3 DF 24     jp nei_loop
0789+  24FC             nei_txwitherr:
0790+  24FC~            #ifdef DEBUG_DRIVERS
0791+  24FC~             ld a,2
0792+  24FC~             ld c,SSeg1
0793+  24FC~             call n_to_7seg
0794+  24FC             #endif
0795+  24FC AF           xor a
0796+  24FD 32 21 EB     ld (ethTxing),a
0797+  2500 3E 08        ld a,ENISR_TX_ERR
0798+  2502 D3 E7        out (ETHBASE+EN0_ISR),a
0799+  2504 C3 DF 24     jp nei_loop
0800+  2507             ; Handle receiver overrun
0801+  2507             nei_over:
0802+  2507~            #ifdef DEBUG_DRIVERS
0803+  2507~             ld a,3
0804+  2507~             ld c,SSeg1
0805+  2507~             call n_to_7seg
0806+  2507             #endif
0807+  2507 DB E0        in a,(ETHBASE+E8390_CMD)
0808+  2509 E6 04        and E8390_TRANS
0809+  250B 47           ld b,a
0810+  250C 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0811+  250E D3 E0        out (ETHBASE+E8390_CMD),a
0812+  2510 2A F0 EA     ld hl,(ethRxOverErrs)
0813+  2513 23           inc hl
0814+  2514 22 F0 EA     ld (ethRxOverErrs),hl
0815+  2517 11 32 00     ld de,50
0816+  251A CD 54 05     call Delayms
0817+  251D AF           xor a
0818+  251E D3 EA        out (ETHBASE+EN0_RCNTLO),a
0819+  2520 D3 EB        out (ETHBASE+EN0_RCNTHI),a
0820+  2522 B8           cp b
0821+  2523 CA 31 25     jp z,neio_notrans
0822+  2526 DB E7        in a,(ETHBASE+EN0_ISR)
0823+  2528 E6 0A        and ENISR_TX+ENISR_TX_ERR
0824+  252A FE 00        cp 0
0825+  252C C2 31 25     jp nz,neio_notrans
0826+  252F 06 01        ld b,1                         ; A packet must be resend 
0827+  2531             neio_notrans:
0828+  2531 3E 02        ld a,E8390_TXOFF
0829+  2533 D3 ED        out (ETHBASE+EN0_TXCR),a
0830+  2535 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0831+  2537 D3 E0        out (ETHBASE+E8390_CMD),a
0832+  2539 CD 86 25     call ne_receive
0833+  253C 3E 10        ld a,ENISR_OVER
0834+  253E D3 E7        out (ETHBASE+EN0_ISR),a
0835+  2540 3A 00 00     ld a,(E8390_TXCONFIG)
0836+  2543 D3 ED        out (ETHBASE+EN0_TXCR),a
0837+  2545             ; Resend a packet if there was a send before overrun happened
0838+  2545 AF           xor a
0839+  2546 B8           cp b
0840+  2547 CA 4E 25     jp z,neio_noretrans
0841+  254A 3E 26        ld a,E8390_NODMA+E8390_PAGE0+E8390_START+E8390_TRANS
0842+  254C D3 E0        out (ETHBASE+E8390_CMD),a
0843+  254E             neio_noretrans:
0844+  254E C3 DF 24     jp nei_loop
0845+  2551             ; Ignore any RDC
0846+  2551             nei_enisr:
0847+  2551~            #ifdef DEBUG_DRIVERS
0848+  2551~             ld a,4
0849+  2551~             ld c,SSeg1
0850+  2551~             call n_to_7seg
0851+  2551             #endif
0852+  2551 3E 40        ld a,ENISR_RDC
0853+  2553 D3 E7        out (ETHBASE+EN0_ISR),a
0854+  2555 C3 DF 24     jp nei_loop
0855+  2558             ; Update counters
0856+  2558             nei_counters:
0857+  2558~            #ifdef DEBUG_DRIVERS
0858+  2558~             ld a,4
0859+  2558~             ld c,SSeg1
0860+  2558~             call n_to_7seg
0861+  2558             #endif
0862+  2558 DB ED        in a,(ETHBASE+EN0_COUNTER0)
0863+  255A 6F           ld l,a
0864+  255B 26 00        ld h,0
0865+  255D ED 5B E4 EA  ld de,(ethRxFrameErrs)
0866+  2561 19           add hl,de
0867+  2562 22 E4 EA     ld (ethRxFrameErrs),hl
0868+  2565 DB EE        in a,(ETHBASE+EN0_COUNTER1)
0869+  2567 6F           ld l,a
0870+  2568 26 00        ld h,0
0871+  256A ED 5B E6 EA  ld de,(ethRxCrcErrs)
0872+  256E 19           add hl,de
0873+  256F 22 E6 EA     ld (ethRxCrcErrs),hl
0874+  2572 DB EF        in a,(ETHBASE+EN0_COUNTER2)
0875+  2574 6F           ld l,a
0876+  2575 26 00        ld h,0
0877+  2577 ED 5B E8 EA  ld de,(ethRxMissedErrs)
0878+  257B 19           add hl,de
0879+  257C 22 E8 EA     ld (ethRxMissedErrs),hl
0880+  257F 3E 20        ld a,ENISR_COUNTERS
0881+  2581 D3 E7        out (ETHBASE+EN0_ISR),a
0882+  2583 C3 DF 24     jp nei_loop
0883+  2586             ; end of ne_interrupt
0884+  2586             
0885+  2586             ; *******************************
0886+  2586             ; ne_receive
0887+  2586             ne_receive:
0888+  2586 F5           push af
0889+  2587 E5           push hl
0890+  2588 C5           push bc
0891+  2589 D5           push de
0892+  258A 3E 0A        ld a,MAX_RECEIVE_SERVICE
0893+  258C 32 7F EB     ld (NT3),a
0894+  258F             ner_loop:
0895+  258F 3A 7F EB     ld a,(NT3)
0896+  2592 3D           dec a
0897+  2593 CA 34 27     jp z,ner_end
0898+  2596 32 7F EB     ld (NT3),a
0899+  2599             ;
0900+  2599 3E 60        ld a,E8390_NODMA+E8390_PAGE1
0901+  259B D3 E0        out (ETHBASE+E8390_CMD),a
0902+  259D DB E7        in a,(ETHBASE+EN1_CURPAG)
0903+  259F 47           ld b,a
0904+  25A0 32 7C EB     ld (NT0),a
0905+  25A3 3E 20        ld a,E8390_NODMA+E8390_PAGE0
0906+  25A5 D3 E0        out (ETHBASE+E8390_CMD),a
0907+  25A7 DB E3        in a,(ETHBASE+EN0_BOUNDARY)
0908+  25A9 3C           inc a
0909+  25AA 5F           ld e,a
0910+  25AB 32 7D EB     ld (NT1),a
0911+  25AE 3A B3 EA     ld a,(ethStopPage)
0912+  25B1 3D           dec a
0913+  25B2 BB           cp e
0914+  25B3 D2 BA 25     jp nc,ner_notbigger
0915+  25B6 3A B2 EA     ld a,(erxStartPage)
0916+  25B9 5F           ld e,a
0917+  25BA             ner_notbigger:
0918+  25BA 78           ld a,b
0919+  25BB BB           cp e
0920+  25BC CA 34 27     jp z,ner_end
0921+  25BF             ; Now grab the 8390 header
0922+  25BF 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0923+  25C1 D3 E0        out (ETHBASE+E8390_CMD),a
0924+  25C3 3E 04        ld a,pkthdr_size
0925+  25C5 47           ld b,a
0926+  25C6 D3 EA        out (ETHBASE+EN0_RCNTLO),a
0927+  25C8 AF           xor a
0928+  25C9 D3 EB        out (ETHBASE+EN0_RCNTHI),a
0929+  25CB D3 E8        out (ETHBASE+EN0_RSARLO),a
0930+  25CD 7B           ld a,e
0931+  25CE D3 E9        out (ETHBASE+EN0_RSARHI),a
0932+  25D0 3E 0A        ld a,E8390_RREAD+E8390_START
0933+  25D2 D3 E0        out (ETHBASE+E8390_CMD),a
0934+  25D4 21 16 EB     ld hl,pkthdr
0935+  25D7 3A AC EA     ld a,(ethwrdlen)
0936+  25DA FE 02        cp 2
0937+  25DC C2 F0 25     jp nz,ner_hdrbybyte
0938+  25DF CB 38        srl b
0939+  25E1             ner_wloop:
0940+  25E1 DB F0        in a,(ETHBASE+NE_DATAPORT)
0941+  25E3 77           ld (hl),a
0942+  25E4 23           inc hl
0943+  25E5 DB C0        in a,(ethcom)
0944+  25E7 77           ld (hl),a
0945+  25E8 23           inc hl
0946+  25E9 05           dec b
0947+  25EA C2 E1 25     jp nz,ner_wloop
0948+  25ED C3 F8 25     jp ner_hdrcopied
0949+  25F0             ner_hdrbybyte:
0950+  25F0 DB F0        in a,(ETHBASE+NE_DATAPORT)
0951+  25F2 77           ld (hl),a
0952+  25F3 23           inc hl
0953+  25F4 05           dec b
0954+  25F5 C2 E1 25     jp nz,ner_wloop
0955+  25F8             ner_hdrcopied:
0956+  25F8 3E 40        ld a,ENISR_RDC
0957+  25FA D3 E7        out (ETHBASE+EN0_ISR),a
0958+  25FC             ;
0959+  25FC 2A 18 EB     ld hl,(pkthdr_count)
0960+  25FF 54           ld d,h
0961+  2600 3E 04        ld a,pkthdr_size
0962+  2602             ner_pkthdrdec:
0963+  2602 2B           dec hl
0964+  2603 3D           dec a
0965+  2604 20 FC        jr nz,ner_pkthdrdec
0966+  2606 22 18 EB     ld (pkthdr_count),hl
0967+  2609 14           inc d
0968+  260A 7B           ld a,e
0969+  260B 82           add a,d
0970+  260C ED 5B 17 EB  ld de,(pkthdr_next)
0971+  2610             ; Bogosity test
0972+  2610             ; Aaargh!! This kind of testing can be awful to do with assembly:
0973+  2610             ; (cut from ne.c, linux kernel drivers)
0974+  2610             ; "if (rx_frame.next != next_frame
0975+  2610             ;   && rx_frame.next != next_frame + 1
0976+  2610             ;   && rx_frame.next != next_frame - num_rx_pages
0977+  2610             ;   && rx_frame.next != next_frame + 1 - num_rx_pages) {"
0978+  2610             ;
0979+  2610             ;rx_frame.next != next_frame 
0980+  2610 BB           cp e
0981+  2611 CA 3F 26     jp z,ner_bogend
0982+  2614             ;rx_frame.next != next_frame + 1
0983+  2614 3C           inc a
0984+  2615 BB           cp e
0985+  2616 CA 3F 26     jp z,ner_bogend
0986+  2619             ;rx_frame.next != next_frame + 1 - num_rx_pages
0987+  2619 ED 4B B3 EA  ld bc,(ethStopPage)
0988+  261D 81           add a,c
0989+  261E ED 4B B2 EA  ld bc,(erxStartPage)
0990+  2622 91           sub c
0991+  2623 BB           cp e
0992+  2624 CA 3F 26     jp z,ner_bogend
0993+  2627             ;rx_frame.next != next_frame - num_rx_pages
0994+  2627 3D           dec a
0995+  2628 BB           cp e
0996+  2629 CA 3F 26     jp z,ner_bogend
0997+  262C             ;
0998+  262C 3A 7C EB     ld a,(NT0)
0999+  262F 32 B4 EA     ld (ethCurrentPage),a
1000+  2632 3D           dec a
1001+  2633 D3 E3        out (ETHBASE+EN0_BOUNDARY),a
1002+  2635 2A F2 EA     ld hl,(ethRxErrs)
1003+  2638 23           inc hl
1004+  2639 22 F2 EA     ld (ethRxErrs),hl
1005+  263C C3 8F 25     jp ner_loop
1006+  263F             ; bogosity test end
1007+  263F             ner_bogend:
1008+  263F 3A 19 EB     ld a,(pkthdr_count+1)
1009+  2642 FE 00        cp $00
1010+  2644 C2 60 26     jp nz,ner_bigpkt
1011+  2647 3A 18 EB     ld a,(pkthdr_count)
1012+  264A FE 3C        cp $3c
1013+  264C D2 73 26     jp nc,ner_pktsizeok
1014+  264F             ner_pktsizenok:
1015+  264F 2A F2 EA     ld hl,(ethRxErrs)
1016+  2652 23           inc hl
1017+  2653 22 F2 EA     ld (ethRxErrs),hl
1018+  2656 2A F6 EA     ld hl,(ethRxLenErrs)
1019+  2659 23           inc hl
1020+  265A 22 F6 EA     ld (ethRxLenErrs),hl
1021+  265D C3 1C 27     jp ner_nend
1022+  2660             ner_bigpkt:
1023+  2660 ED 5B 18 EB  ld de,(pkthdr_count)
1024+  2664 3E 05        ld a,$05
1025+  2666 BA           cp d
1026+  2667 DA 4F 26     jp c,ner_pktsizenok
1027+  266A C2 73 26     jp nz,ner_pktsizeok
1028+  266D 3E EE        ld a,$ee
1029+  266F BB           cp e
1030+  2670 DA 4F 26     jp c,ner_pktsizenok
1031+  2673             ner_pktsizeok:
1032+  2673             ;
1033+  2673 3A 16 EB     ld a,(pkthdr_stat)
1034+  2676 E6 0F        and $0f
1035+  2678 FE 01        cp ENRSR_RXOK
1036+  267A C2 06 27     jp nz,ner_else
1037+  267D             ; The packet is really a packet and it's OK!!!
1038+  267D             ; Now it can be handled!
1039+  267D             ; Copy the packet from NIC to local memory
1040+  267D             ; Same as linux drivers ne_block_input-routine
1041+  267D             ; First check for free space in packet buffer
1042+  267D~            #ifdef DEBUG_DRIVERS
1043+  267D~             ld a,0
1044+  267D~             ld c,SSeg2
1045+  267D~             call n_to_7seg
1046+  267D             #endif
1047+  267D 2A 18 EB     ld hl,(pkthdr_count)
1048+  2680 22 F7 CF     ld (netDataLen),hl
1049+  2683 CD 03 2A     call net_checkspace
1050+  2686 FE FF        cp nBufNoSpace
1051+  2688 CA C8 26     jp z,ner_nospace
1052+  268B             ;
1053+  268B 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
1054+  268D D3 E0        out (ETHBASE+NE_CMD),a
1055+  268F 3A 18 EB     ld a,(pkthdr_count)
1056+  2692 D3 EA        out (ETHBASE+EN0_RCNTLO),a
1057+  2694 3A 19 EB     ld a,(pkthdr_count+1)
1058+  2697 D3 EB        out (ETHBASE+EN0_RCNTHI),a
1059+  2699 3E 04        ld a,pkthdr_size
1060+  269B D3 E8        out (ETHBASE+EN0_RSARLO),a
1061+  269D 3A 7D EB     ld a,(NT1)
1062+  26A0 D3 E9        out (ETHBASE+EN0_RSARHI),a
1063+  26A2 3E 0A        ld a,E8390_RREAD+E8390_START
1064+  26A4 D3 E0        out (ETHBASE+NE_CMD),a
1065+  26A6             ; Registers ready, start copying
1066+  26A6 ED 5B 18 EB  ld de,(pkthdr_count)
1067+  26AA ED 53 F7 CF  ld (netDataLen),de
1068+  26AE 3E F0        ld a,ETHBASE+NE_DATAPORT
1069+  26B0 32 FC CF     ld (netIOCopyPort),a
1070+  26B3 3E 00        ld a,nBufCopyIO
1071+  26B5 32 FB CF     ld (netCopyType),a
1072+  26B8~            #ifdef DEBUG_DRIVERS
1073+  26B8~             ld a,1
1074+  26B8~             ld c,SSeg2
1075+  26B8~             call n_to_7seg
1076+  26B8             #endif
1077+  26B8 CD 06 2A     call net_allocbuffer
1078+  26BB FE FF        cp nBufNoSpace
1079+  26BD C2 D2 26     jp nz,ner_copyok
1080+  26C0             ; Should this be handled in this way?
1081+  26C0             ; Anyway something is really wrong if this is needed
1082+  26C0 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
1083+  26C2 D3 E0        out (ETHBASE+NE_CMD),a
1084+  26C4 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
1085+  26C6 D3 E0        out (ETHBASE+NE_CMD),a
1086+  26C8             ner_nospace:
1087+  26C8~            #ifdef DEBUG_DRIVERS
1088+  26C8~             ld a,2
1089+  26C8~             ld c,SSeg2
1090+  26C8~             call n_to_7seg
1091+  26C8             #endif
1092+  26C8 2A 08 EB     ld hl,(ethRxDropped)
1093+  26CB 23           inc hl
1094+  26CC 22 08 EB     ld (ethRxDropped),hl
1095+  26CF~            #ifdef DEBUG_DRIVERS
1096+  26CF~             ld a,(ethRxDropped)
1097+  26CF~             ld c,SSeg3
1098+  26CF~             call b_to_7seg
1099+  26CF             #endif
1100+  26CF C3 34 27     jp ner_end
1101+  26D2             ner_copyok:
1102+  26D2~            #ifdef DEBUG_DRIVERS
1103+  26D2~             ld a,3
1104+  26D2~             ld c,SSeg2
1105+  26D2~             call n_to_7seg
1106+  26D2             #endif
1107+  26D2 3E 40        ld a,ENISR_RDC
1108+  26D4 D3 E7        out (ETHBASE+EN0_ISR),a
1109+  26D6             ; Update rx packet counter and rx byte counter
1110+  26D6 2A F8 EA     ld hl,(ethRxPackets)
1111+  26D9 11 01 00     ld de,1
1112+  26DC 19           add hl,de
1113+  26DD 22 F8 EA     ld (ethRxPackets),hl
1114+  26E0 2A FA EA     ld hl,(ethRxPackets+2)
1115+  26E3 1E 00        ld e,0
1116+  26E5 ED 5A        adc hl,de
1117+  26E7 22 FA EA     ld (ethRxPackets+2),hl
1118+  26EA 2A 00 EB     ld hl,(ethRxBytes)
1119+  26ED ED 5B 18 EB  ld de,(pkthdr_count)
1120+  26F1 19           add hl,de
1121+  26F2 22 00 EB     ld (ethRxBytes),hl
1122+  26F5 2A 02 EB     ld hl,(ethRxBytes+2)
1123+  26F8 11 00 00     ld de,0
1124+  26FB ED 5A        adc hl,de
1125+  26FD 22 02 EB     ld (ethRxBytes+2),hl
1126+  2700~            #ifdef DEBUG_DRIVERS
1127+  2700~             ld a,(ethRxPackets)
1128+  2700~             ld c,SSeg3
1129+  2700~             call b_to_7seg
1130+  2700             #endif
1131+  2700             ; Call packet handler
1132+  2700 CD 0F 2A     call net_handlepacket
1133+  2703 C3 1C 27     jp ner_nend
1134+  2706             ;
1135+  2706             ner_else:
1136+  2706~            #ifdef DEBUG_DRIVERS
1137+  2706~             ld a,4
1138+  2706~             ld c,SSeg2
1139+  2706~             call n_to_7seg
1140+  2706             #endif
1141+  2706 2A F2 EA     ld hl,(ethRxErrs)
1142+  2709 23           inc hl
1143+  270A 22 F2 EA     ld (ethRxErrs),hl
1144+  270D 3A 16 EB     ld a,(pkthdr_stat)
1145+  2710 E6 08        and ENRSR_FO
1146+  2712 CA 1C 27     jp z,ner_nend
1147+  2715 2A F4 EA     ld hl,(ethRxFifoErrs)
1148+  2718 23           inc hl
1149+  2719 22 F4 EA     ld (ethRxFifoErrs),hl
1150+  271C             ner_nend:
1151+  271C~            #ifdef DEBUG_DRIVERS
1152+  271C~             ld a,5
1153+  271C~             ld c,SSeg2
1154+  271C~             call n_to_7seg
1155+  271C             #endif
1156+  271C 3A B3 EA     ld a,(ethStopPage)
1157+  271F 3D           dec a
1158+  2720 21 17 EB     ld hl,pkthdr_next
1159+  2723 BE           cp (hl)
1160+  2724 D2 2A 27     jp nc,nerp_nbadbad
1161+  2727~            #ifdef DEBUG_DRIVERS
1162+  2727~             ld a,6
1163+  2727~             ld c,SSeg2
1164+  2727~             call n_to_7seg
1165+  2727             #endif
1166+  2727 21 B2 EA     ld hl,erxStartPage
1167+  272A             nerp_nbadbad:
1168+  272A 7E           ld a,(hl)
1169+  272B 32 B4 EA     ld (ethCurrentPage),a
1170+  272E 3D           dec a
1171+  272F D3 E3        out (ETHBASE+EN0_BOUNDARY),a
1172+  2731 C3 8F 25     jp ner_loop
1173+  2734             ;
1174+  2734             ner_end:
1175+  2734 3E 05        ld a,ENISR_RX+ENISR_RX_ERR
1176+  2736 D3 E7        out (ETHBASE+EN0_ISR),a
1177+  2738 D1           pop de
1178+  2739 C1           pop bc
1179+  273A E1           pop hl
1180+  273B F1           pop af
1181+  273C C9           ret
1182+  273D             ; end of ne_receive
1183+  273D             
1184+  273D             ; *******************************
1185+  273D             ; ne_send
1186+  273D             ; Packet's address in (ethDataAddr), lenght in
1187+  273D             ; (ethDataLen)
1188+  273D 54696D656F75nes_timeout     .db "Timeout for Tx RDC.",LOGSP,EOL
1188+  2743 7420666F72205478205244432EFF17
1189+  2752             
1190+  2752             jne_send:
1191+  2752 E1           pop hl
1192+  2753             ne_send:
1193+  2753 3A 21 EB     ld a,(ethTxing)
1194+  2756 FE 11        cp XXXing
1195+  2758 3E 26        ld a,eSending
1196+  275A C8           ret z
1197+  275B DB E0        in a,(ETHBASE+NE_CMD)           ; Is NIC already sending?
1198+  275D FE 26        cp $26
1199+  275F 3E 26        ld a,eSending          ; If, return eSending in reg a
1200+  2761 C8           ret z                  ;
1201+  2762 F3           di
1202+  2763 C5           push bc
1203+  2764 D5           push de
1204+  2765 E5           push hl
1205+  2766~            #ifdef DEBUG_DRIVERS
1206+  2766~             ld a,0
1207+  2766~             ld c,SSeg4
1208+  2766~             call n_to_7seg
1209+  2766             #endif
1210+  2766 3A AC EA     ld a,(ethwrdlen)
1211+  2769 FE 02        cp 2                   ; Check for odd byte count if
1212+  276B C2 79 27     jp nz,nes_nodd         ; in word mode (is this needed really?)
1213+  276E 2A D2 EA     ld hl,(ethDataLen)
1214+  2771 23           inc hl
1215+  2772 7D           ld a,l
1216+  2773 E6 FE        and $fe
1217+  2775 6F           ld l,a
1218+  2776 22 D2 EA     ld (ethDataLen),hl
1219+  2779             nes_nodd:
1220+  2779 3E 22        ld a,E8390_PAGE0+E8390_START+E8390_NODMA
1221+  277B D3 E0        out (ETHBASE+NE_CMD),a
1222+  277D 3E 40        ld a,ENISR_RDC
1223+  277F D3 E7        out (ETHBASE+EN0_ISR),a
1224+  2781 3A D2 EA     ld a,(ethDataLen)
1225+  2784 D3 EA        out (ETHBASE+EN0_RCNTLO),a
1226+  2786 3A D3 EA     ld a,(ethDataLen+1)
1227+  2789 D3 EB        out (ETHBASE+EN0_RCNTHI),a
1228+  278B AF           xor a
1229+  278C D3 E8        out (ETHBASE+EN0_RSARLO),a
1230+  278E 3A B1 EA     ld a,(etxStartPage)
1231+  2791 D3 E9        out (ETHBASE+EN0_RSARHI),a
1232+  2793 3E 12        ld a,E8390_RWRITE+E8390_START
1233+  2795 D3 E0        out (ETHBASE+NE_CMD),a
1234+  2797 0E F0        ld c,ETHBASE+NE_DATAPORT
1235+  2799             ; Now copy the data into NIC
1236+  2799 3A AC EA     ld a,(ethwrdlen)
1237+  279C FE 02        cp 2		        ; Is the card 16bit or 8bit?
1238+  279E C2 C0 27     jp nz,nes_sendbybyte   ; Is the card 8- or 16-bit
1239+  27A1~            #ifdef DEBUG_DRIVERS
1240+  27A1~             push bc
1241+  27A1~             push af
1242+  27A1~             ld a,1
1243+  27A1~             ld c,SSeg4
1244+  27A1~             call n_to_7seg
1245+  27A1~             pop af
1246+  27A1~             pop bc
1247+  27A1             #endif
1248+  27A1 ED 5B D2 EA  ld de,(ethDataLen)
1249+  27A5 CB 3A        srl d                  ; Divide de's value by 2
1250+  27A7 CB 1B        rr e
1251+  27A9 14           inc d
1252+  27AA 2A D0 EA     ld hl,(ethDataAddr)
1253+  27AD             nes_sendbyword:
1254+  27AD 46           ld b,(hl)
1255+  27AE 23           inc hl
1256+  27AF 7E           ld a,(hl)
1257+  27B0 23           inc hl
1258+  27B1 D3 C0        out (ethcom),a
1259+  27B3 ED 41        out (c),b
1260+  27B5 1D           dec e
1261+  27B6 C2 AD 27     jp nz,nes_sendbyword
1262+  27B9 15           dec d
1263+  27BA C2 AD 27     jp nz,nes_sendbyword
1264+  27BD C3 C5 27     jp nes_nsend
1265+  27C0             nes_sendbybyte:
1266+  27C0             ; 8-bit card not supported yet
1267+  27C0~            #ifdef DEBUG_DRIVERS
1268+  27C0~             ld a,2
1269+  27C0~             ld c,SSeg4
1270+  27C0~             call n_to_7seg
1271+  27C0             #endif
1272+  27C0 3E 17        ld a,eSended
1273+  27C2 C3 09 28     jp nes_end
1274+  27C5             nes_nsend:
1275+  27C5~            #ifdef DEBUG_DRIVERS
1276+  27C5~             push bc
1277+  27C5~             push af
1278+  27C5~             ld a,3
1279+  27C5~             ld c,SSeg4
1280+  27C5~             call n_to_7seg
1281+  27C5~             pop af
1282+  27C5~             pop bc
1283+  27C5             #endif
1284+  27C5 21 E0 15     ld hl,WaitForTimeout
1285+  27C8             nes_wait:               ; Should wait here about 20ms
1286+  27C8 2B           dec hl
1287+  27C9 7C           ld a,h
1288+  27CA FE 00        cp 0
1289+  27CC CA F2 27     jp z,nes_timedout
1290+  27CF DB E7        in a,(ETHBASE+EN0_ISR)
1291+  27D1 E6 40        and ENISR_RDC
1292+  27D3 CA C8 27     jp z,nes_wait
1293+  27D6             nes_pos:
1294+  27D6 3E 40        ld a,ENISR_RDC
1295+  27D8 D3 E7        out (ETHBASE+(EN0_ISR),a
1296+  27DA 3A B1 EA     ld a,(etxStartPage)
1297+  27DD D3 E4        out (ETHBASE+EN0_TPSR),a
1298+  27DF 3A D2 EA     ld a,(ethDataLen)
1299+  27E2 D3 E5        out (ETHBASE+EN0_TCNTLO),a
1300+  27E4 3A D3 EA     ld a,(ethDataLen+1)
1301+  27E7 D3 E6        out (ETHBASE+EN0_TCNTHI),a
1302+  27E9 3E 26        ld a,E8390_NODMA+E8390_TRANS+E8390_START
1303+  27EB D3 E0        out (ETHBASE+NE_CMD),a
1304+  27ED 3E 17        ld a,eSended
1305+  27EF C3 09 28     jp nes_end
1306+  27F2             nes_timedout:
1307+  27F2 3A B5 EA     ld a,(NetLogId)
1308+  27F5 21 3D 27     ld hl,nes_timeout
1309+  27F8 CD BD 05     call AddLog            ; This message is seen in Net log(1)
1310+  27FB CD 11 28     call ne_reset
1311+  27FE CD 69 21     call DP8390_init
1312+  2801 CD F8 21     call DP8390_enable
1313+  2804 3E 69        ld a,eTimedOut
1314+  2806 C3 09 28     jp nes_end
1315+  2809             nes_end:
1316+  2809 F5           push af
1317+  280A~            #ifdef DEBUG_DRIVERS
1318+  280A~             ld a,4
1319+  280A~             ld c,SSeg4
1320+  280A~             call n_to_7seg
1321+  280A             #endif
1322+  280A F1           pop af
1323+  280B E1           pop hl
1324+  280C D1           pop de
1325+  280D C1           pop bc
1326+  280E FB           ei
1327+  280F C9           ret
1328+  2810             
1329+  2810             ; end of ne_send
1330+  2810             
1331+  2810             ; *******************************
1332+  2810             ; ne_reset
1333+  2810             jne_reset:
1334+  2810 E1           pop hl
1335+  2811             ne_reset:
1336+  2811 C5           push bc
1337+  2812 E5           push hl
1338+  2813 DB FF        in a,(ETHBASE+NE_RESET)
1339+  2815 D3 FF        out (ETHBASE+NE_RESET),a
1340+  2817 21 00 10     ld hl,$1000
1341+  281A             ners_wait:
1342+  281A 2B           dec hl
1343+  281B 7C           ld a,h
1344+  281C FE 00        cp 0
1345+  281E 28 0F        jr z,ners_failed
1346+  2820 DB E7        in a,(ETHBASE+EN0_ISR)
1347+  2822 E6 80        and ENISR_RESET
1348+  2824 28 F4        jr z,ners_wait
1349+  2826 3E FF        ld a,$ff
1350+  2828 D3 E7        out (ETHBASE+EN0_ISR),a
1351+  282A 3E 17        ld a,$17
1352+  282C E1           pop hl
1353+  282D C1           pop bc
1354+  282E C9           ret
1355+  282F             ners_failed:
1356+  282F 3E 69        ld a,$69
1357+  2831 E1           pop hl
1358+  2832 C1           pop bc
1359+  2833 C9           ret
1360+  2834             ; end of ne_reset
1361+  2834             
1362+  2834             ; end of NEx000 compatible adapters driver
1363+  2834             ;**************************************************************
1364+  2834             
1365+  2834             ; end of Drivers
1366+  2834             ;**************************************************************
2793   2834             #include "flash.asm"
0001+  2834             ;**************************************************************
0002+  2834             ;
0003+  2834             ; FLASH.asm
0004+  2834             ;       version 009
0005+  2834             ;
0006+  2834             ; Here is routines and such for network mostly
0007+  2834             ; Some other miscellaneous code also... 
0008+  2834             
0009+  2834             ; Enable some of these to use LEDs and 7segments for debugging
0010+  2834             ;#define DEBUG_MM        ; DEBUG when running memory manager code
0011+  2834             ;#define DEBUG_TCPIP     ; DEBUG when running TCP/IP code
0012+  2834             ;#define DEBUG_HANDLEPACKET      ;DEBUG when running TCP/IP code
0013+  2834             
0014+  2834~            #ifndef OS_FILE
0015+  2834~            #define ALONE
0016+  2834             #endif
0017+  2834             
0018+  2834~            #ifdef ALONE
0019+  2834~            #include "OSdef.h"
0020+  2834~            #include "drivers.asm"
0021+  2834             #endif
0022+  2834             
0023+  2A00             .org $2a00
0024+  2A00             ; Jump table
0025+  2A00             net_init:
0026+  2A00 C3 12 2C     jp nnet_init
0027+  2A03             net_checkspace:
0028+  2A03 C3 6C 2A     jp nnet_checkspace
0029+  2A06             net_allocbuffer:
0030+  2A06 C3 B8 2A     jp nnet_allocbuffer
0031+  2A09             net_freebuffer:
0032+  2A09 C3 C7 2B     jp nnet_freebuffer
0033+  2A0C             net_resetbuf:
0034+  2A0C C3 32 2A     jp nnet_resetbuf
0035+  2A0F             net_handlepacket:
0036+  2A0F C3 74 2C     jp nnet_handlepacket
0037+  2A12             
0038+  2A12             ;**************************************************************
0039+  2A12             ;
0040+  2A12             ; code for TCP/IP & ARP support
0041+  2A12             ;
0042+  2A12             ;**************************************************************
0043+  2A12             
0044+  2A12             ; #defines
0045+  2A12             #define ARP_OR_IP  $08
0046+  2A12             #define ARP_PACKET $06
0047+  2A12             #define IP_PACKET  $00
0048+  2A12             
0049+  2A12             #define ARP_REQUEST 1
0050+  2A12             #define ARP_REPLY 2
0051+  2A12             #define ARP_HWTYPE_ETH 1
0052+  2A12             
0053+  2A12             #define IP_PROTO_ICMP 1
0054+  2A12             
0055+  2A12             #define IP_DEFAULT_TTL 64
0056+  2A12             #define IP_ICMP_ECHO_TTL 32
0057+  2A12             #define IP_ICMP_MAX_SIZE 102    ; Maximum size of incoming icmp-packet
0058+  2A12                                             ; which is still handled
0059+  2A12                                             ; (Absolut maximum is 254)
0060+  2A12                                             ; This is here for now becose of some bug in 
0061+  2A12                                             ; ip-packet handling or network drivers
0062+  2A12             #define ICMP_ECHO_REPLY 0
0063+  2A12             #define ICMP_ECHO 8
0064+  2A12             #define ICMP_DROP 7
0065+  2A12             #define ICMP_UNREACHABLE 3
0066+  2A12             #define ICMP_DEFAULT_REPLY_TYPE ICMP_ECHO_REPLY
0067+  2A12             #define ICMP_DEFAULT_REPLY_CODE 0
0068+  2A12             #define ICMP_UNREACHABLE_TTL 240
0069+  2A12             ;
0070+  2A12             #define HWTYPE_ETH 1            ; No support for others than ethernet (probably)
0071+  2A12             #define OPCODE_ARPREQ 1         ; ARP-request
0072+  2A12             #define OPCODE_ARPREP 2         ; ARP-reply
0073+  2A12             ;
0074+  2A12             #define nBufPages 12
0075+  2A12             #define nBufTocs 4
0076+  2A12             #define nBufTocMaxPages 6
0077+  2A12             #define nBufPageSize 256
0078+  2A12             #define nBufMaxSize nBufTocMaxPages*nBufPageSize
0079+  2A12             #define nBuf1TocSize 10
0080+  2A12             #define nBufTocSize nBufTocs*nBuf1TocSize
0081+  2A12             ;
0082+  2A12             #define nBufTocStat 0           ;byte
0083+  2A12             #define nBufTocNPages 1         ;byte
0084+  2A12             #define nBufTocLen 2            ;word
0085+  2A12             #define nBufTocPages  4         ;6 bytes
0086+  2A12             ;
0087+  2A12             #define nBufferRead 1
0088+  2A12             #define nBufferWrite 2
0089+  2A12             #define nBufPageReserved 1
0090+  2A12             #define nBufTocReserved 1
0091+  2A12             ; ARP table
0092+  2A12             #define nArpTables 16
0093+  2A12             #define nArp1TabSize 12
0094+  2A12             #define nArpTabSize nArpTables*nArp1TabSize
0095+  2A12             #define nArpTabStat 0           ;byte
0096+  2A12             #define nArpTabDate 1           ;byte
0097+  2A12             #define nArpTabMAC 2            ;6 bytes
0098+  2A12             #define nArpTabIp 8             ;4 bytes
0099+  2A12             ; Ethernet packet header
0100+  2A12             ; DLC header
0101+  2A12             #define ehDlcSize 14
0102+  2A12             #define ehTarget 0              ;6 bytes
0103+  2A12             #define ehSource 6              ;6 bytes
0104+  2A12             #define ehType 12               ;word
0105+  2A12             ; ARP specific header
0106+  2A12             #define ehArpSize 28
0107+  2A12             #define ehArpHwType 14          ;word
0108+  2A12             #define ehArpProtocol 16        ;word
0109+  2A12             #define ehArpHwLen 18           ;byte
0110+  2A12             #define ehArpProtoLen 19        ;byte
0111+  2A12             #define ehArpOpCode 20          ;word
0112+  2A12             #define ehArpSourceHw 22        ;6 bytes
0113+  2A12             #define ehArpSourceIp 28        ;4 bytes, when using IP-protocol
0114+  2A12             #define ehArpTargetHw 32        ;6 bytes
0115+  2A12             #define ehArpTargetIp 38        ;4 bytes, when IP...
0116+  2A12             ; IP specific header
0117+  2A12             #define ehIpSize 20
0118+  2A12             #define ehIpVhl 14              ;byte
0119+  2A12             #define ehIpTos 15              ;byte
0120+  2A12             #define ehIpLen 16              ;word
0121+  2A12             #define ehIpId 18               ;word
0122+  2A12             #define ehIpOffset 20           ;word
0123+  2A12             #define ehIpTtl 22              ;byte
0124+  2A12             #define ehIpProto 23            ;byte
0125+  2A12             #define ehIpChecksum 24         ;word
0126+  2A12             #define ehIpSource 26           ;4 bytes
0127+  2A12             #define ehIpTarget 30           ;4 bytes
0128+  2A12             ; ICMP header
0129+  2A12             #define ehIcmpSize 8
0130+  2A12             #define ehIcmpType 34           ;byte
0131+  2A12             #define ehIcmpCode 35           ;byte
0132+  2A12             #define ehIcmpChecksum 36       ;word
0133+  2A12             #define ehIcmpId 38             ;word
0134+  2A12             #define ehIcmpSeqNumb 40        ;word
0135+  2A12             ;
0136+  2A12             nBufCopyIO      equ 0
0137+  2A12             nBufCopyMem     equ 1
0138+  2A12             nBufNoSpace     equ $ff
0139+  2A12             nBufNoId        equ $ff
0140+  2A12             ;
0141+  2A12             nArpDate        equ 40
0142+  2A12             
0143+  2A12             ; RAM at address $c000-$dfff
0144+  2A12             NETB            equ $c000       ;4KB of RAM for use of network
0145+  2A12             NETBL           equ NETB+$fff
0146+  2A12             ;
0147+  2A12             netBuffer       equ NETB+0      ;Reserves 12*256 bytes as buffer for received
0148+  2A12                                             ;and queue transmit packets
0149+  2A12             ;
0150+  2A12             netBufToc       equ NETB+3072   ;8*10 bytes
0151+  2A12             netArpTable     equ NETB+3152   ;16*12 bytes
0152+  2A12             ;Misc
0153+  2A12             netIcmpReplyType        equ NETBL-57    ;byte
0154+  2A12             netIcmpReplyCode        equ NETBL-56    ;byte
0155+  2A12             netChksumAddr   equ NETBL-55    ;word
0156+  2A12             netChksumCount  equ NETBL-53    ;word
0157+  2A12             ;Here are settings for this systems NIC
0158+  2A12             IpMasked        equ NETBL-51    ;*
0159+  2A12             IpAddress       equ NETBL-47    ;4 bytes
0160+  2A12             NetMask         equ NETBL-43    ;*
0161+  2A12             GateWay         equ NETBL-39    ;*
0162+  2A12             DNS             equ NETBL-35    ;*
0163+  2A12             ;
0164+  2A12             netMacAddress   equ NETBL-31    ;6 bytes, for MAC address
0165+  2A12             netIpAddress    equ NETBL-25    ;4 bytes, for IP address
0166+  2A12             netBufStat      equ NETBL-21    ;12 bytes, 1 for each buffer page
0167+  2A12             netBufUsedPages equ NETBL-9     ;byte
0168+  2A12             netDataLen      equ NETBL-8     ;word
0169+  2A12             netDataAddr     equ NETBL-6     ;word
0170+  2A12             netCopyType     equ NETBL-4     ;byte
0171+  2A12             netIOCopyPort   equ NETBL-3     ;byte
0172+  2A12             netBufStatus    equ NETBL-2     ;byte
0173+  2A12             netBufTemp      equ NETBL-1     ;byte
0174+  2A12             netBufTocId     equ NETBL-0     ;byte
0175+  2A12             ;
0176+  2A12             ; Default settings for tcp/ip
0177+  2A12             default_ip_settings:
0178+  2A12 C0 A8 01 D9 def_ip          .db 192,168,1,217
0179+  2A16 FF FF FF 00 def_mask        .db 255,255,255,0
0180+  2A1A 00 00 00 00 def_gw          .db 0,0,0,0
0181+  2A1E 00 00 00 00 def_dns         .db 0,0,0,0
0182+  2A22             ; Pointer to tocs starts
0183+  2A22             ; (this is a look-up-table for faster execution)
0184+  2A22             nBufTocPointers:
0185+  2A22 00 00       netBuf1stToc    .dw netBufToc+nBuf1TocSize*0
0186+  2A24 0A CC       netBuf2ndToc    .dw netBufToc+nBuf1TocSize*1
0187+  2A26 14 98       netBuf3rdToc    .dw netBufToc+nBuf1TocSize*2
0188+  2A28 1E 64       netBuf4thToc    .dw netBufToc+nBuf1TocSize*3
0189+  2A2A 28 30       netBuf5thToc    .dw netBufToc+nBuf1TocSize*4
0190+  2A2C 32 FC       netBuf6thToc    .dw netBufToc+nBuf1TocSize*5
0191+  2A2E 3C C8       netBuf7thToc    .dw netBufToc+nBuf1TocSize*6
0192+  2A30 46 94       netBuf8thToc    .dw netBufToc+nBuf1TocSize*7
0193+  2A32             
0194+  2A32             ;**************************************************************
0195+  2A32             ; Network buffer memory manager
0196+  2A32             
0197+  2A32             ; *******************************
0198+  2A32             ; net_resetbuf
0199+  2A32             nnet_resetbuf:
0200+  2A32 F5           push af
0201+  2A33 C5           push bc
0202+  2A34 E5           push hl
0203+  2A35 01 27 00     ld bc,nBufTocSize-1
0204+  2A38 21 00 CC     ld hl,netBufToc
0205+  2A3B 11 01 CC     ld de,netBufToc+1
0206+  2A3E 36 00        ld (hl),0
0207+  2A40 ED B0        ldir
0208+  2A42 01 0B 00     ld bc,nBufPages-1
0209+  2A45 21 EA CF     ld hl,netBufStat
0210+  2A48 11 EB CF     ld de,netBufStat+1
0211+  2A4B 36 00        ld (hl),0
0212+  2A4D ED B0        ldir
0213+  2A4F 01 BF 00     ld bc,nArpTabSize-1
0214+  2A52 21 50 CC     ld hl,netArpTable
0215+  2A55 11 51 CC     ld de,netArpTable+1
0216+  2A58 36 00        ld (hl),0
0217+  2A5A ED B0        ldir
0218+  2A5C AF           xor a
0219+  2A5D 32 F6 CF     ld (netBufUsedPages),a
0220+  2A60 32 FD CF     ld (netBufStatus),a
0221+  2A63 3E FF        ld a,nBufNoSpace
0222+  2A65 32 FF CF     ld (netBufTocId),a
0223+  2A68 E1           pop hl
0224+  2A69 C1           pop bc
0225+  2A6A F1           pop af
0226+  2A6B C9           ret
0227+  2A6C             ; end of net_resetbuf
0228+  2A6C             
0229+  2A6C             ; *******************************
0230+  2A6C             ; net_checkspace
0231+  2A6C             ; Checks for free space in network buffer and if there is
0232+  2A6C             ; enough space returns free TOC's ID in (netBudTocId) and
0233+  2A6C             ; reg a, otherwise returns nBufNoSpace in reg a
0234+  2A6C             nnet_checkspace:
0235+  2A6C C5           push bc
0236+  2A6D D5           push de
0237+  2A6E E5           push hl
0238+  2A6F~            #ifdef DEBUG_MM
0239+  2A6F~             ld a,1
0240+  2A6F~             ld c,SSeg1
0241+  2A6F~             call n_to_7seg
0242+  2A6F             #endif
0243+  2A6F ED 4B F7 CF  ld bc,(netDataLen)
0244+  2A73 AF           xor a
0245+  2A74 B8           cp b
0246+  2A75 C2 7E 2A     jp nz,ntc_nzero
0247+  2A78 B9           cp c
0248+  2A79 3E FF        ld a,nBufNoSpace
0249+  2A7B CA B4 2A     jp z,ntc_end
0250+  2A7E             ntc_nzero:
0251+  2A7E 0B           dec bc
0252+  2A7F 3E 06        ld a,nBufMaxSize/256
0253+  2A81 B8           cp b
0254+  2A82 3E FF        ld a,nBufNoSpace
0255+  2A84 DA B4 2A     jp c,ntc_end
0256+  2A87 CA B4 2A     jp z,ntc_end
0257+  2A8A 04           inc b
0258+  2A8B 3A F6 CF     ld a,(netBufUsedPages)
0259+  2A8E 80           add a,b
0260+  2A8F 3D           dec a
0261+  2A90 FE 0C        cp nBufPages
0262+  2A92 3E FF        ld a,nBufNoSpace
0263+  2A94 D2 B4 2A     jp nc,ntc_end
0264+  2A97 21 00 CC     ld hl,netBufToc+nBufTocStat
0265+  2A9A 11 0A 00     ld de,nBuf1TocSize
0266+  2A9D 0E 04        ld c,nBufTocs
0267+  2A9F AF           xor a
0268+  2AA0             ntc_findfreetoc:
0269+  2AA0 BE           cp (hl)
0270+  2AA1 CA AE 2A     jp z,ntc_fftoc
0271+  2AA4 19           add hl,de
0272+  2AA5 0D           dec c
0273+  2AA6 C2 A0 2A     jp nz,ntc_findfreetoc
0274+  2AA9 3E FF        ld a,nBufNoSpace
0275+  2AAB C3 B4 2A     jp ntc_end
0276+  2AAE             ntc_fftoc:
0277+  2AAE 3E 04        ld a,nBufTocs
0278+  2AB0 91           sub c
0279+  2AB1 32 FF CF     ld (netBufTocId),a
0280+  2AB4             ntc_end:
0281+  2AB4~            #ifdef DEBUG_MM
0282+  2AB4~             ld a,2
0283+  2AB4~             ld c,SSeg1
0284+  2AB4~             call n_to_7seg
0285+  2AB4             #endif
0286+  2AB4 C1           pop bc
0287+  2AB5 D1           pop de
0288+  2AB6 E1           pop hl
0289+  2AB7 C9           ret
0290+  2AB8             ; end of net_checkspace
0291+  2AB8             
0292+  2AB8             ; *******************************
0293+  2AB8             ; net_allocbuffer
0294+  2AB8             ; This routine is mostly used by network drivers
0295+  2AB8             ; Allocates buffer with size stored in (netDataLen) and
0296+  2AB8             ; copies data to that buffer from address found in
0297+  2AB8             ; (netDataAddr), returns buffer id (netBufTocId).
0298+  2AB8             ; Type of copy must be stored in (netCopyType) and port
0299+  2AB8             ; which to copy from in (netIOCopyPort), types are memory
0300+  2AB8             ; and io.
0301+  2AB8             ; If there is no space left returns nBufNoSpace in reg a
0302+  2AB8             nnet_allocbuffer:
0303+  2AB8 3A FD CF     ld a,(netBufStatus)            ; This should not happen!
0304+  2ABB FE 00        cp 0                           ; (That the buffer is already in use)
0305+  2ABD 3E FF        ld a,nBufNoSpace
0306+  2ABF C0           ret nz
0307+  2AC0 3E 02        ld a,nBufferWrite
0308+  2AC2 32 FD CF     ld (netBufStatus),a
0309+  2AC5 C5           push bc
0310+  2AC6 D5           push de
0311+  2AC7 E5           push hl
0312+  2AC8~            #ifdef DEBUG_MM
0313+  2AC8~             ld a,1
0314+  2AC8~             ld c,SSeg2
0315+  2AC8~             call n_to_7seg
0316+  2AC8~             xor a
0317+  2AC8~             out (SSeg3),a
0318+  2AC8             #endif
0319+  2AC8 ED 4B F7 CF  ld bc,(netDataLen)
0320+  2ACC AF           xor a
0321+  2ACD B8           cp b
0322+  2ACE C2 D7 2A     jp nz,nta_nzero
0323+  2AD1 B9           cp c
0324+  2AD2 3E FF        ld a,nBufNoSpace
0325+  2AD4 CA BD 2B     jp z,nta_end
0326+  2AD7             nta_nzero:
0327+  2AD7 0B           dec bc
0328+  2AD8 3E 06        ld a,nBufMaxSize/256
0329+  2ADA B8           cp b
0330+  2ADB 3E FF        ld a,nBufNoSpace
0331+  2ADD DA BD 2B     jp c,nta_end
0332+  2AE0 CA BD 2B     jp z,nta_end
0333+  2AE3 04           inc b
0334+  2AE4 3A F6 CF     ld a,(netBufUsedPages)
0335+  2AE7 80           add a,b
0336+  2AE8 3D           dec a
0337+  2AE9 FE 0C        cp nBufPages
0338+  2AEB 3E FF        ld a,nBufNoSpace
0339+  2AED D2 BD 2B     jp nc,nta_end
0340+  2AF0 21 00 CC     ld hl,netBufToc+nBufTocStat
0341+  2AF3 11 0A 00     ld de,nBuf1TocSize
0342+  2AF6 0E 04        ld c,nBufTocs
0343+  2AF8 AF           xor a
0344+  2AF9             nta_findfreetoc:
0345+  2AF9 BE           cp (hl)
0346+  2AFA CA 07 2B     jp z,nta_fftoc
0347+  2AFD 19           add hl,de
0348+  2AFE 0D           dec c
0349+  2AFF C2 F9 2A     jp nz,nta_findfreetoc
0350+  2B02 3E FF        ld a,nBufNoSpace
0351+  2B04 C3 BD 2B     jp nta_end
0352+  2B07             nta_fftoc:
0353+  2B07             ; There is free TOC and enough free pages (free space)
0354+  2B07             ; Now copy the data and set up TOC
0355+  2B07~            #ifdef DEBUG_MM
0356+  2B07~             push bc
0357+  2B07~             ld a,4
0358+  2B07~             ld c,SSeg2
0359+  2B07~             call n_to_7seg
0360+  2B07~             pop bc
0361+  2B07             #endif
0362+  2B07 3E 04        ld a,nBufTocs
0363+  2B09 91           sub c
0364+  2B0A 32 FF CF     ld (netBufTocId),a             ; Save TOC ID
0365+  2B0D 3A F6 CF     ld a,(netBufUsedPages)
0366+  2B10 80           add a,b
0367+  2B11 32 F6 CF     ld (netBufUsedPages),a
0368+  2B14 3E 01        ld a,nBufTocReserved
0369+  2B16 77           ld (hl),a
0370+  2B17 23           inc hl
0371+  2B18 70           ld (hl),b
0372+  2B19 78           ld a,b
0373+  2B1A 32 FE CF     ld (netBufTemp),a
0374+  2B1D 23           inc hl
0375+  2B1E ED 5B F7 CF  ld de,(netDataLen)
0376+  2B22 73           ld (hl),e
0377+  2B23 23           inc hl
0378+  2B24 72           ld (hl),d
0379+  2B25 23           inc hl
0380+  2B26 EB           ex de,hl
0381+  2B27 21 E9 CF     ld hl,netBufStat-1
0382+  2B2A 0E 0D        ld c,nBufPages+1
0383+  2B2C D9           exx
0384+  2B2D ED 5B F9 CF  ld de,(netDataAddr)
0385+  2B31 D9           exx
0386+  2B32 AF           xor a
0387+  2B33             nta_pgloop:
0388+  2B33 23           inc hl
0389+  2B34 0D           dec c
0390+  2B35 BE           cp (hl)
0391+  2B36 C2 33 2B     jp nz,nta_pgloop
0392+  2B39 3E 01        ld a,nBufPageReserved
0393+  2B3B 77           ld (hl),a
0394+  2B3C 3E 0C        ld a,nBufPages
0395+  2B3E 91           sub c
0396+  2B3F 12           ld (de),a
0397+  2B40 13           inc de
0398+  2B41 D9           exx
0399+  2B42 21 00 C0     ld hl,netBuffer
0400+  2B45 84           add a,h
0401+  2B46 67           ld h,a
0402+  2B47 3A FB CF     ld a,(netCopyType)
0403+  2B4A FE 00        cp nBufCopyIO
0404+  2B4C C2 AD 2B     jp nz,nta_copyfrommem
0405+  2B4F             nta_copyfromio:
0406+  2B4F~            #ifdef DEBUG_MM
0407+  2B4F~             ld a,1
0408+  2B4F~             ld c,SSeg3
0409+  2B4F~             call n_to_7seg
0410+  2B4F             #endif
0411+  2B4F ED 4B FC CF  ld bc,(netIOCopyPort)
0412+  2B53 3A AC EA     ld a,(ethwrdlen)
0413+  2B56 FE 02        cp 2
0414+  2B58 C2 8F 2B     jp nz,nte_cpbybyte
0415+  2B5B 06 80        ld b,$80
0416+  2B5D 3A FE CF     ld a,(netBufTemp)
0417+  2B60 3D           dec a
0418+  2B61 32 FE CF     ld (netBufTemp),a
0419+  2B64 C2 6D 2B     jp nz,nte_cpbyword
0420+  2B67 3A F7 CF     ld a,(netDataLen)
0421+  2B6A CB 3F        srl a
0422+  2B6C 47           ld b,a
0423+  2B6D             nte_cpbyword:
0424+  2B6D ED 78        in a,(c)
0425+  2B6F 77           ld (hl),a
0426+  2B70 23           inc hl
0427+  2B71 DB C0        in a,(ethcom)
0428+  2B73 77           ld (hl),a
0429+  2B74 23           inc hl
0430+  2B75 05           dec b
0431+  2B76 C2 6D 2B     jp nz,nte_cpbyword
0432+  2B79 3A FE CF     ld a,(netBufTemp)
0433+  2B7C FE 00        cp 0
0434+  2B7E C2 8C 2B     jp nz,nte_cpwnlast
0435+  2B81 3A F7 CF     ld a,(netDataLen)
0436+  2B84 E6 01        and 1
0437+  2B86 CA 8C 2B     jp z,nte_cpwnlast
0438+  2B89 ED 78        in a,(c)
0439+  2B8B 77           ld (hl),a
0440+  2B8C             nte_cpwnlast:
0441+  2B8C C3 A1 2B     jp nte_iocpend
0442+  2B8F             nte_cpbybyte:
0443+  2B8F 06 00        ld b,0
0444+  2B91 3A FE CF     ld a,(netBufTemp)
0445+  2B94 3D           dec a
0446+  2B95 32 FE CF     ld (netBufTemp),a
0447+  2B98 C2 9F 2B     jp nz,nte_cpbnlast
0448+  2B9B 3A F7 CF     ld a,(netDataLen)
0449+  2B9E 47           ld b,a
0450+  2B9F             nte_cpbnlast:
0451+  2B9F ED B2        inir                   ; Copy one page from io
0452+  2BA1             nte_iocpend:
0453+  2BA1 D9           exx
0454+  2BA2~            #ifdef DEBUG_MM
0455+  2BA2~             push bc
0456+  2BA2~             ld a,2
0457+  2BA2~             ld c,SSeg3
0458+  2BA2~             call n_to_7seg
0459+  2BA2~             pop bc
0460+  2BA2             #endif
0461+  2BA2 AF           xor a
0462+  2BA3 05           dec b
0463+  2BA4 C2 33 2B     jp nz,nta_pgloop
0464+  2BA7 3A FF CF     ld a,(netBufTocId)
0465+  2BAA C3 BD 2B     jp nta_end
0466+  2BAD             nta_copyfrommem:
0467+  2BAD~            #ifdef DEBUG_MM
0468+  2BAD~             ld a,4
0469+  2BAD~             ld c,SSeg3
0470+  2BAD~             call n_to_7seg
0471+  2BAD             #endif
0472+  2BAD 01 00 01     ld bc,$100
0473+  2BB0 EB           ex de,hl
0474+  2BB1 ED B0        ldir                   ; Copy one page from mem
0475+  2BB3 EB           ex de,hl
0476+  2BB4 D9           exx
0477+  2BB5~            #ifdef DEBUG_MM
0478+  2BB5~             push bc
0479+  2BB5~             ld a,5
0480+  2BB5~             ld c,SSeg3
0481+  2BB5~             call n_to_7seg
0482+  2BB5~             pop bc
0483+  2BB5             #endif
0484+  2BB5 AF           xor a
0485+  2BB6 05           dec b
0486+  2BB7 C2 33 2B     jp nz,nta_pgloop
0487+  2BBA 3A FF CF     ld a,(netBufTocId)
0488+  2BBD             nta_end:
0489+  2BBD 47           ld b,a
0490+  2BBE~            #ifdef DEBUG_MM
0491+  2BBE~             ld a,8
0492+  2BBE~             ld c,SSeg2
0493+  2BBE~             call n_to_7seg
0494+  2BBE             #endif
0495+  2BBE AF           xor a
0496+  2BBF 32 FD CF     ld (netBufStatus),a
0497+  2BC2 78           ld a,b
0498+  2BC3 E1           pop hl
0499+  2BC4 D1           pop de
0500+  2BC5 C1           pop bc
0501+  2BC6 C9           ret
0502+  2BC7             ; end of net_allocbuffer
0503+  2BC7             
0504+  2BC7             ; *******************************
0505+  2BC7             ; net_freebuffer
0506+  2BC7             ; Marks free a TOC which ID must be stored in (netBufTocId)
0507+  2BC7             nnet_freebuffer:
0508+  2BC7 F5           push af
0509+  2BC8 C5           push bc
0510+  2BC9 DD E5        push ix
0511+  2BCB FD E5        push iy
0512+  2BCD DD 21 00 CC  ld ix,netBufToc
0513+  2BD1 01 0A 00     ld bc,nBuf1TocSize
0514+  2BD4 3A FF CF     ld a,(netBufTocId)
0515+  2BD7 3C           inc a
0516+  2BD8             ntf_gettotoc:
0517+  2BD8 3D           dec a
0518+  2BD9 CA E1 2B     jp z,ntf_gottotoc
0519+  2BDC DD 09        add ix,bc
0520+  2BDE C3 D8 2B     jp ntf_gettotoc
0521+  2BE1             ntf_gottotoc:
0522+  2BE1 DD 7E 00     ld a,(ix+nBufTocStat)
0523+  2BE4 FE 00        cp 0
0524+  2BE6 CA 0B 2C     jp z,ntf_end
0525+  2BE9 AF           xor a
0526+  2BEA 47           ld b,a
0527+  2BEB DD 77 00     ld (ix+nBufTocStat),a
0528+  2BEE DD 4E 01     ld c,(ix+nBufTocNPages)
0529+  2BF1 3A F6 CF     ld a,(netBufUsedPages)
0530+  2BF4 91           sub c
0531+  2BF5 32 F6 CF     ld (netBufUsedPages),a
0532+  2BF8 79           ld a,c
0533+  2BF9 FD 21 EA CF  ld iy,netBufStat
0534+  2BFD             ntf_markpagesfree:
0535+  2BFD DD 4E 04     ld c,(ix+nBufTocPages)
0536+  2C00 FD 09        add iy,bc
0537+  2C02 FD 70 00     ld (iy),b
0538+  2C05 DD 23        inc ix
0539+  2C07 3D           dec a
0540+  2C08 C2 FD 2B     jp nz,ntf_markpagesfree
0541+  2C0B             ntf_end:
0542+  2C0B FD E1        pop iy
0543+  2C0D DD E1        pop ix
0544+  2C0F C1           pop bc
0545+  2C10 F1           pop af
0546+  2C11 C9           ret
0547+  2C12             ; end of net_freebuffer
0548+  2C12             
0549+  2C12             ; end of Memory manager
0550+  2C12             ;**************************************************************
0551+  2C12             
0552+  2C12             ; *******************************
0553+  2C12             ; net_init
0554+  2C12             nnet_init:
0555+  2C12 F3          	di
0556+  2C13 E5          	push hl
0557+  2C14 D5          	push de
0558+  2C15 C5          	push bc
0559+  2C16 CD 0C 2A    	call net_resetbuf
0560+  2C19             ; Set default ip, netmask, gateway and dns
0561+  2C19 21 12 2A    	ld hl, default_ip_settings
0562+  2C1C 11 D0 CF    	ld de, IpAddress
0563+  2C1F 01 10 00    	ld bc, 4 * 4
0564+  2C22 ED B0       	ldir
0565+  2C24             ; Logical and between ip and netmask for later use
0566+  2C24 DD 21 D4 CF 	ld ix, NetMask
0567+  2C28 3A D0 CF    	ld a, (IpAddress)
0568+  2C2B DD A6 00    	and (ix)
0569+  2C2E 32 CC CF    	ld (IpMasked),a
0570+  2C31 3A D1 CF    	ld a, (IpAddress+1)
0571+  2C34 DD A6 01    	and (ix+1)
0572+  2C37 32 CD CF    	ld (IpMasked+1),a
0573+  2C3A 3A D2 CF    	ld a, (IpAddress+2)
0574+  2C3D DD A6 02    	and (ix+2)
0575+  2C40 32 CE CF    	ld (IpMasked+2),a
0576+  2C43 3A D3 CF    	ld a, (IpAddress+3)
0577+  2C46 DD A6 03    	and (ix+3)
0578+  2C49 32 CF CF    	ld (IpMasked+3), a
0579+  2C4C             ; Set icmp reply type and code
0580+  2C4C 3E 00       	ld a, ICMP_DEFAULT_REPLY_TYPE
0581+  2C4E 32 C6 CF    	ld (netIcmpReplyType), a
0582+  2C51 3E 00       	ld a, ICMP_DEFAULT_REPLY_CODE
0583+  2C53 32 C7 CF    	ld (netIcmpReplyCode), a
0584+  2C56             ; Send kind of 'test packet'
0585+  2C56 AF          	xor a
0586+  2C57 32 D4 EA    	ld (ethDataPage), a
0587+  2C5A 3A B1 EA    	ld a, (etxStartPage)
0588+  2C5D 32 D5 EA    	ld (ethDataPage+1), a
0589+  2C60 21 3C 00    	ld hl, MIN_ETH_PACKET_SIZE
0590+  2C63 22 D2 EA    	ld (ethDataLen), hl
0591+  2C66 21 5B 20    	ld hl, test_packet
0592+  2C69 22 D0 EA    	ld (ethDataAddr), hl
0593+  2C6C CD 1C 20    	call ethSend
0594+  2C6F             ;
0595+  2C6F C1          	pop bc
0596+  2C70 D1          	pop de
0597+  2C71 E1          	pop hl
0598+  2C72 FB          	ei
0599+  2C73 C9          	ret
0600+  2C74             ; end of nnet_init
0601+  2C74             
0602+  2C74             ; *******************************
0603+  2C74             ; net_handlepacket
0604+  2C74             ; Should be called when a packet arrives from network
0605+  2C74             ; Packet TOC ID must be stored in (netBufTocId)
0606+  2C74             nnet_handlepacket:
0607+  2C74 F5           push af
0608+  2C75 C5           push bc
0609+  2C76 D5           push de
0610+  2C77 E5           push hl
0611+  2C78 FD E5        push iy
0612+  2C7A DD E5        push ix
0613+  2C7C             ; Find out what kind of packet we are dealing with
0614+  2C7C~            #ifdef DEBUG_HANDLEPACKET
0615+  2C7C~             ld a,0
0616+  2C7C~             ld c,SSeg1
0617+  2C7C~             call n_to_7seg
0618+  2C7C~             ld a,$ff
0619+  2C7C~             out (SSeg2),a
0620+  2C7C~             out (SSeg3),a
0621+  2C7C~             out (SSeg4),a
0622+  2C7C             #endif
0623+  2C7C             ; Get toc start into ix
0624+  2C7C DD 21 00 CC  ld ix,netBufToc
0625+  2C80 01 0A 00     ld bc,nBuf1TocSize
0626+  2C83 3A FF CF     ld a,(netBufTocId)
0627+  2C86 3C           inc a
0628+  2C87             nhtf_gettotoc:
0629+  2C87 3D           dec a
0630+  2C88 CA 90 2C     jp z,nhtf_gottotoc
0631+  2C8B DD 09        add ix,bc
0632+  2C8D C3 87 2C     jp nhtf_gettotoc
0633+  2C90             nhtf_gottotoc:
0634+  2C90             ; ld h,0
0635+  2C90             ; ld a,(netBufTocId)
0636+  2C90             ; sla a
0637+  2C90             ; ld l,a
0638+  2C90             ; ld bc,nBufTocPointers
0639+  2C90             ; add hl,bc
0640+  2C90             ; ld c,(hl)
0641+  2C90             ; inc hl
0642+  2C90             ; ld b,(hl)
0643+  2C90             ; ld ix,0
0644+  2C90             ; add ix,bc
0645+  2C90 DD 7E 00     ld a,(ix+nBufTocStat) ;disabled* Check, just for sure, that this
0646+  2C93 FE 01        cp nBufTocReserved    ;TOC is really in use
0647+  2C95 C2 D9 2C     jp nz,nh_end
0648+  2C98 DD 46 04     ld b,(ix+nBufTocPages)
0649+  2C9B 0E 00        ld c,0
0650+  2C9D FD 21 00 C0  ld iy,netBuffer
0651+  2CA1 FD 09        add iy,bc              ;Now iy has the start address of packet's first page
0652+  2CA3             ; Find out what protocol the packet is using
0653+  2CA3 3E 08        ld a,ARP_OR_IP
0654+  2CA5 FD BE 0C     cp (iy+ehType)
0655+  2CA8 C2 BB 2C     jp nz,nh_drop          ; No support for other than ip-protocol (and arp ofcourse)
0656+  2CAB 3E 00        ld a,IP_PACKET 
0657+  2CAD FD BE 0D     cp (iy+ehType+1)
0658+  2CB0 CA D7 2D     jp z,nh_handleippacket
0659+  2CB3 3E 06        ld a,ARP_PACKET 
0660+  2CB5 FD BE 0D     cp (iy+ehType+1)
0661+  2CB8 CA E2 2C     jp z,nh_handlearppacket
0662+  2CBB             ; Now the packet should be handled and the buffer can be set free
0663+  2CBB             nh_drop:
0664+  2CBB             nh_packethandled:
0665+  2CBB             ; This is same as the free-buffer-routine, just little shorter
0666+  2CBB 06 00        ld b,0
0667+  2CBD DD 36 00 00  ld (ix+nBufTocStat),0
0668+  2CC1 DD 4E 01     ld c,(ix+nBufTocNPages)
0669+  2CC4 3A F6 CF     ld a,(netBufUsedPages)
0670+  2CC7 91           sub c
0671+  2CC8 32 F6 CF     ld (netBufUsedPages),a
0672+  2CCB             nhtf_markpagesfree:
0673+  2CCB 21 EA CF     ld hl,netBufStat
0674+  2CCE DD 4E 04     ld c,(ix+nBufTocPages)
0675+  2CD1 09           add hl,bc
0676+  2CD2 70           ld (hl),b
0677+  2CD3 DD 23        inc ix
0678+  2CD5 3D           dec a
0679+  2CD6 C2 CB 2C     jp nz,nhtf_markpagesfree
0680+  2CD9             nhtf_end:
0681+  2CD9             ;
0682+  2CD9             nh_end:
0683+  2CD9~            #ifdef DEBUG_HANDLEPACKET
0684+  2CD9~             ld a,2
0685+  2CD9~             ld c,SSeg1
0686+  2CD9~             call n_to_7seg
0687+  2CD9             #endif
0688+  2CD9 DD E1        pop ix
0689+  2CDB FD E1        pop iy
0690+  2CDD E1           pop hl
0691+  2CDE D1           pop de
0692+  2CDF C1           pop bc
0693+  2CE0 F1           pop af
0694+  2CE1 C9           ret
0695+  2CE2              
0696+  2CE2             ; *******************************
0697+  2CE2             ;
0698+  2CE2             ; Handle an arp-packet
0699+  2CE2             ;
0700+  2CE2             nh_handlearppacket:
0701+  2CE2~            #ifdef DEBUG_HANDLEPACKET
0702+  2CE2~             ld a,0
0703+  2CE2~             ld c,SSeg2
0704+  2CE2~             call n_to_7seg
0705+  2CE2             #endif
0706+  2CE2             ; Here could be checked if the packet is too small, but
0707+  2CE2             ; the NIC drivers should already have checked that the packet
0708+  2CE2             ; is atleast 60 bytes long.
0709+  2CE2             ; ld a,(ix+nBufTocLen+1)
0710+  2CE2             ; cp 0
0711+  2CE2             ; jp nz,nh_enough
0712+  2CE2             ; ld a,(ix+nBufTocLen)
0713+  2CE2             ; cp ehDlcSize+ehArpSize
0714+  2CE2             ; jp c,nh_packethandled
0715+  2CE2             ;nh_enough:
0716+  2CE2 AF           xor a
0717+  2CE3 FD BE 14     cp (iy+ehArpOpCode)
0718+  2CE6 C2 BB 2C     jp nz,nh_packethandled
0719+  2CE9 FD 7E 15     ld a,(iy+ehArpOpCode+1)
0720+  2CEC FE 01        cp ARP_REQUEST
0721+  2CEE CA F9 2C     jp z,nh_arprequest
0722+  2CF1 FE 02        cp ARP_REPLY
0723+  2CF3 C2 BB 2C     jp nz,nh_packethandled
0724+  2CF6             ; *******************************
0725+  2CF6             nh_arpreply:
0726+  2CF6~            #ifdef DEBUG_HANDLEPACKET
0727+  2CF6~             ld a,0
0728+  2CF6~             ld c,SSeg3
0729+  2CF6~             call n_to_7seg
0730+  2CF6             #endif
0731+  2CF6 C3 BB 2C     jp nh_packethandled
0732+  2CF9             ; *******************************
0733+  2CF9             nh_arprequest:
0734+  2CF9~            #ifdef DEBUG_HANDLEPACKET
0735+  2CF9~             ld a,8
0736+  2CF9~             ld c,SSeg3
0737+  2CF9~             call n_to_7seg
0738+  2CF9             #endif
0739+  2CF9             ; Check that is the ip-address this node's
0740+  2CF9 3A D0 CF     ld a,(IpAddress)
0741+  2CFC FD BE 26     cp (iy+ehArpTargetIp)
0742+  2CFF C2 BB 2C     jp nz,nh_packethandled
0743+  2D02 3A D1 CF     ld a,(IpAddress+1)
0744+  2D05 FD BE 27     cp (iy+ehArpTargetIp+1)
0745+  2D08 C2 BB 2C     jp nz,nh_packethandled
0746+  2D0B 3A D2 CF     ld a,(IpAddress+2)
0747+  2D0E FD BE 28     cp (iy+ehArpTargetIp+2)
0748+  2D11 C2 BB 2C     jp nz,nh_packethandled
0749+  2D14 3A D3 CF     ld a,(IpAddress+3)
0750+  2D17 FD BE 29     cp (iy+ehArpTargetIp+3)
0751+  2D1A C2 BB 2C     jp nz,nh_packethandled
0752+  2D1D~            #ifdef DEBUG_HANDLEPACKET
0753+  2D1D~             ld a,9
0754+  2D1D~             ld c,SSeg3
0755+  2D1D~             call n_to_7seg
0756+  2D1D             #endif
0757+  2D1D             ; This ARP-request was meant for this node
0758+  2D1D             ; Set opcode to ARP-reply
0759+  2D1D             ; ld (iy+ehArpOpCode),0
0760+  2D1D FD 36 15 02  ld (iy+ehArpOpCode+1),ARP_REPLY
0761+  2D21             ; Set target MAC-address (horrifying long, but faster than a loop)
0762+  2D21             #define nh__set_target_mac_address(fix) ld a,(iy+ehArpSourceHw+fix)
0763+  2D21             #defcont \ ld (iy+ehArpTargetHw+fix),a
0764+  2D21             #defcont \ ld (iy+ehTarget+fix),a
0765+  2D21 FD 7E 16     nh__set_target_mac_address(0)
0765+  2D24 FD 77 20    
0765+  2D27 FD 77 00    
0766+  2D2A FD 7E 17     nh__set_target_mac_address(1)
0766+  2D2D FD 77 21    
0766+  2D30 FD 77 01    
0767+  2D33 FD 7E 18     nh__set_target_mac_address(2)
0767+  2D36 FD 77 22    
0767+  2D39 FD 77 02    
0768+  2D3C FD 7E 19     nh__set_target_mac_address(3)
0768+  2D3F FD 77 23    
0768+  2D42 FD 77 03    
0769+  2D45 FD 7E 1A     nh__set_target_mac_address(4)
0769+  2D48 FD 77 24    
0769+  2D4B FD 77 04    
0770+  2D4E FD 7E 1B     nh__set_target_mac_address(5)
0770+  2D51 FD 77 25    
0770+  2D54 FD 77 05    
0771+  2D57             ; Set source MAC-address
0772+  2D57             #define nh__set_source_mac_address(fix) ld a,(HWADDRESS+fix)
0773+  2D57             #defcont \ ld (iy+ehArpSourceHw+fix),a
0774+  2D57             #defcont \ ld (iy+ehSource+fix),a
0775+  2D57 3A 87 20     nh__set_source_mac_address(0)
0775+  2D5A FD 77 16    
0775+  2D5D FD 77 06    
0776+  2D60 3A 88 20     nh__set_source_mac_address(1)
0776+  2D63 FD 77 17    
0776+  2D66 FD 77 07    
0777+  2D69 3A 89 20     nh__set_source_mac_address(2)
0777+  2D6C FD 77 18    
0777+  2D6F FD 77 08    
0778+  2D72 3A 8A 20     nh__set_source_mac_address(3)
0778+  2D75 FD 77 19    
0778+  2D78 FD 77 09    
0779+  2D7B 3A 8B 20     nh__set_source_mac_address(4)
0779+  2D7E FD 77 1A    
0779+  2D81 FD 77 0A    
0780+  2D84 3A 8C 20     nh__set_source_mac_address(5)
0780+  2D87 FD 77 1B    
0780+  2D8A FD 77 0B    
0781+  2D8D             ; Set target IP-address
0782+  2D8D             #define nh__set_target_ip(fix) ld a,(iy+ehArpSourceIp+fix)
0783+  2D8D             #defcont \ ld (iy+ehArpTargetIp+fix),a
0784+  2D8D FD 7E 1C     nh__set_target_ip(0)
0784+  2D90 FD 77 26    
0785+  2D93 FD 7E 1D     nh__set_target_ip(1)
0785+  2D96 FD 77 27    
0786+  2D99 FD 7E 1E     nh__set_target_ip(2)
0786+  2D9C FD 77 28    
0787+  2D9F FD 7E 1F     nh__set_target_ip(3)
0787+  2DA2 FD 77 29    
0788+  2DA5             ; Set source IP-address
0789+  2DA5             #define nh__set_source_ip(fix) ld a,(IpAddress+fix)
0790+  2DA5             #defcont \ ld (iy+ehArpSourceIp+fix),a
0791+  2DA5 3A D0 CF     nh__set_source_ip(0)
0791+  2DA8 FD 77 1C    
0792+  2DAB 3A D1 CF     nh__set_source_ip(1)
0792+  2DAE FD 77 1D    
0793+  2DB1 3A D2 CF     nh__set_source_ip(2)
0793+  2DB4 FD 77 1E    
0794+  2DB7 3A D3 CF     nh__set_source_ip(3)
0794+  2DBA FD 77 1F    
0795+  2DBD             ; Send this packet
0796+  2DBD~            #ifdef DEBUG_HANDLEPACKET
0797+  2DBD~             ld a,$a
0798+  2DBD~             ld c,SSeg3
0799+  2DBD~             call n_to_7seg
0800+  2DBD             #endif
0801+  2DBD AF           xor a
0802+  2DBE 32 D4 EA     ld (ethDataPage),a
0803+  2DC1 3A B1 EA     ld a,(etxStartPage)
0804+  2DC4 32 D5 EA     ld (ethDataPage+1),a
0805+  2DC7 21 3C 00     ld hl,MIN_ETH_PACKET_SIZE
0806+  2DCA 22 D2 EA     ld (ethDataLen),hl
0807+  2DCD FD 22 D0 EA  ld (ethDataAddr),iy
0808+  2DD1 CD 1C 20     call ethSend
0809+  2DD4~            #ifdef DEBUG_HANDLEPACKET
0810+  2DD4~             ld a,$b
0811+  2DD4~             ld c,SSeg3
0812+  2DD4~             call n_to_7seg
0813+  2DD4             #endif
0814+  2DD4 C3 BB 2C     jp nh_packethandled
0815+  2DD7             ; end of handing of arp-packet
0816+  2DD7             
0817+  2DD7             ; *******************************
0818+  2DD7             ;
0819+  2DD7             ; Handle an ip-packet
0820+  2DD7             ;
0821+  2DD7             nh_handleippacket:
0822+  2DD7~            #ifdef DEBUG_HANDLEPACKET
0823+  2DD7~             ld a,1
0824+  2DD7~             ld c,SSeg2
0825+  2DD7~             call n_to_7seg
0826+  2DD7             #endif
0827+  2DD7             ; Check that the packet is valid
0828+  2DD7 3E 45        ld a,$45
0829+  2DD9 FD BE 0E     cp (iy+ehIpVhl)
0830+  2DDC C2 BB 2C     jp nz,nh_drop
0831+  2DDF             ; Here should be checked that the ip packet lenght is valid,
0832+  2DDF             ; but it is left out for now
0833+  2DDF             ; No ip fragments allowed
0834+  2DDF FD 7E 14     ld a,(iy+ehIpOffset)
0835+  2DE2 E6 3F        and $3f
0836+  2DE4 C2 BB 2C     jp nz,nh_drop
0837+  2DE7             ; Check if the packet is for us
0838+  2DE7 3A D3 CF     ld a,(IpAddress+3)
0839+  2DEA FD BE 21     cp (iy+ehIpTarget+3)
0840+  2DED C2 31 2E     jp nz,nhip_arpupdate
0841+  2DF0 3A D2 CF     ld a,(IpAddress+2)
0842+  2DF3 FD BE 20     cp (iy+ehIpTarget+2)
0843+  2DF6 C2 31 2E     jp nz,nhip_arpupdate
0844+  2DF9 3A D1 CF     ld a,(IpAddress+1)
0845+  2DFC FD BE 1F     cp (iy+ehIpTarget+1)
0846+  2DFF C2 31 2E     jp nz,nhip_arpupdate
0847+  2E02 3A D0 CF     ld a,(IpAddress)
0848+  2E05 FD BE 1E     cp (iy+ehIpTarget)
0849+  2E08 C2 31 2E     jp nz,nhip_arpupdate
0850+  2E0B             ; This packet is for us
0851+  2E0B             ; Check checksum
0852+  2E0B FD E5        push iy
0853+  2E0D 01 0E 00     ld bc,ehDlcSize
0854+  2E10 FD 09        add iy,bc
0855+  2E12 FD 22 C8 CF  ld (netChksumAddr),iy
0856+  2E16 01 14 00     ld bc,ehIpSize
0857+  2E19 ED 43 CA CF  ld (netChksumCount),bc
0858+  2E1D CD F6 2F     call chksum
0859+  2E20 FD E1        pop iy
0860+  2E22 01 01 00     ld bc,1
0861+  2E25 09           add hl,bc
0862+  2E26 D2 BB 2C     jp nc,nh_drop          ;If checksum failed then jump
0863+  2E29             ; Find out what ip-protocol the packet is  using
0864+  2E29 3E 01        ld a,IP_PROTO_ICMP
0865+  2E2B FD BE 17     cp (iy+ehIpProto)
0866+  2E2E CA 95 2E     jp z,nhip_icmp
0867+  2E31             nhip_arpupdate:
0868+  2E31             ; Use netmask to the packet ip
0869+  2E31             ; and compare packet and this node ip address with netmask
0870+  2E31             ; to see if the packet came from LAN
0871+  2E31 ED 5B CC CF  ld de,(IpMasked)
0872+  2E35 ED 4B CE CF  ld bc,(IpMasked+2)
0873+  2E39 21 D4 CF     ld hl,NetMask
0874+  2E3C FD 7E 1A     ld a,(iy+ehIpSource)
0875+  2E3F 32 E6 CF     ld (netIpAddress),a
0876+  2E42 A6           and (hl)
0877+  2E43 BB           cp e
0878+  2E44 C2 92 2E     jp nz,nhip_notlan
0879+  2E47 FD 7E 1B     ld a,(iy+ehIpSource+1)
0880+  2E4A 32 E7 CF     ld (netIpAddress+1),a
0881+  2E4D 23           inc hl
0882+  2E4E A6           and (hl)
0883+  2E4F BA           cp d
0884+  2E50 C2 92 2E     jp nz,nhip_notlan
0885+  2E53 FD 7E 1C     ld a,(iy+ehIpSource+2)
0886+  2E56 32 E8 CF     ld (netIpAddress+2),a
0887+  2E59 23           inc hl
0888+  2E5A A6           and (hl)
0889+  2E5B B9           cp c
0890+  2E5C C2 92 2E     jp nz,nhip_notlan
0891+  2E5F FD 7E 1D     ld a,(iy+ehIpSource+3)
0892+  2E62 32 E9 CF     ld (netIpAddress+3),a
0893+  2E65 23           inc hl
0894+  2E66 A6           and (hl)
0895+  2E67 B8           cp b
0896+  2E68 C2 92 2E     jp nz,nhip_notlan
0897+  2E6B             ; Packet came from LAN, update ARP-table
0898+  2E6B             ; Copy the packet ip and mac
0899+  2E6B             #define nh__copy_mac(fix) ld a,(iy+ehSource+fix)
0900+  2E6B             #defcont \ ld (netMacAddress+fix),a
0901+  2E6B FD 7E 06     nh__copy_mac(0)
0901+  2E6E 32 E0 CF    
0902+  2E71 FD 7E 07     nh__copy_mac(1)
0902+  2E74 32 E1 CF    
0903+  2E77 FD 7E 08     nh__copy_mac(2)
0903+  2E7A 32 E2 CF    
0904+  2E7D FD 7E 09     nh__copy_mac(3)
0904+  2E80 32 E3 CF    
0905+  2E83 FD 7E 0A     nh__copy_mac(4)
0905+  2E86 32 E4 CF    
0906+  2E89 FD 7E 0B     nh__copy_mac(5)
0906+  2E8C 32 E5 CF    
0907+  2E8F CD 49 30     call arp_update
0908+  2E92             nhip_notlan:
0909+  2E92 C3 BB 2C     jp nh_packethandled
0910+  2E95             
0911+  2E95             ; *******************************
0912+  2E95             ;
0913+  2E95             ; Handle icmp-packet
0914+  2E95             ;
0915+  2E95             nhip_icmp:
0916+  2E95~            #ifdef DEBUG_HANDLEPACKET
0917+  2E95~             ld a,0
0918+  2E95~             ld c,SSeg3
0919+  2E95~             call n_to_7seg
0920+  2E95             #endif
0921+  2E95             ; Here should be checked icmp-packet's checksum
0922+  2E95             ; but it is not so important than sparing cpu
0923+  2E95             ; time for more important things
0924+  2E95             ;
0925+  2E95             ; Limit icmp-packet size
0926+  2E95             ; If size is bigger than ICMP_MAX_SIZE
0927+  2E95             ; then just drop the packet
0928+  2E95             ; (Absolut maximum is 254)
0929+  2E95 AF           xor a
0930+  2E96 DD BE 03     cp (ix+nBufTocLen+1)
0931+  2E99 C2 BB 2C     jp nz,nh_drop
0932+  2E9C DD 7E 02     ld a,(ix+nBufTocLen)
0933+  2E9F FE 67        cp IP_ICMP_MAX_SIZE+1
0934+  2EA1 D2 BB 2C     jp nc,nh_drop
0935+  2EA4 3E 08        ld a,ICMP_ECHO
0936+  2EA6 FD BE 22     cp (iy+ehIcmpType)
0937+  2EA9 CA B7 2E     jp z,nhicmp_echo
0938+  2EAC 3E 00        ld a,ICMP_ECHO_REPLY
0939+  2EAE FD BE 22     cp (iy+ehIcmpType)
0940+  2EB1 CA F3 2F     jp z,nhicmp_reply
0941+  2EB4 C3 31 2E     jp nhip_arpupdate
0942+  2EB7             ; *******************************
0943+  2EB7             nhicmp_echo:
0944+  2EB7~            #ifdef DEBUG_HANDLEPACKET
0945+  2EB7~             ld a,0
0946+  2EB7~             ld c,SSeg4
0947+  2EB7~             call n_to_7seg
0948+  2EB7             #endif
0949+  2EB7             ; Check that is the icmp echo-reply
0950+  2EB7             ; denied totaly and if it is then
0951+  2EB7             ; just drop the packet
0952+  2EB7 3A C6 CF     ld a,(netIcmpReplyType)
0953+  2EBA FE 07        cp ICMP_DROP
0954+  2EBC CA BB 2C     jp z,nh_drop
0955+  2EBF             ; Just answer to the echo with the type
0956+  2EBF             ; and code defined in (netIcmpReply[Type,Code])
0957+  2EBF FE 03        cp ICMP_UNREACHABLE
0958+  2EC1 CC C3 2F     call z,icmp_unreachable
0959+  2EC4 FD 77 22     ld (iy+ehIcmpType),a
0960+  2EC7 FD 36 16 20  ld (iy+ehIpTtl),IP_ICMP_ECHO_TTL
0961+  2ECB             ;
0962+  2ECB             #define nhicmp__mac(fix) ld a,(iy+ehSource+fix)
0963+  2ECB             #defcont \ ld (iy+ehTarget+fix),a
0964+  2ECB             #defcont \ ld a,(HWADDRESS+fix)
0965+  2ECB             #defcont \ ld (iy+ehSource+fix),a
0966+  2ECB             #define nhicmp__ip(fix) ld a,(iy+ehIpSource+fix)
0967+  2ECB             #defcont \ ld (iy+ehIpTarget+fix),a
0968+  2ECB             #defcont \ ld a,(IpAddress+fix)
0969+  2ECB             #defcont \ ld (iy+ehIpSource+fix),a
0970+  2ECB FD 7E 06     nhicmp__mac(0)
0970+  2ECE FD 77 00    
0970+  2ED1 3A 87 20    
0970+  2ED4 FD 77 06    
0971+  2ED7 FD 7E 07     nhicmp__mac(1)
0971+  2EDA FD 77 01    
0971+  2EDD 3A 88 20    
0971+  2EE0 FD 77 07    
0972+  2EE3 FD 7E 08     nhicmp__mac(2)
0972+  2EE6 FD 77 02    
0972+  2EE9 3A 89 20    
0972+  2EEC FD 77 08    
0973+  2EEF FD 7E 09     nhicmp__mac(3)
0973+  2EF2 FD 77 03    
0973+  2EF5 3A 8A 20    
0973+  2EF8 FD 77 09    
0974+  2EFB FD 7E 0A     nhicmp__mac(4)
0974+  2EFE FD 77 04    
0974+  2F01 3A 8B 20    
0974+  2F04 FD 77 0A    
0975+  2F07 FD 7E 0B     nhicmp__mac(5)
0975+  2F0A FD 77 05    
0975+  2F0D 3A 8C 20    
0975+  2F10 FD 77 0B    
0976+  2F13 FD 7E 1A     nhicmp__ip(0)
0976+  2F16 FD 77 1E    
0976+  2F19 3A D0 CF    
0976+  2F1C FD 77 1A    
0977+  2F1F FD 7E 1B     nhicmp__ip(1)
0977+  2F22 FD 77 1F    
0977+  2F25 3A D1 CF    
0977+  2F28 FD 77 1B    
0978+  2F2B FD 7E 1C     nhicmp__ip(2)
0978+  2F2E FD 77 20    
0978+  2F31 3A D2 CF    
0978+  2F34 FD 77 1C    
0979+  2F37 FD 7E 1D     nhicmp__ip(3)
0979+  2F3A FD 77 21    
0979+  2F3D 3A D3 CF    
0979+  2F40 FD 77 1D    
0980+  2F43             ; Set up sending parameters
0981+  2F43 AF           xor a
0982+  2F44 32 D3 EA     ld (ethDataLen+1),a
0983+  2F47 FD 77 10     ld (iy+ehIpLen),a
0984+  2F4A FD 22 D0 EA  ld (ethDataAddr),iy
0985+  2F4E DD 7E 02     ld a,(ix+nBufTocLen)
0986+  2F51 32 D2 EA     ld (ethDataLen),a
0987+  2F54 D6 0E        sub ehDlcSize
0988+  2F56 FD 77 11     ld (iy+ehIpLen+1),a
0989+  2F59 3A 80 EB     ld a,(uptime)
0990+  2F5C FD 86 12     add a,(iy+ehIpId)
0991+  2F5F FD 77 12     ld (iy+ehIpId),a
0992+  2F62 FD 86 13     add a,(iy+ehIpId+1)
0993+  2F65 FD 77 13     ld (iy+ehIpId+1),a
0994+  2F68             ; Calculate checksums
0995+  2F68 FD 36 18 00  ld (iy+ehIpChecksum),0
0996+  2F6C FD 36 19 00  ld (iy+ehIpChecksum+1),0
0997+  2F70 FD 36 24 00  ld (iy+ehIcmpChecksum),0
0998+  2F74 FD 36 25 00  ld (iy+ehIcmpChecksum+1),0
0999+  2F78 FD E5        push iy
1000+  2F7A 01 14 00     ld bc,ehIpSize
1001+  2F7D ED 43 CA CF  ld (netChksumCount),bc
1002+  2F81 01 0E 00     ld bc,ehDlcSize
1003+  2F84 FD 09        add iy,bc
1004+  2F86 FD 22 C8 CF  ld (netChksumAddr),iy
1005+  2F8A CD F6 2F     call chksum
1006+  2F8D ED 5B C8 CF  ld de,(netChksumAddr)
1007+  2F91 DD 7E 02     ld a,(ix+nBufTocLen)
1008+  2F94 D6 22        sub ehDlcSize+ehIpSize
1009+  2F96 32 CA CF     ld (netChksumCount),a
1010+  2F99 AF           xor a
1011+  2F9A 32 CB CF     ld (netChksumCount+1),a
1012+  2F9D 01 14 00     ld bc,ehIpSize
1013+  2FA0 FD 09        add iy,bc
1014+  2FA2 FD 22 C8 CF  ld (netChksumAddr),iy
1015+  2FA6 CD F6 2F     call chksum
1016+  2FA9 FD E1        pop iy
1017+  2FAB FD 72 18     ld (iy+ehIpChecksum),d
1018+  2FAE FD 73 19     ld (iy+ehIpChecksum+1),e
1019+  2FB1 3A C9 CF     ld a,(netChksumAddr+1)
1020+  2FB4 FD 77 24     ld (iy+ehIcmpChecksum),a
1021+  2FB7 3A C8 CF     ld a,(netChksumAddr)
1022+  2FBA FD 77 25     ld (iy+ehIcmpChecksum+1),a
1023+  2FBD             ; Send
1024+  2FBD CD 1C 20     call ethSend
1025+  2FC0 C3 31 2E     jp nhip_arpupdate
1026+  2FC3             ; icmp-reply type is destination unreachable
1027+  2FC3             icmp_unreachable:
1028+  2FC3 FD 22 C8 CF  ld (netChksumAddr),iy
1029+  2FC7 2A C8 CF     ld hl,(netChksumAddr)
1030+  2FCA 54           ld d,h
1031+  2FCB 5D           ld e,l
1032+  2FCC 01 65 00     ld bc,ehDlcSize+ehIpSize+ehIcmpSize+ehIpSize+39
1033+  2FCF 09           add hl,bc
1034+  2FD0 EB           ex de,hl
1035+  2FD1 01 49 00     ld bc,ehDlcSize+ehIpSize+39
1036+  2FD4 09           add hl,bc
1037+  2FD5 01 3C 00     ld bc,ehIpSize+40
1038+  2FD8 ED B8        lddr
1039+  2FDA 3E 66        ld a,ehDlcSize+ehIpSize+ehIcmpSize+ehIpSize+40
1040+  2FDC DD 77 02     ld (ix+nBufTocLen),a
1041+  2FDF 3E C0        ld a,$c0
1042+  2FE1 FD 77 0F     ld (iy+ehIpTos),a
1043+  2FE4 3E 40        ld a,$40               ; No fragmentation allowed
1044+  2FE6 FD 77 14     ld (iy+ehIpOffset),a
1045+  2FE9             ; ld a,ICMP_UNREACHABLE_TTL
1046+  2FE9             ; ld (iy+ehIpTtl),a
1047+  2FE9 3A C7 CF     ld a,(netIcmpReplyCode)
1048+  2FEC FD 77 23     ld (iy+ehIcmpCode),a
1049+  2FEF             ;
1050+  2FEF 3A C6 CF     ld a,(netIcmpReplyType)
1051+  2FF2 C9           ret
1052+  2FF3             ; *******************************
1053+  2FF3             nhicmp_reply:
1054+  2FF3~            #ifdef DEBUG_HANDLEPACKET
1055+  2FF3~             ld a,1
1056+  2FF3~             ld c,SSeg4
1057+  2FF3~             call n_to_7seg
1058+  2FF3             #endif
1059+  2FF3 C3 31 2E     jp nhip_arpupdate
1060+  2FF6             ; end of handling icmp-packet 
1061+  2FF6             
1062+  2FF6             ; end of handling ip-packet 
1063+  2FF6             
1064+  2FF6             ; end of net_handlepacket
1065+  2FF6             
1066+  2FF6             ; *******************************
1067+  2FF6             ; chksum
1068+  2FF6             ; Calculates checksum of example ip-header
1069+  2FF6             ; Data address in (netChksumAddr) and count in (netChksumCount)
1070+  2FF6             ; Returns checksum in (netChksumAddr) and in hl as inversed
1071+  2FF6             chksum:
1072+  2FF6             ; push af
1073+  2FF6 C5           push bc
1074+  2FF7 D5           push de
1075+  2FF8             ; push hl
1076+  2FF8 DD E5        push ix
1077+  2FFA 21 00 00     ld hl,0
1078+  2FFD DD 2A C8 CF  ld ix,(netChksumAddr)
1079+  3001 ED 4B CA CF  ld bc,(netChksumCount)
1080+  3005 CB 38        srl b
1081+  3007 CB 19        rr c
1082+  3009 04           inc b
1083+  300A B7           or a
1084+  300B             chks_loop:
1085+  300B DD 56 00     ld d,(ix)
1086+  300E DD 5E 01     ld e,(ix+1)
1087+  3011 DD 23        inc ix
1088+  3013 DD 23        inc ix
1089+  3015 ED 5A        adc hl,de
1090+  3017 0D           dec c
1091+  3018 C2 0B 30     jp nz,chks_loop
1092+  301B 05           dec b
1093+  301C C2 0B 30     jp nz,chks_loop
1094+  301F 11 00 00     ld de,0
1095+  3022 ED 5A        adc hl,de
1096+  3024 3A CA CF     ld a,(netChksumCount)
1097+  3027 E6 01        and 1
1098+  3029 CA 38 30     jp z,chks_noodd
1099+  302C DD 56 00     ld d,(ix)
1100+  302F 1E 00        ld e,0
1101+  3031 ED 5A        adc hl,de
1102+  3033 11 00 00     ld de,0
1103+  3036 ED 5A        adc hl,de
1104+  3038             chks_noodd:
1105+  3038 7C           ld a,h
1106+  3039 EE FF        xor $ff
1107+  303B 32 C9 CF     ld (netChksumAddr+1),a
1108+  303E 7D           ld a,l
1109+  303F EE FF        xor $ff
1110+  3041 32 C8 CF     ld (netChksumAddr),a
1111+  3044 DD E1        pop ix
1112+  3046             ; pop hl
1113+  3046 D1           pop de
1114+  3047 C1           pop bc
1115+  3048             ; pop af
1116+  3048 C9           ret 
1117+  3049             
1118+  3049             ; *******************************
1119+  3049             ; arp_update
1120+  3049             ; Updates ARP-table
1121+  3049             ; Incoming packets IP-address must be stored in (netIpAddress)
1122+  3049             ; and MAC-address in (netMacAddress)
1123+  3049             arp_update:
1124+  3049             ; Pushs and pops should be enabled if this routine
1125+  3049             ; is called from else where than net_handlepacket
1126+  3049             ; push af
1127+  3049             ; push bc
1128+  3049             ; push de
1129+  3049             ; push hl
1130+  3049 FD E5        push iy
1131+  304B DD E5        push ix
1132+  304D 0E 11        ld c,nArpTables+1
1133+  304F 11 0C 00     ld de,nArp1TabSize
1134+  3052 DD 21 44 CC  ld ix,netArpTable-nArp1TabSize
1135+  3056             aup_findupdate:
1136+  3056 AF           xor a
1137+  3057 DD 19        add ix,de
1138+  3059 0D           dec c
1139+  305A CA 8A 30     jp z,aup_noold
1140+  305D DD BE 00     cp (ix+nArpTabStat)
1141+  3060 CA 56 30     jp z,aup_findupdate
1142+  3063 3A E6 CF     ld a,(netIpAddress)
1143+  3066 DD BE 08     cp (ix+nArpTabIp)
1144+  3069 C2 56 30     jp nz,aup_findupdate
1145+  306C 3A E7 CF     ld a,(netIpAddress+1)
1146+  306F DD BE 09     cp (ix+nArpTabIp+1)
1147+  3072 C2 56 30     jp nz,aup_findupdate
1148+  3075 3A E8 CF     ld a,(netIpAddress+2)
1149+  3078 DD BE 0A     cp (ix+nArpTabIp+2)
1150+  307B C2 56 30     jp nz,aup_findupdate
1151+  307E 3A E9 CF     ld a,(netIpAddress+3)
1152+  3081 DD BE 0B     cp (ix+nArpTabIp+3)
1153+  3084 C2 56 30     jp nz,aup_findupdate
1154+  3087 C3 E9 30     jp aup_end
1155+  308A             aup_noold:
1156+  308A 0E 11        ld c,nArpTables+1
1157+  308C 16 00        ld d,0
1158+  308E 1E 0C        ld e,nArp1TabSize
1159+  3090 DD 21 44 CC  ld ix,netArpTable-nArp1TabSize
1160+  3094 AF           xor a
1161+  3095             aup_findempty:
1162+  3095 DD 19        add ix,de
1163+  3097 0D           dec c
1164+  3098 CA A4 30     jp z,aup_noempty
1165+  309B DD BE 00     cp (ix+nArpTabStat)
1166+  309E C2 95 30     jp nz,aup_findempty
1167+  30A1 C3 D5 30     jp aup_ipend
1168+  30A4             aup_noempty:
1169+  30A4 0E 10        ld c,nArpTables
1170+  30A6 16 00        ld d,0
1171+  30A8 1E 0C        ld e,nArp1TabSize
1172+  30AA FD 21 50 CC  ld iy,netArpTable
1173+  30AE DD 21 50 CC  ld ix,netArpTable
1174+  30B2 DD 7E 28     ld a,(ix+nArpDate)
1175+  30B5             aup_findoldest:
1176+  30B5 FD 19        add iy,de
1177+  30B7 0D           dec c
1178+  30B8 CA D5 30     jp z,aup_ipend
1179+  30BB FD BE 01     cp (iy+nArpTabDate)
1180+  30BE DA B5 30     jp c,aup_findoldest
1181+  30C1 AF           xor a
1182+  30C2 FD BE 00     cp (iy+nArpTabStat)
1183+  30C5 DD 7E 01     ld a,(ix+nArpTabDate)
1184+  30C8 CA B5 30     jp z,aup_findoldest
1185+  30CB FD E5        push iy
1186+  30CD DD E1        pop ix
1187+  30CF DD 7E 01     ld a,(ix+nArpTabDate)
1188+  30D2 C3 B5 30     jp aup_findoldest
1189+  30D5             aup_ipend:
1190+  30D5 ED 4B E6 CF  ld bc,(netIpAddress)
1191+  30D9 ED 5B E8 CF  ld de,(netIpAddress+2)
1192+  30DD DD 71 08     ld (ix+nArpTabIp),c
1193+  30E0 DD 70 09     ld (ix+nArpTabIp+1),b
1194+  30E3 DD 73 0A     ld (ix+nArpTabIp+2),e
1195+  30E6 DD 72 0B     ld (ix+nArpTabIp+3),d
1196+  30E9             aup_end:
1197+  30E9 3E 28        ld a,nArpDate
1198+  30EB ED 4B E0 CF  ld bc,(netMacAddress)
1199+  30EF ED 5B E2 CF  ld de,(netMacAddress+2)
1200+  30F3 2A E4 CF     ld hl,(netMacAddress+4)
1201+  30F6 DD 77 00     ld (ix+nArpTabStat),a
1202+  30F9 DD 77 01     ld (ix+nArpTabDate),a
1203+  30FC DD 71 02     ld (ix+nArpTabMAC),c
1204+  30FF DD 70 03     ld (ix+nArpTabMAC+1),b
1205+  3102 DD 73 04     ld (ix+nArpTabMAC+2),e
1206+  3105 DD 72 05     ld (ix+nArpTabMAC+3),d
1207+  3108 DD 75 06     ld (ix+nArpTabMAC+4),l
1208+  310B DD 74 07     ld (ix+nArpTabMAC+5),h
1209+  310E DD E1        pop ix
1210+  3110 FD E1        pop iy
1211+  3112             ; pop hl
1212+  3112             ; pop de
1213+  3112             ; pop bc
1214+  3112             ; pop af
1215+  3112 C9           ret
1216+  3113             ; end of arp_update
1217+  3113             
1218+  3113             ; end of TCP/IP & ARP
1219+  3113             ;**************************************************************
1220+  3113             
1221+  3113             ; Something for testing
1222+  3A00             .org $3a00
1223+  3A00             test1:
1224+  3A00 06 00        ld b,0
1225+  3A02             t1_loop:
1226+  3A02 ED 79        out (c),a
1227+  3A04 10 FC        djnz t1_loop
1228+  3A06 C9           ret
1229+  3A07             
1230+  3A20             .org $3a20
1231+  3A20             test2:
1232+  3A20 06 00        ld b,0
1233+  3A22             t2_loop:
1234+  3A22 ED 79        out (c),a
1235+  3A24 3C           inc a
1236+  3A25 10 FB        djnz t2_loop
1237+  3A27 C9           ret
1238+  3A28             
1239+  3A20             .org $3a20
1240+  3A20             test4:
1241+  3A20 0E E0        ld c,$e0
1242+  3A22 06 00        ld b,0
1243+  3A24             t4_loop:
1244+  3A24 79           ld a,c
1245+  3A25 D3 01        out (SSeg1),a
1246+  3A27 AF           xor a
1247+  3A28 ED 79        out (c),a
1248+  3A2A 10 F8        djnz t4_loop
1249+  3A2C 11 E8 03     ld de,1000
1250+  3A2F CD 54 05     call Delayms
1251+  3A32 0C           inc c
1252+  3A33 C2 24 3A     jp nz,t4_loop
1253+  3A36 C9           ret
1254+  3A37             
1255+  3A60             .org $3a60
1256+  3A60             test3:
1257+  3A60 06 00        ld b,0
1258+  3A62             t3_loop:
1259+  3A62 D3 E0        out ($e0),a
1260+  3A64 D3 E1        out ($e1),a
1261+  3A66 D3 E2        out ($e2),a
1262+  3A68 D3 E3        out ($e3),a
1263+  3A6A D3 E4        out ($e4),a
1264+  3A6C D3 E5        out ($e5),a
1265+  3A6E D3 E6        out ($e6),a
1266+  3A70 D3 E7        out ($e7),a
1267+  3A72             
1268+  3A72 D3 E8        out ($e8),a
1269+  3A74 D3 E9        out ($e9),a
1270+  3A76 D3 EA        out ($ea),a
1271+  3A78 D3 EB        out ($eb),a
1272+  3A7A D3 EC        out ($ec),a
1273+  3A7C D3 ED        out ($ed),a
1274+  3A7E D3 EE        out ($ee),a
1275+  3A80 D3 EF        out ($ef),a
1276+  3A82             
1277+  3A82 D3 F0        out ($f0),a
1278+  3A84 D3 F1        out ($f1),a
1279+  3A86 D3 F2        out ($f2),a
1280+  3A88 D3 F3        out ($f3),a
1281+  3A8A D3 F4        out ($f4),a
1282+  3A8C D3 F5        out ($f5),a
1283+  3A8E D3 F6        out ($f6),a
1284+  3A90 D3 F7        out ($f7),a
1285+  3A92             
1286+  3A92 D3 F8        out ($f8),a
1287+  3A94 D3 F9        out ($f9),a
1288+  3A96 D3 FA        out ($fa),a
1289+  3A98 D3 FB        out ($fb),a
1290+  3A9A D3 FC        out ($fc),a
1291+  3A9C D3 FD        out ($fd),a
1292+  3A9E D3 FE        out ($fe),a
1293+  3AA0 D3 FF        out ($ff),a
1294+  3AA2             
1295+  3AA2 10 BE        djnz t3_loop
1296+  3AA4 C9           ret
1297+  3AA5             
1298+  3AA5             ;
1299+  3AA5~            #ifdef ALONE
1300+  3AA5~            .end
1301+  3AA5             #endif
2794   3AA5             
2795   3AA5             .end
2796   3AA5             
tasm: Number of errors = 0
