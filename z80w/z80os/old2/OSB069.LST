0001   0000             ;**************************************************************
0002   0000             ;
0003   0000             ;                       The Z80 WestOS
0004   0000             ;
0005   0000             ;                 Operating System for Z80 board
0006   0000             ;                       West 17 Designs
0007   0000             ;                        - by Duge -
0008   0000             ;
0009   0000             ;**************************************************************
0010   0000             ; Misc information:
0011   0000             ; The LCD-display mentioned in the code should be 2x20
0012   0000             ; characters LCD-display module using hd44780-based
0013   0000             ; controller.
0014   0000             ;
0015   0000             ;**************************************************************
0016   0000             
0017   0000             #define OS_FILE
0018   0000             
0019   0000             #include "OSdef.h"
0001+  0000             ;**************************************************************
0002+  0000             ;
0003+  0000             ; Defines & equs & routine addresses
0004+  0000             ;
0005+  0000             ;**************************************************************
0006+  0000             
0007+  0000             #define equ .equ
0008+  0000             
0009+  0000             #define CPU_AT_4MHZ
0010+  0000             
0011+  0000             ; Macros for using the LEDs
0012+  0000             #define led_reset(reset) ld a,(LEDs_state)\ or ~reset\ out (LEDs),a\ ld (LEDs_state),a
0013+  0000             #define led_set(set) ld a,(LEDs_state)\ and ~set\ out (LEDs),a\ ld (LEDs_state),a
0014+  0000             #define led_toggle(toggle) ld a,(LEDs_state)\ xor toggle\ out (LEDs),a\ ld (LEDs_state),a
0015+  0000             #define leds_load(load) ld a,load\ out (LEDs),a\ ld (LEDs_state),a
0016+  0000             
0017+  0000             ; Operating system reserves memory between $ea00-$ffff
0018+  0000             
0019+  0000             ; Stack Pointer start value,
0020+  0000             ; it reserves 256bytes ($ff00-$ffff)
0021+  0000             StackPointerOrigin: equ $fff0
0022+  0000             ; Variables
0023+  0000             SRM             equ $ea00       ; Here are OS's variables
0024+  0000             UMO             equ $e000       ; Here starts the 'User's Memory' (1KB)
0025+  0000             ; Temporary values
0026+  0000             T0              equ SRM+0       ; These values are bytes
0027+  0000             T1              equ SRM+1
0028+  0000             T2              equ SRM+2
0029+  0000             T3              equ SRM+3
0030+  0000             GT0             equ SRM+4
0031+  0000             GT1             equ SRM+5
0032+  0000             ; Hex editor
0033+  0000             w_he_address    equ SRM+6       ;word
0034+  0000             b_he_addset     equ SRM+8       ;byte
0035+  0000             b_he_undovalue  equ SRM+9       ;byte
0036+  0000             w_he_undoaddr   equ SRM+10      ;word
0037+  0000             b_he_undoset    equ SRM+12      ;byte
0038+  0000             b_he_nibble     equ SRM+13      ;byte
0039+  0000             b_he_output     equ SRM+14      ;byte
0040+  0000             b_he_input      equ SRM+15      ;byte
0041+  0000             w_he_jumpaddr   equ SRM+16      ;word
0042+  0000             b_he_calljump   equ SRM+18      ;byte
0043+  0000             w_he_calladdr   equ SRM+19      ;word
0044+  0000             ; key-routines
0045+  0000             key_pressed     equ SRM+30      ;byte
0046+  0000             key_timer       equ SRM+31      ;byte
0047+  0000             key_delay       equ SRM+32      ;byte
0048+  0000             key_press       equ SRM+33      ;byte
0049+  0000             key_repeatdelay equ SRM+34      ;word
0050+  0000             key_repeatrate  equ SRM+36      ;word
0051+  0000             key_rd          equ SRM+38      ;word
0052+  0000             key_rr          equ SRM+40      ;word
0053+  0000             key_rset        equ SRM+42      ;byte
0054+  0000             ; Default repeat delay and rate for keyboard
0055+  0000             RepeatDelay     equ SRM+50      ;word
0056+  0000             RepeatRate      equ SRM+52      ;word
0057+  0000             RepeatSet       equ SRM+54      ;byte
0058+  0000             ; Log id's and addresses
0059+  0000             logs_curid      equ SRM+60      ;byte
0060+  0000             logs_status     equ SRM+61      ;byte
0061+  0000             logs_cur        equ SRM+62      ;word
0062+  0000             logs_ids        equ SRM+64      ;9words=18bytes
0063+  0000             ;
0064+  0000             SystemLogId     equ SRM+127     ;byte
0065+  0000             ; Used by network
0066+  0000             network         equ SRM+128     ;reserves 256bytes
0067+  0000             ; Uptime counter               
0068+  0000             uptime          equ SRM+384     ;6bytes
0069+  0000             ; State of LEDs
0070+  0000             LEDs_state      equ SRM+390
0071+  0000             ; For logs
0072+  0000             logs            equ SRM+640     ;reserves 4KB
0073+  0000             
0074+  0000             ;**************************************************************
0075+  0000             ; LEDs, 7segments and keyboard io-addresses
0076+  0000             SSeg1           equ $01
0077+  0000             SSeg2           equ $02
0078+  0000             SSeg3           equ $03
0079+  0000             SSeg4           equ $04
0080+  0000             KeyS            equ $05
0081+  0000             KeyR            equ $06
0082+  0000             LEDs            equ $07
0083+  0000             ; 8255 PIO -chip registers
0084+  0000             ;  LCD-display
0085+  0000             PortA           equ $20
0086+  0000             PortB           equ $21
0087+  0000             PortC           equ $22
0088+  0000             PIOCtrl         equ $23
0089+  0000             LCDd            equ PortB
0090+  0000             LCDi            equ PortC
0091+  0000             ; Timer
0092+  0000             Counter0        equ $a0
0093+  0000             Counter1        equ $a1
0094+  0000             Counter2        equ $a2
0095+  0000             CounterC        equ $a3
0096+  0000             ; Other IOs
0097+  0000             ethcom          equ $c0
0098+  0000             flashcom        equ $c1
0099+  0000             
0100+  0000             
0101+  0000             ; Keyboard
0102+  0000             ; These values are returned by key-routines
0103+  0000             key0    equ $00
0104+  0000             key1    equ $01
0105+  0000             key2    equ $02
0106+  0000             key3    equ $03
0107+  0000             
0108+  0000             key4    equ $04
0109+  0000             key5    equ $05
0110+  0000             key6    equ $06
0111+  0000             key7    equ $07
0112+  0000             
0113+  0000             key8    equ $08
0114+  0000             key9    equ $09
0115+  0000             keya    equ $0a
0116+  0000             keyb    equ $0b
0117+  0000             
0118+  0000             keyc    equ $0c
0119+  0000             keyd    equ $0d
0120+  0000             keye    equ $0e
0121+  0000             keyf    equ $0f
0122+  0000             
0123+  0000             CK0     equ $10
0124+  0000             CK1     equ $11
0125+  0000             CK2     equ $12
0126+  0000             CK3     equ $13
0127+  0000             
0128+  0000             CK4     equ $14
0129+  0000             CK5     equ $15
0130+  0000             Shift   equ $16
0131+  0000             Enter   equ $17
0132+  0000             
0133+  0000             none    equ $ff
0134+  0000             
0135+  0000             ; defines
0136+  0000             #define Line1 $00
0137+  0000             #define Line2 $40
0138+  0000             #define EOL $17                 ; End Of Line, used with strings
0139+  0000             #define EOLOG $18               ; End Of LOG
0140+  0000             #define NOEOL $19
0141+  0000             #define LOGSP $ff
0142+  0000             #define log_adding $01          ; This flag is set in log_status when there is adding in progress
0143+  0000             #define MAX_LOGS 8
0144+  0000             #define LOG_MEMORY_SIZE 4096
0145+  0000             
0146+  0000             ; Next delay-values are relative to speed of CPU
0147+  0000~            #ifdef CPU_AT_2MHZ
0148+  0000~            _RepeatDelay    equ $0aff       ; default value
0149+  0000~            _RepeatRate     equ $00ff       ; default value
0150+  0000~            FastKeyDelay    equ $40
0151+  0000~            NormalKeyDelay  equ $a0
0152+  0000             #endif
0153+  0000             #ifdef CPU_AT_4MHZ
0154+  0000             _RepeatDelay    equ $0fff       ; default value
0155+  0000             _RepeatRate     equ $01ff       ; default value
0156+  0000             FastKeyDelay    equ $80
0157+  0000             NormalKeyDelay  equ $f0
0158+  0000             #endif
0159+  0000~            #ifdef CPU_AT_8MHZ
0160+  0000~            _RepeatDelay    equ $1fff       ; default value
0161+  0000~            _RepeatRate     equ $02ff       ; default value
0162+  0000~            FastKeyDelay    equ $c0
0163+  0000~            NormalKeyDelay  equ $f0
0164+  0000             #endif
0165+  0000             
0166+  0000             LCD_delay       equ $0002       ; Delay after actions when using
0167+  0000                                             ; LCD for 2ms
0168+  0000             
0169+  0000             ErrorMesg       equ 3000        ; Show error for 3secs
0170+  0000             NormalMesg      equ 1000        ; Show normal messages for 1,5secs
0171+  0000             FastMesg        equ 1000        ; Show fast messages for 1sec
0172+  0000             LongMesg        equ 4000        ; Show long message for 4secs
0173+  0000             LLongMesg       equ 7000        ; Show really long message for 7secs
0174+  0000             
0175+  0000             ; *****************
0176+  0000             ; Routine addresses
0177+  0000~            #ifndef OS_FILE
0178+  0000~            DelayBC         equ $0040
0179+  0000~            DelayDE         equ $0049
0180+  0000~            DelayHL         equ $0052
0181+  0000~            HALT            equ $0068
0182+  0000~            n_as_7seg       equ $009b
0183+  0000~            n_to_7seg       equ $00ae
0184+  0000~            b_to_7seg       equ $00c8
0185+  0000~            bute2lcd        equ $00fb
0186+  0000~            set_lcd         equ $0122
0187+  0000~            char2lcd        equ $013c
0188+  0000~            reset_lcd       equ $0158
0189+  0000~            clear_lcd       equ $017b
0190+  0000~            str2lcd         equ $0183
0191+  0000~            strn2lcd        equ $0194
0192+  0000~            strd2lcd        equ $01b0
0193+  0000~            setDDRAMa       equ $01c4
0194+  0000~            key_scan        equ $01cd
0195+  0000~            key_testshift   equ $0267
0196+  0000~            key_getkey      equ $0274
0197+  0000~            key_getbyte     equ $0307
0198+  0000~            key_getaddress  equ $03de
0199+  0000~            key_getword     equ $03f4
0200+  0000~            Delayms         equ $0551
0201+  0000~            CreateLog       equ $056e
0202+  0000~            AddLog          equ $05ba
0203+  0000~            ViewLog         equ $063d
0204+  0000             #endif
0205+  0000             
0206+  0000             ; ************
0207+  0000             ; "Next level"
0208+  0000             ; (Network and such)
0209+  0000             
0210+  0000             ; These macros makes easier to use the NIC
0211+  0000             ; by adding the base address of NIC to the
0212+  0000             ; relative NIC register address
0213+  0000             #define einb(address) ld a,(ethbase)\ add a,address\ ld c,a\ in a,(c)
0214+  0000             #define eoutb(address) ex af,af'\ ld a,(ethbase)\ add a,address\ ld c,a\ ex af,af'\ out (c),a
0215+  0000             #define eoutb_ ex af,af'\ ld a,(ethbase)\ add a,c\ ld c,a\ ex af,af'\ out (c),a
0216+  0000             
0217+  0000             ; network variables
0218+  0000             ETHM            equ SRM+128     ;256bytes (must be equ to network
0219+  0000                                             ;in osXXX.asm)
0220+  0000             ;
0221+  0000             ethbase         equ ETHM+0      ;byte
0222+  0000             ethdetect       equ ETHM+1      ;byte
0223+  0000             ethtmp          equ ETHM+2      ;byte
0224+  0000             ethsaprom       equ ETHM+3      ;32 bytes
0225+  0000             ethhwaddr       equ ETHM+35      ;6 bytes
0226+  0000             ethpiomode      equ ETHM+41     ;byte
0227+  0000             ethaddr         equ ETHM+42     ;byte
0228+  0000             ethirqreg       equ ETHM+43     ;byte
0229+  0000             ethwrdlen       equ ETHM+44     ;byte
0230+  0000             ethT0           equ ETHM+45     ;byte
0231+  0000             ethT1           equ ETHM+46     ;byte
0232+  0000             ethT2           equ ETHM+47     ;byte
0233+  0000             ethT3           equ ETHM+48     ;byte
0234+  0000             etxStartPage    equ ETHM+49     ;byte
0235+  0000             erxStartPage    equ ETHM+50     ;byte
0236+  0000             ethStopPage     equ ETHM+51     ;byte
0237+  0000             ethCurrentPage  equ ETHM+52     ;byte
0238+  0000             NetLogId        equ ETHM+53     ;byte
0239+  0000             ; Jump-table
0240+  0000             ejProbe         equ ETHM+60     ;word
0241+  0000             ejReset         equ ETHM+62     ;word
0242+  0000             ejOpen          equ ETHM+64     ;word
0243+  0000             ejEnable        equ ETHM+66     ;word
0244+  0000             ejDisable       equ ETHM+68     ;word
0245+  0000             ejInterrupt     equ ETHM+70     ;word
0246+  0000             ejSend          equ ETHM+72     ;word
0247+  0000             ; Information for sending and receiving packets
0248+  0000             ethDataAddr     equ ETHM+80     ;word
0249+  0000             ethDataLen      equ ETHM+82     ;word
0250+  0000             ethDataPage     equ ETHM+84     ;word
0251+  0000             ; Error counters
0252+  0000             ethRxFrameErrs  equ ETHM+100    ;word frame errors
0253+  0000             ethRxCrcErrs    equ ETHM+102    ;word CRC errors
0254+  0000             ethRxMissedErrs equ ETHM+104    ;word missed-errors
0255+  0000             ethTxCarrErrs   equ ETHM+106    ;word tx carrier errors
0256+  0000             ethTxHBErrs     equ ETHM+108    ;word tx heartbeat errors
0257+  0000             ethTxWindow     equ ETHM+110    ;word tx window errors
0258+  0000             ethRxOverErrs   equ ETHM+112    ;word rx overrun errors
0259+  0000             ethRxErrs       equ ETHM+114    ;word rx errors
0260+  0000             ethRxFifoErrs   equ ETHM+116    ;word rx fifo errors
0261+  0000             ethRxLenErrs    equ ETHM+118    ;word rx lenght errors
0262+  0000             ethRxPackets    equ ETHM+120    ;dword rx packets counter
0263+  0000             ethTxPackets    equ ETHM+124    ;dword tx packets counter
0264+  0000             ethRxBytes      equ ETHM+128    ;dword rx bytes
0265+  0000             ethTxBytes      equ ETHM+132    ;dword tx bytes
0266+  0000             ethRxDropped    equ ETHM+136    ;word rx packets dropped
0267+  0000             ; Structures (ex. headers) and such
0268+  0000             ; receive packet header
0269+  0000             #define pkthdr_size 4
0270+  0000             pkthdr          equ ETHM+150    ;2bytes+1word=4bytes
0271+  0000             pkthdr_stat     equ ETHM+150    ;byte
0272+  0000             pkthdr_next     equ ETHM+151    ;byte
0273+  0000             pkthdr_count    equ ETHM+152    ;word
0274+  0000             ; Ethernet packet header
0275+  0000             ethpkt          equ ETHM+160
0276+  0000             ; DLC header
0277+  0000             ep_target       equ ETHM+160    ;6 bytes
0278+  0000             ep_source       equ ETHM+166    ;6 bytes
0279+  0000             ep_type         equ ETHM+172    ;word
0280+  0000             ; ARP specific header
0281+  0000             #define ethpkt_ARPsize 14+28
0282+  0000             ep_hwtype       equ ETHM+174    ;word
0283+  0000             ep_protocol     equ ETHM+176    ;word
0284+  0000             ep_hwlen        equ ETHM+178    ;byte
0285+  0000             ep_protolen     equ ETHM+179    ;byte
0286+  0000             ep_opcode       equ ETHM+180    ;word
0287+  0000             ep_senderhw     equ ETHM+182    ;6 bytes
0288+  0000             ep_senderpr     equ ETHM+188    ;4 bytes, when using IP-protocol
0289+  0000             ep_targethw     equ ETHM+192    ;6 bytes
0290+  0000             ep_targetpr     equ ETHM+198    ;4 bytes, when using IP-protocol
0291+  0000             
0292+  0000             ; Temporary values
0293+  0000             NT0             equ ETHM+252    ;byte
0294+  0000             NT1             equ ETHM+253    ;byte
0295+  0000             NT2             equ ETHM+254    ;byte
0296+  0000             NT3             equ ETHM+255    ;byte
0020   0000             
0021   0000             ;**************************************************************
0022   0000             ; Code origin
0023   0000             .org $0000
0024   0000             
0025   0000             ;**************************************************************
0026   0000             ; RST $00
0027   0000             ; Set the counters third counters out to inactive state
0028   0000             ; becose nmi interrupt is not a good thing in here
0029   0000 3E 90        ld a,$90
0030   0002 D3 A3        out (CounterC),a
0031   0004 C3 50 07     jp RESET
0032   0007             ; RST $08
0033   0007             ; This RST jumps to HALT-routine
0034   0008             .org $0008
0035   0008 C3 6B 00     jp HALT
0036   000B             ; RST $10
0037   0010             .org $0010
0038   0010 76           halt
0039   0011 ED 4D        reti
0040   0013             ; RST $18
0041   0018             .org $0018
0042   0018 76           halt
0043   0019 ED 4D        reti
0044   001B             ; RST $20
0045   0020             .org $0020
0046   0020 76           halt
0047   0021 ED 4D        reti
0048   0023             ; RST $28
0049   0028             .org $0028
0050   0028 76           halt
0051   0029 ED 4D        reti
0052   002B             ; RST $30
0053   0030             .org $0030
0054   0030 76           halt
0055   0031 ED 4D        reti
0056   0033             ; RST $38 or /INT-signal in interrupt mode 1
0057   0033             ; INT is used by ethernet controller
0058   0038             .org $0038
0059   0038 F3           di
0060   0039             ; Handle the ethernet NIC's interrupt
0061   0039 CD 79 14     call ethInterrupt
0062   003C FB           ei
0063   003D ED 4D        reti
0064   003F             ;**************************************************************
0065   003F             ; Empty space for the NMI-interrupt point
0066   003F             ; Here are three default delay routines
0067   003F             ; and little string ;)
0068   003F             ; $40
0069   003F             ; $1000 loops in these delays takes about 16.428ms when
0070   003F             ; CPU runs @4MHz
0071   003F             ; @2MHz it takes 32.856ms
0072   003F             ; @8MHz it takes 8.214ms
0073   0040             .org $0040
0074   0040             DelayBC:
0075   0040 04           inc b
0076   0041 0C           inc c
0077   0042             DelayBC0:
0078   0042 0D           dec c          ; 1byte    4 clocks / 1us / 2us
0079   0043 20 FD        jr nz,DelayBC0 ; 2bytes   12/7 clocks / 3us/1.75us / 6us/3.5us
0080   0045 05           dec b          ; 1byte    4 clocks / 1us / 2us
0081   0046 20 FA        jr nz,DelayBC0 ; 2bytes   12 clocks / 3us / 6us
0082   0048 C9           ret            ; 1byte
0083   0049             DelayDE:
0084   0049 14           inc d
0085   004A 1C           inc e
0086   004B             DelayDE0:
0087   004B 1D           dec e          ; 1byte
0088   004C 20 FD        jr nz,DelayDE0 ; 2bytes
0089   004E 15           dec d          ; 1byte
0090   004F 20 FA        jr nz,DelayDE0 ; 2bytes
0091   0051 C9           ret            ; 1byte
0092   0052             DelayHL:
0093   0052 24           inc h
0094   0053 2C           inc l
0095   0054             DelayHL0:
0096   0054 2D           dec l          ; 1byte
0097   0055 20 FD        jr nz,DelayHL0 ; 2bytes
0098   0057 25           dec h          ; 1byte
0099   0058 20 FA        jr nz,DelayHL0 ; 2bytes
0100   005A C9           ret            ; 1byte
0101   005B             ;
0102   005B             
0103   005B 627920447567.db "by Duge"
0103   0061 65
0104   0062             
0105   0062             ;**************************************************************
0106   0062             ; This is the point where the processor goes when NMI-interrupt
0107   0062             ; is signalled
0108   0062             ; 0066H or $66
0109   0066             .org $0066
0110   0066 C3 1C 0F     jp HandleNMI
0111   0069 ED 45        retn
0112   006B             
0113   006B             ;**************************************************************
0114   006B             ; Here starts the 'REAL' code
0115   006B             ; First routines, then the main code
0116   006B             ; and then misc data like strings and such
0117   006B             ;**************************************************************
0118   006B             ; Routines
0119   006B             ;
0120   006B             ; Three delay routines have already been written in earlier
0121   006B             ; addresses
0122   006B             
0123   006B             ; *** HALT
0124   006B             ; Writes 'HALT' into 7segments, "CPU halted." into
0125   006B             ; system log and then halt's the cpu
0126   006B             ; /INT and /NMI signals can wake up the CPU
0127   006B             ; from halt-mode
0128   006B             HALT:
0129   006B F5           push af
0130   006C E5           push hl
0131   006D 3E A4        ld a,%10100100
0132   006F D3 01        out (SSeg1),a
0133   0071 3E A0        ld a,%10100000
0134   0073 D3 02        out (SSeg2),a
0135   0075 3E CD        ld a,%11001101
0136   0077 D3 03        out (SSeg3),a
0137   0079 3E E9        ld a,%11101001
0138   007B D3 04        out (SSeg4),a
0139   007D 3A 7F EA     ld a,(SystemLogId)
0140   0080 21 26 14     ld hl,s_SysHalt
0141   0083 CD BD 05     call AddLog
0142   0086 3E FF        ld a,$ff
0143   0088 76           halt
0144   0089 D3 01        out (SSeg1),a
0145   008B D3 02        out (SSeg2),a
0146   008D D3 03        out (SSeg3),a
0147   008F D3 04        out (SSeg4),a
0148   0091 3A 7F EA     ld a,(SystemLogId)
0149   0094 21 33 14     ld hl,s_SysHaltWake
0150   0097 CD BD 05     call AddLog
0151   009A E1           pop hl
0152   009B F1           pop af
0153   009C ED 4D        reti
0154   009E             ; end of HALT
0155   009E             
0156   009E             ; *** n_as_7seg
0157   009E             ; This routine converts the hex value of lower 4bits of reg a
0158   009E             ; as 7segment value and returns the result in reg a
0159   009E             ; The 7bit of reg a is leaved unchanged for use of dot
0160   009E             n_as_7seg:
0161   009E E5           push hl
0162   009F C5           push bc
0163   00A0             
0164   00A0 21 52 14     ld hl,hexto7segment
0165   00A3 47           ld b,a
0166   00A4 E6 0F        and $0f
0167   00A6 4F           ld c,a
0168   00A7 78           ld a,b
0169   00A8 06 00        ld b,0
0170   00AA 09           add hl,bc
0171   00AB E6 80        and $80
0172   00AD A6           and (hl)
0173   00AE             
0174   00AE C1           pop bc
0175   00AF E1           pop hl
0176   00B0 C9           ret
0177   00B1             ; end of n_as_7seg
0178   00B1             
0179   00B1             ; *** n_to_7seg
0180   00B1             ; This routine outputs the hex value of lower 4bits of reg a
0181   00B1             ; into 7segment display which io-address is specified in
0182   00B1             ; reg c
0183   00B1             ; Carry flag defines if the dot is on or off
0184   00B1             ; reg a and flags are changed
0185   00B1             n_to_7seg:
0186   00B1 E5           push hl
0187   00B2 C5           push bc
0188   00B3             
0189   00B3 06 FF        ld b,$ff
0190   00B5 30 02        jr nc,nto7_nocarry
0191   00B7 CB B8        res 7,b
0192   00B9             nto7_nocarry:
0193   00B9 21 52 14     ld hl,hexto7segment
0194   00BC C5           push bc
0195   00BD 06 00        ld b,0
0196   00BF E6 0F        and $0f
0197   00C1 4F           ld c,a
0198   00C2 09           add hl,bc
0199   00C3 C1           pop bc
0200   00C4 78           ld a,b
0201   00C5 A6           and (hl)
0202   00C6 ED 79        out (c),a
0203   00C8             
0204   00C8 C1           pop bc
0205   00C9 E1           pop hl
0206   00CA C9           ret
0207   00CB             ; end of n_to_7seg
0208   00CB             
0209   00CB             ; *** b_to_7seg
0210   00CB             ; This routine outputs the hex value of reg a into
0211   00CB             ; two 7segment display
0212   00CB             ; First display io-address is specified in reg c
0213   00CB             ; The most valuable nibble of reg a will be outed
0214   00CB             ; into the address of c, then c's value is increased
0215   00CB             ; and the lower nibble is outed into that address
0216   00CB             ; Carry flag defines if the dot is on or off
0217   00CB             ; flags are changed
0218   00CB             b_to_7seg:
0219   00CB F5           push af
0220   00CC E5           push hl
0221   00CD C5           push bc
0222   00CE             
0223   00CE 06 FF        ld b,$ff
0224   00D0 30 02        jr nc,bto7_nocarry
0225   00D2 CB B8        res 7,b
0226   00D4             bto7_nocarry:
0227   00D4             ; Upper 4bits of reg a
0228   00D4 21 52 14     ld hl,hexto7segment
0229   00D7 F5           push af
0230   00D8 C5           push bc
0231   00D9 06 00        ld b,0
0232   00DB CB 3F        srl a
0233   00DD CB 3F        srl a
0234   00DF CB 3F        srl a
0235   00E1 CB 3F        srl a
0236   00E3 4F           ld c,a
0237   00E4 09           add hl,bc
0238   00E5 C1           pop bc
0239   00E6 7E           ld a,(hl)
0240   00E7 ED 79        out (c),a
0241   00E9 0C           inc c
0242   00EA F1           pop af
0243   00EB             ; Lower 4bits of reg a
0244   00EB C5           push bc
0245   00EC 21 52 14     ld hl,hexto7segment
0246   00EF 06 00        ld b,0
0247   00F1 E6 0F        and $0f
0248   00F3 4F           ld c,a
0249   00F4 09           add hl,bc
0250   00F5 C1           pop bc
0251   00F6 78           ld a,b
0252   00F7 A6           and (hl)
0253   00F8 ED 79        out (c),a
0254   00FA             
0255   00FA C1           pop bc
0256   00FB E1           pop hl
0257   00FC F1           pop af
0258   00FD C9           ret
0259   00FE             ; end of b_to_7seg
0260   00FE             
0261   00FE             ; *** byte2lcd
0262   00FE             ; This routine outputs the hex value of reg a into
0263   00FE             ; LCD-display
0264   00FE             byte2lcd:
0265   00FE E5           push hl
0266   00FF C5           push bc
0267   0100             ; Upper 4bits of reg a
0268   0100 21 42 14     ld hl,hextolcd
0269   0103 F5           push af
0270   0104 06 00        ld b,0
0271   0106 CB 3F        srl a
0272   0108 CB 3F        srl a
0273   010A CB 3F        srl a
0274   010C CB 3F        srl a
0275   010E 4F           ld c,a
0276   010F 09           add hl,bc
0277   0110 46           ld b,(hl)
0278   0111 CD 3F 01     call char2lcd
0279   0114 F1           pop af
0280   0115             ; Lower 4bits of reg a
0281   0115 21 42 14     ld hl,hextolcd
0282   0118 06 00        ld b,0
0283   011A E6 0F        and $0f
0284   011C 4F           ld c,a
0285   011D 09           add hl,bc
0286   011E 46           ld b,(hl)
0287   011F CD 3F 01     call char2lcd
0288   0122             ;
0289   0122 C1           pop bc
0290   0123 E1           pop hl
0291   0124 C9           ret
0292   0125             ; end of byte2lcd
0293   0125             
0294   0125             ; *** set_lcd
0295   0125             ; Sets value to LCDs instruction register
0296   0125             set_lcd:
0297   0125 F5           push af
0298   0126 D5           push de
0299   0127 3E 01        ld a,%00000001
0300   0129 D3 22        out (LCDi),a
0301   012B 78           ld a,b
0302   012C D3 21        out (LCDd),a
0303   012E 3E 00        ld a,%00000000
0304   0130 D3 22        out (LCDi),a
0305   0132 11 02 00     ld de,LCD_delay
0306   0135 CD 54 05     call Delayms
0307   0138 3E 01        ld a,%00000001
0308   013A D3 22        out (LCDi),a
0309   013C D1           pop de
0310   013D F1           pop af
0311   013E C9           ret
0312   013F             ; end of set_lcd
0313   013F             
0314   013F             ; *** char2lcd
0315   013F             ; Outs character to LCD-display
0316   013F             char2lcd:
0317   013F F5           push af
0318   0140 C5           push bc
0319   0141 D5           push de
0320   0142 3E 05        ld a,%00000101
0321   0144 D3 22        out (LCDi),a
0322   0146 78           ld a,b
0323   0147 D3 21        out (LCDd),a
0324   0149 3E 04        ld a,%00000100
0325   014B D3 22        out (LCDi),a
0326   014D 11 02 00     ld de,LCD_delay
0327   0150 CD 54 05     call Delayms
0328   0153 3E 01        ld a,%00000001
0329   0155 D3 22        out (LCDi),a
0330   0157 D1           pop de
0331   0158 C1           pop bc
0332   0159 F1           pop af
0333   015A C9           ret
0334   015B             ; end of char2lcd
0335   015B             
0336   015B             ; *** reset_lcd
0337   015B             ; Resets the LCD-diplay
0338   015B             ; Clears the LCD, returns cursor to home, sets cursor move
0339   015B             ; direction to incremental, sets display shifting off,
0340   015B             ; sets dosplay on, cursor on, cursor blinking off, sets
0341   015B             ; cursor-move mode on, shift direction left, interface
0342   015B             ; data lenght to 8bits, number of display lines to 2lines
0343   015B             ; and character font to 5x7.
0344   015B             ; none of the regs or flags are changed
0345   015B             reset_lcd:
0346   015B F5           push af
0347   015C C5           push bc
0348   015D             
0349   015D 06 01        ld b,%00000001
0350   015F CD 25 01     call set_lcd
0351   0162 06 06        ld b,%00000110
0352   0164 CD 25 01     call set_lcd
0353   0167 06 0C        ld b,%00001100
0354   0169 CD 25 01     call set_lcd
0355   016C 06 10        ld b,%00010000
0356   016E CD 25 01     call set_lcd
0357   0171 06 38        ld b,%00111000
0358   0173 CD 25 01     call set_lcd
0359   0176 06 80        ld b,%10000000
0360   0178 CD 25 01     call set_lcd
0361   017B             
0362   017B C1           pop bc
0363   017C F1           pop af
0364   017D C9           ret
0365   017E             ; end of reset_lcd
0366   017E             
0367   017E             ; *** clear_lcd
0368   017E             ; Clears the LCD
0369   017E             clear_lcd:
0370   017E C5           push bc
0371   017F 06 01        ld b,%00000001
0372   0181 CD 25 01     call set_lcd
0373   0184 C1           pop bc
0374   0185 C9           ret
0375   0186             ; end of clear_lcd
0376   0186             
0377   0186             ; *** str2lcd
0378   0186             ; Outputs a string into LCD-display
0379   0186             ; The string start address should be stored into hl and
0380   0186             ; end of the string should be marked with EOL
0381   0186             ; The string is just added to displays previous
0382   0186             ; contents
0383   0186             ; hl and flags are changed
0384   0186             str2lcd:
0385   0186 F5           push af
0386   0187 C5           push bc
0387   0188 3E 17        ld a,EOL
0388   018A             s2l_loop:
0389   018A 46           ld b,(hl)
0390   018B B8           cp b
0391   018C 28 06        jr z,s2l_end
0392   018E CD 3F 01     call char2lcd
0393   0191 23           inc hl
0394   0192 18 F6        jr s2l_loop
0395   0194             s2l_end:
0396   0194 C1           pop bc
0397   0195 F1           pop af
0398   0196 C9           ret
0399   0197             ; end of str2lcd
0400   0197             
0401   0197             ; *** strn2lcd
0402   0197             ; Outputs a string into LCD-display
0403   0197             ; The string start address should be stored into hl and
0404   0197             ; lenght of the string should be in reg c
0405   0197             ; This routine also exits if it find EOL- or EOLOG-char and
0406   0197             ; returns that char in reg c, otherwise it returns NOEOL
0407   0197             ; The string is just added to displays previous
0408   0197             ; contents
0409   0197             ; none is changed
0410   0197             strn2lcd:
0411   0197 F5           push af
0412   0198 C5           push bc
0413   0199 0C           inc c
0414   019A             sn2l_loop:
0415   019A 3E 19        ld a,NOEOL
0416   019C 0D           dec c
0417   019D 28 10        jr z,sn2l_end
0418   019F 7E           ld a,(hl)
0419   01A0 FE 17        cp EOL
0420   01A2 28 0B        jr z,sn2l_end
0421   01A4 FE 18        cp EOLOG
0422   01A6 28 07        jr z,sn2l_end
0423   01A8 47           ld b,a
0424   01A9 CD 3F 01     call char2lcd
0425   01AC 23           inc hl
0426   01AD 18 EB        jr sn2l_loop
0427   01AF             sn2l_end:
0428   01AF C1           pop bc
0429   01B0 4F           ld c,a
0430   01B1 F1           pop af
0431   01B2 C9           ret
0432   01B3             ; end of strn2lcd
0433   01B3             
0434   01B3             ; *** strd2lcd
0435   01B3             ; Outputs a string into LCD-display with delay
0436   01B3             ; The string start address should be stored into hl,
0437   01B3             ; end of the string should be marked with EOL,
0438   01B3             ; delay between characters in de as milliseconds
0439   01B3             ; The string is just added to displays previous
0440   01B3             ; contents
0441   01B3             ; hl and flags are changed
0442   01B3             strd2lcd:
0443   01B3 F5           push af
0444   01B4 C5           push bc
0445   01B5 3E 17        ld a,EOL
0446   01B7             sd2l_loop:
0447   01B7 46           ld b,(hl)
0448   01B8 B8           cp b
0449   01B9 28 09        jr z,sd2l_end
0450   01BB CD 3F 01     call char2lcd
0451   01BE 23           inc hl
0452   01BF CD 54 05     call Delayms
0453   01C2 18 F3        jr sd2l_loop
0454   01C4             sd2l_end:
0455   01C4 C1           pop bc
0456   01C5 F1           pop af
0457   01C6 C9           ret
0458   01C7             ; end of strd2lcd
0459   01C7              
0460   01C7             ; *** setDDRAMa
0461   01C7             ; Sets LCDs DDRAM address
0462   01C7             setDDRAMa:
0463   01C7 C5           push bc
0464   01C8 F6 80        or $80
0465   01CA 47           ld b,a
0466   01CB CD 25 01     call set_lcd
0467   01CE C1           pop bc
0468   01CF C9           ret
0469   01D0             ; end of setDDRAMa
0470   01D0             
0471   01D0             ; *** key_scan
0472   01D0             ; Tests all keys on keyboard and if finds a pressed key
0473   01D0             ; then aborts the loop and returns that key's value
0474   01D0             ; in reg a
0475   01D0             key_scan:
0476   01D0 3E FE        ld a,%11111110
0477   01D2 D3 05        out (KeyS),a
0478   01D4 DB 06        in a,(KeyR)
0479   01D6 CB 47        bit 0,a
0480   01D8 CA 51 05     jp z,key_Enter
0481   01DB CB 4F        bit 1,a
0482   01DD CA 4B 05     jp z,key_CK5
0483   01E0 CB 57        bit 2,a
0484   01E2 CA 45 05     jp z,key_CK3
0485   01E5 CB 5F        bit 3,a
0486   01E7 CA 3F 05     jp z,key_CK1
0487   01EA 3E FD        ld a,%11111101
0488   01EC D3 05        out (KeyS),a
0489   01EE DB 06        in a,(KeyR)
0490   01F0             ; bit 0,a
0491   01F0             ; jp z,key_Shift
0492   01F0 CB 4F        bit 1,a
0493   01F2 CA 48 05     jp z,key_CK4
0494   01F5 CB 57        bit 2,a
0495   01F7 CA 42 05     jp z,key_CK2
0496   01FA CB 5F        bit 3,a
0497   01FC CA 3C 05     jp z,key_CK0
0498   01FF 3E FB        ld a,%11111011
0499   0201 D3 05        out (KeyS),a
0500   0203 DB 06        in a,(KeyR)
0501   0205 CB 47        bit 0,a
0502   0207 CA 39 05     jp z,key_f
0503   020A CB 4F        bit 1,a
0504   020C CA 2D 05     jp z,key_b
0505   020F CB 57        bit 2,a
0506   0211 CA 21 05     jp z,key_7
0507   0214 CB 5F        bit 3,a
0508   0216 CA 15 05     jp z,key_3
0509   0219 3E F7        ld a,%11110111
0510   021B D3 05        out (KeyS),a
0511   021D DB 06        in a,(KeyR)
0512   021F CB 47        bit 0,a
0513   0221 CA 36 05     jp z,key_e
0514   0224 CB 4F        bit 1,a
0515   0226 CA 2A 05     jp z,key_a
0516   0229 CB 57        bit 2,a
0517   022B CA 1E 05     jp z,key_6
0518   022E CB 5F        bit 3,a  
0519   0230 CA 12 05     jp z,key_2
0520   0233 3E EF        ld a,%11101111
0521   0235 D3 05        out (KeyS),a
0522   0237 DB 06        in a,(KeyR)
0523   0239 CB 47        bit 0,a
0524   023B CA 33 05     jp z,key_d
0525   023E CB 4F        bit 1,a
0526   0240 CA 27 05     jp z,key_9
0527   0243 CB 57        bit 2,a
0528   0245 CA 1B 05     jp z,key_5
0529   0248 CB 5F        bit 3,a
0530   024A CA 0F 05     jp z,key_1
0531   024D 3E DF        ld a,%11011111
0532   024F D3 05        out (KeyS),a
0533   0251 DB 06        in a,(KeyR)
0534   0253 CB 47        bit 0,a
0535   0255 CA 30 05     jp z,key_c
0536   0258 CB 4F        bit 1,a
0537   025A CA 24 05     jp z,key_8
0538   025D CB 57        bit 2,a
0539   025F CA 18 05     jp z,key_4
0540   0262 CB 5F        bit 3,a  
0541   0264 CA 0C 05     jp z,key_0
0542   0267             ; no key was pressed, load $ff into reg a
0543   0267             ; for mark of that
0544   0267 3E FF        ld a,$ff
0545   0269 C9           ret
0546   026A             ; end of key_scan
0547   026A             
0548   026A             ; *** key_testshift
0549   026A             ; Test Shift's current status
0550   026A             ; Result is returned in Z-flag
0551   026A             key_testshift:
0552   026A C5           push bc
0553   026B 47           ld b,a
0554   026C 3E FD        ld a,%11111101
0555   026E D3 05        out (KeyS),a
0556   0270 DB 06        in a,(KeyR)
0557   0272 CB 47        bit 0,a
0558   0274 78           ld a,b
0559   0275 C1           pop bc
0560   0276 C9           ret
0561   0277             ; end of key_testshift
0562   0277             
0563   0277             ; *** key_getkey
0564   0277             key_getkey:
0565   0277 E5           push hl
0566   0278 3A 20 EA     ld a,(key_delay)
0567   027B 32 1F EA     ld (key_timer),a
0568   027E 3A 2A EA     ld a,(key_rset)
0569   0281 FE FF        cp $ff
0570   0283 20 11        jr nz,gk_loop
0571   0285 3E 00        ld a,$00
0572   0287 32 2A EA     ld (key_rset),a
0573   028A 2A 22 EA     ld hl,(key_repeatdelay)
0574   028D 22 26 EA     ld (key_rd),hl
0575   0290 2A 24 EA     ld hl,(key_repeatrate)
0576   0293 22 28 EA     ld (key_rr),hl
0577   0296             gk_loop:
0578   0296 CD D0 01     call key_scan
0579   0299 FE FF        cp none
0580   029B 20 29        jr nz,gk_key        ; Some key was pressed
0581   029D 3A 1E EA     ld a,(key_pressed)
0582   02A0 FE FF        cp none
0583   02A2 28 F2        jr z,gk_loop
0584   02A4 2A 22 EA     ld hl,(key_repeatdelay)
0585   02A7 22 26 EA     ld (key_rd),hl
0586   02AA 2A 24 EA     ld hl,(key_repeatrate)
0587   02AD 22 28 EA     ld (key_rr),hl
0588   02B0 3A 1F EA     ld a,(key_timer)
0589   02B3 3D           dec a
0590   02B4 32 1F EA     ld (key_timer),a
0591   02B7 20 DD        jr nz,gk_loop
0592   02B9 3E FF        ld a,none
0593   02BB 32 1E EA     ld (key_pressed),a
0594   02BE 3A 20 EA     ld a,(key_delay)
0595   02C1 32 1F EA     ld (key_timer),a
0596   02C4 18 D0        jr gk_loop
0597   02C6             ;
0598   02C6             gk_key:
0599   02C6 32 21 EA     ld (key_press),a    ;
0600   02C9 3A 1E EA     ld a,(key_pressed)  ; Test if this key was pressed earlier
0601   02CC 21 21 EA     ld hl,key_press     ;
0602   02CF BE           cp (hl)             ;
0603   02D0 20 30        jr nz,gk_nkey
0604   02D2 2A 22 EA     ld hl,(key_repeatdelay)
0605   02D5 3E 00        ld a,0
0606   02D7 BC           cp h
0607   02D8 20 06        jr nz,gk_delay
0608   02DA BD           cp l
0609   02DB 20 03        jr nz,gk_delay
0610   02DD C3 96 02     jp gk_loop
0611   02E0             gk_delay:
0612   02E0 2A 26 EA     ld hl,(key_rd)
0613   02E3 BC           cp h
0614   02E4 20 0E        jr nz,gk_dntr
0615   02E6 BD           cp l
0616   02E7 20 0B        jr nz,gk_dntr
0617   02E9 2A 28 EA     ld hl,(key_rr)
0618   02EC BC           cp h
0619   02ED 20 0C        jr nz,gk_rntr
0620   02EF BD           cp l
0621   02F0 20 09        jr nz,gk_rntr
0622   02F2 18 0E        jr gk_nkey
0623   02F4             gk_dntr:
0624   02F4 2B           dec hl
0625   02F5 22 26 EA     ld (key_rd),hl
0626   02F8 C3 96 02     jp gk_loop
0627   02FB             gk_rntr:
0628   02FB 2B           dec hl
0629   02FC 22 28 EA     ld (key_rr),hl
0630   02FF C3 96 02     jp gk_loop
0631   0302             ;
0632   0302             gk_nkey:
0633   0302 3A 21 EA     ld a,(key_press)
0634   0305 32 1E EA     ld (key_pressed),a
0635   0308 E1           pop hl
0636   0309 C9           ret
0637   030A             ; end of key_getkey
0638   030A             
0639   030A             ; *** key_getbyte
0640   030A             ; Uses the LCD to get word-value from the user
0641   030A             ; Default value should be stored into b, value
0642   030A             ; given is also returned in b
0643   030A             ; In a is the key which was pressed to get here
0644   030A             key_getbyte:
0645   030A F5           push af
0646   030B E5           push hl
0647   030C CD 7E 01     call clear_lcd
0648   030F 3E 00        ld a,Line1
0649   0311 CD C7 01     call setDDRAMa
0650   0314 21 35 13     ld hl,s_inputbyte
0651   0317 CD 86 01     call str2lcd
0652   031A E1           pop hl
0653   031B F1           pop af
0654   031C             ; If there is need for own start string, then
0655   031C             ; jump here after setting that
0656   031C             key_getbvalue:
0657   031C D5           push de
0658   031D E5           push hl
0659   031E 50           ld d,b
0660   031F 58           ld e,b
0661   0320 32 1E EA     ld (key_pressed),a
0662   0323 3E 40        ld a,Line2
0663   0325 CD C7 01     call setDDRAMa
0664   0328 06 3E        ld b,'>'
0665   032A CD 3F 01     call char2lcd
0666   032D 7A           ld a,d
0667   032E CD FE 00     call byte2lcd
0668   0331 3E 41        ld a,Line2+1
0669   0333 CD C7 01     call setDDRAMa
0670   0336 06 01        ld b,1
0671   0338 3E 80        ld a,FastKeyDelay
0672   033A 32 20 EA     ld (key_delay),a
0673   033D             ;
0674   033D             gb_loop:
0675   033D CD 77 02     call key_getkey
0676   0340             ;
0677   0340 FE 10        cp $10
0678   0342 DA 8B 03     jp c,gb_number
0679   0345 FE 17        cp Enter
0680   0347 20 06        jr nz,gb_nEnter
0681   0349 42           ld b,d
0682   034A 3E 17        ld a,Enter
0683   034C C3 DE 03     jp gb_end
0684   034F             gb_nEnter:
0685   034F FE 15        cp CK5
0686   0351 C2 5A 03     jp nz,gb_nundo
0687   0354 53           ld d,e
0688   0355 3E 15        ld a,CK5
0689   0357 C3 DE 03     jp gb_end
0690   035A             gb_nundo:
0691   035A FE 10        cp CK0
0692   035C CA 67 03     jp z,gb_left
0693   035F FE 11        cp CK1
0694   0361 CA 79 03     jp z,gb_right
0695   0364 C3 3D 03     jp gb_loop
0696   0367             ;
0697   0367             gb_left:
0698   0367 3E 01        ld a,1
0699   0369 B8           cp b
0700   036A CA 3D 03     jp z,gb_loop
0701   036D 04           inc b
0702   036E 3E 01        ld a,1
0703   0370 90           sub b
0704   0371 C6 41        add a,Line2+1
0705   0373 CD C7 01     call setDDRAMa
0706   0376 C3 3D 03     jp gb_loop
0707   0379             ;
0708   0379             gb_right:
0709   0379 3E 00        ld a,0
0710   037B B8           cp b
0711   037C CA 3D 03     jp z,gb_loop
0712   037F 05           dec b
0713   0380 3E 01        ld a,1
0714   0382 90           sub b
0715   0383 C6 41        add a,Line2+1
0716   0385 CD C7 01     call setDDRAMa
0717   0388 C3 3D 03     jp gb_loop
0718   038B             ;
0719   038B             gb_number:
0720   038B 6F           ld l,a
0721   038C 78           ld a,b
0722   038D             ;
0723   038D FE 01        cp 1
0724   038F 20 21        jr nz,gb_n1
0725   0391 7D           ld a,l
0726   0392 CB 27        sla a
0727   0394 CB 27        sla a
0728   0396 CB 27        sla a
0729   0398 CB 27        sla a
0730   039A E6 F0        and $f0
0731   039C 6F           ld l,a
0732   039D 7A           ld a,d
0733   039E E6 0F        and $0f
0734   03A0 B5           or l
0735   03A1 57           ld d,a
0736   03A2 7D           ld a,l
0737   03A3 CB 3F        srl a
0738   03A5 CB 3F        srl a
0739   03A7 CB 3F        srl a
0740   03A9 CB 3F        srl a
0741   03AB 05           dec b
0742   03AC CD CB 03     call gb_setadda
0743   03AF C3 3D 03     jp gb_loop
0744   03B2             ;
0745   03B2             gb_n1:
0746   03B2 FE 00        cp 0
0747   03B4 20 25        jr nz,gb_n0
0748   03B6 7D           ld a,l
0749   03B7 E6 0F        and $0f
0750   03B9 6F           ld l,a
0751   03BA 7A           ld a,d
0752   03BB E6 F0        and $f0
0753   03BD B5           or l
0754   03BE 57           ld d,a
0755   03BF 7D           ld a,l
0756   03C0 CD CB 03     call gb_setadda
0757   03C3 3E 42        ld a,Line2+2
0758   03C5 CD C7 01     call setDDRAMa
0759   03C8 C3 3D 03     jp gb_loop
0760   03CB             ;
0761   03CB             gb_setadda:
0762   03CB C5           push bc
0763   03CC 06 00        ld b,0
0764   03CE E5           push hl
0765   03CF 21 42 14     ld hl,hextolcd
0766   03D2 4F           ld c,a
0767   03D3 09           add hl,bc
0768   03D4 46           ld b,(hl)
0769   03D5 CD 3F 01     call char2lcd
0770   03D8 E1           pop hl
0771   03D9 C1           pop bc
0772   03DA C9           ret
0773   03DB             ;
0774   03DB             gb_n0:
0775   03DB C3 DE 03     jp gb_end
0776   03DE             ;
0777   03DE             gb_end:
0778   03DE E1           pop hl
0779   03DF D1           pop de
0780   03E0 C9           ret
0781   03E1             ; end of key_getbyte
0782   03E1             
0783   03E1             ; *** key_getaddress
0784   03E1             ; Uses the LCD to get word-value from the user
0785   03E1             ; Default value should be stored into hl, value
0786   03E1             ; given is also returned in hl
0787   03E1             ; In a is the key which was pressed to get here
0788   03E1             key_getaddress:
0789   03E1 F5           push af
0790   03E2 E5           push hl
0791   03E3 CD 7E 01     call clear_lcd
0792   03E6 3E 00        ld a,Line1
0793   03E8 CD C7 01     call setDDRAMa
0794   03EB 21 1C 13     ld hl,s_inputaddress
0795   03EE CD 86 01     call str2lcd
0796   03F1 E1           pop hl
0797   03F2 F1           pop af
0798   03F3 CD 09 04     call key_getwvalue
0799   03F6 C9           ret
0800   03F7             ; end of key_getaddress
0801   03F7             
0802   03F7             ; *** key_getword
0803   03F7             ; Uses the LCD to get word-value from the user
0804   03F7             ; Default value should be stored into hl, value
0805   03F7             ; given is also returned in hl
0806   03F7             ; In a is the key which was pressed to get here
0807   03F7             key_getword:
0808   03F7 F5           push af
0809   03F8 E5           push hl
0810   03F9 CD 7E 01     call clear_lcd
0811   03FC 3E 00        ld a,Line1
0812   03FE CD C7 01     call setDDRAMa
0813   0401 21 2A 13     ld hl,s_inputword
0814   0404 CD 86 01     call str2lcd
0815   0407 E1           pop hl
0816   0408 F1           pop af
0817   0409             ; If there is need for own start string, then
0818   0409             ; jump here after setting that
0819   0409             key_getwvalue:
0820   0409 C5           push bc
0821   040A D5           push de
0822   040B 54           ld d,h
0823   040C 5D           ld e,l
0824   040D 32 1E EA     ld (key_pressed),a
0825   0410 3E 40        ld a,Line2
0826   0412 CD C7 01     call setDDRAMa
0827   0415 06 3E        ld b,'>'
0828   0417 CD 3F 01     call char2lcd
0829   041A 7C           ld a,h
0830   041B CD FE 00     call byte2lcd
0831   041E 7D           ld a,l
0832   041F CD FE 00     call byte2lcd
0833   0422 3E 41        ld a,Line2+1
0834   0424 CD C7 01     call setDDRAMa
0835   0427 06 03        ld b,3
0836   0429 3E 80        ld a,FastKeyDelay
0837   042B 32 20 EA     ld (key_delay),a
0838   042E             ;
0839   042E             gw_loop:
0840   042E CD 77 02     call key_getkey
0841   0431             ;
0842   0431 FE 10        cp $10
0843   0433 DA 7C 04     jp c,gw_number
0844   0436 FE 17        cp Enter
0845   0438 20 05        jr nz,gw_nEnter
0846   043A 3E 17        ld a,Enter
0847   043C C3 09 05     jp gw_end
0848   043F             gw_nEnter:
0849   043F FE 15        cp CK5
0850   0441 C2 4B 04     jp nz,gw_nundo
0851   0444 62           ld h,d
0852   0445 6B           ld l,e
0853   0446 3E 15        ld a,CK5
0854   0448 C3 09 05     jp gw_end
0855   044B             gw_nundo:
0856   044B FE 10        cp CK0
0857   044D CA 58 04     jp z,gw_left
0858   0450 FE 11        cp CK1
0859   0452 CA 6A 04     jp z,gw_right
0860   0455 C3 2E 04     jp gw_loop
0861   0458             ;
0862   0458             gw_left:
0863   0458 3E 03        ld a,3
0864   045A B8           cp b
0865   045B CA 2E 04     jp z,gw_loop
0866   045E 04           inc b
0867   045F 3E 03        ld a,3
0868   0461 90           sub b
0869   0462 C6 41        add a,Line2+1
0870   0464 CD C7 01     call setDDRAMa
0871   0467 C3 2E 04     jp gw_loop
0872   046A             ;
0873   046A             gw_right:
0874   046A 3E 00        ld a,0
0875   046C B8           cp b
0876   046D CA 2E 04     jp z,gw_loop
0877   0470 05           dec b
0878   0471 3E 03        ld a,3
0879   0473 90           sub b
0880   0474 C6 41        add a,Line2+1
0881   0476 CD C7 01     call setDDRAMa
0882   0479 C3 2E 04     jp gw_loop
0883   047C             ;
0884   047C             gw_number:
0885   047C 4F           ld c,a
0886   047D 78           ld a,b
0887   047E             ;
0888   047E FE 03        cp 3
0889   0480 20 21        jr nz,gw_n3
0890   0482 79           ld a,c
0891   0483 CB 27        sla a
0892   0485 CB 27        sla a
0893   0487 CB 27        sla a
0894   0489 CB 27        sla a
0895   048B E6 F0        and $f0
0896   048D 4F           ld c,a
0897   048E 7C           ld a,h
0898   048F E6 0F        and $0f
0899   0491 B1           or c
0900   0492 67           ld h,a
0901   0493 79           ld a,c
0902   0494 CB 3F        srl a
0903   0496 CB 3F        srl a
0904   0498 CB 3F        srl a
0905   049A CB 3F        srl a
0906   049C 05           dec b
0907   049D CD F6 04     call gw_setadda
0908   04A0 C3 2E 04     jp gw_loop
0909   04A3             ;
0910   04A3             gw_n3:
0911   04A3 FE 02        cp 2
0912   04A5 20 11        jr nz,gw_n2
0913   04A7 79           ld a,c
0914   04A8 E6 0F        and $0f
0915   04AA 4F           ld c,a
0916   04AB 7C           ld a,h
0917   04AC E6 F0        and $f0
0918   04AE B1           or c
0919   04AF 67           ld h,a
0920   04B0 79           ld a,c
0921   04B1 05           dec b
0922   04B2 CD F6 04     call gw_setadda
0923   04B5 C3 2E 04     jp gw_loop
0924   04B8             ;
0925   04B8             gw_n2:
0926   04B8 FE 01        cp 1
0927   04BA 20 21        jr nz,gw_n1
0928   04BC 79           ld a,c
0929   04BD CB 27        sla a
0930   04BF CB 27        sla a
0931   04C1 CB 27        sla a
0932   04C3 CB 27        sla a
0933   04C5 E6 F0        and $f0
0934   04C7 4F           ld c,a
0935   04C8 7D           ld a,l
0936   04C9 E6 0F        and $0f
0937   04CB B1           or c
0938   04CC 6F           ld l,a
0939   04CD 79           ld a,c
0940   04CE CB 3F        srl a
0941   04D0 CB 3F        srl a
0942   04D2 CB 3F        srl a
0943   04D4 CB 3F        srl a
0944   04D6 05           dec b
0945   04D7 CD F6 04     call gw_setadda
0946   04DA C3 2E 04     jp gw_loop
0947   04DD             ;
0948   04DD             gw_n1:
0949   04DD FE 00        cp 0
0950   04DF 20 25        jr nz,gw_n0
0951   04E1 79           ld a,c
0952   04E2 E6 0F        and $0f
0953   04E4 4F           ld c,a
0954   04E5 7D           ld a,l
0955   04E6 E6 F0        and $f0
0956   04E8 B1           or c
0957   04E9 6F           ld l,a
0958   04EA 79           ld a,c
0959   04EB CD F6 04     call gw_setadda
0960   04EE 3E 44        ld a,Line2+4
0961   04F0 CD C7 01     call setDDRAMa
0962   04F3 C3 2E 04     jp gw_loop
0963   04F6             ;
0964   04F6             gw_setadda:
0965   04F6 C5           push bc
0966   04F7 06 00        ld b,0
0967   04F9 E5           push hl
0968   04FA 21 42 14     ld hl,hextolcd
0969   04FD 4F           ld c,a
0970   04FE 09           add hl,bc
0971   04FF 46           ld b,(hl)
0972   0500 CD 3F 01     call char2lcd
0973   0503 E1           pop hl
0974   0504 C1           pop bc
0975   0505 C9           ret
0976   0506             ;
0977   0506             gw_n0:
0978   0506 C3 09 05     jp gw_end
0979   0509             ;
0980   0509             gw_end:
0981   0509 D1           pop de
0982   050A C1           pop bc
0983   050B C9           ret
0984   050C             ; end of key_getword
0985   050C             
0986   050C             ; Jump-table for key-routines to get the key value into reg a
0987   050C             key_0:
0988   050C 3E 00        ld a,key0
0989   050E C9           ret
0990   050F             key_1:
0991   050F 3E 01        ld a,key1
0992   0511 C9           ret
0993   0512             key_2:
0994   0512 3E 02        ld a,key2
0995   0514 C9           ret
0996   0515             key_3:
0997   0515 3E 03        ld a,key3
0998   0517 C9           ret
0999   0518             key_4:
1000   0518 3E 04        ld a,key4
1001   051A C9           ret
1002   051B             key_5:
1003   051B 3E 05        ld a,key5
1004   051D C9           ret
1005   051E             key_6:
1006   051E 3E 06        ld a,key6
1007   0520 C9           ret
1008   0521             key_7:
1009   0521 3E 07        ld a,key7
1010   0523 C9           ret
1011   0524             key_8:
1012   0524 3E 08        ld a,key8
1013   0526 C9           ret
1014   0527             key_9:
1015   0527 3E 09        ld a,key9
1016   0529 C9           ret
1017   052A             key_a:
1018   052A 3E 0A        ld a,keya
1019   052C C9           ret
1020   052D             key_b:
1021   052D 3E 0B        ld a,keyb
1022   052F C9           ret
1023   0530             key_c:
1024   0530 3E 0C        ld a,keyc
1025   0532 C9           ret
1026   0533             key_d:
1027   0533 3E 0D        ld a,keyd
1028   0535 C9           ret
1029   0536             key_e:
1030   0536 3E 0E        ld a,keye
1031   0538 C9           ret
1032   0539             key_f:
1033   0539 3E 0F        ld a,keyf
1034   053B C9           ret
1035   053C             key_CK0:
1036   053C 3E 10        ld a,CK0
1037   053E C9           ret
1038   053F             key_CK1:
1039   053F 3E 11        ld a,CK1
1040   0541 C9           ret
1041   0542             key_CK2:
1042   0542 3E 12        ld a,CK2
1043   0544 C9           ret
1044   0545             key_CK3:
1045   0545 3E 13        ld a,CK3
1046   0547 C9           ret
1047   0548             key_CK4:
1048   0548 3E 14        ld a,CK4
1049   054A C9           ret
1050   054B             key_CK5:
1051   054B 3E 15        ld a,CK5
1052   054D C9           ret
1053   054E             key_Shift:
1054   054E 3E 16        ld a,Shift
1055   0550 C9           ret
1056   0551             key_Enter:
1057   0551 3E 17        ld a,Enter
1058   0553 C9           ret
1059   0554             ; end of key-jump-table
1060   0554             
1061   0554~            #ifdef CPU_AT_2MHZ
1062   0554~            ; *** Delayms
1063   0554~            ; This loop waits amount of milliseconds which is stored in de
1064   0554~            ; CPU should run @2MHz
1065   0554~            ; There is always spend some extra clocks when this delay is initialized
1066   0554~            ; and when it ends.
1067   0554~            Delayms:        ; Clocks spend in instructions and time
1068   0554~             push af        ; 11 / 
1069   0554~             push bc        ; 11 / 
1070   0554~             push de        ; 11 / 
1071   0554~             push ix        ; 15 / 
1072   0554~             xor a          ; 4 / 
1073   0554~             inc d          ; 4 / 
1074   0554~             ld bc,40|$100 ; 10 /
1075   0554~            Delayms0:       ; = 66 /
1076   0554~            ; Here should be used enough clocks that one loop
1077   0554~            ; would spend 1ms! NOP is not an option :)
1078   0554~             dec ix         ; 10 /
1079   0554~             nop            ; 4 /
1080   0554~             nop            ; 4 /
1081   0554~             nop            ; 4 /
1082   0554~             nop            ; 4 /
1083   0554~             dec bc         ; 6 /
1084   0554~             cp b           ; 4 / 
1085   0554~             jr nz,Delayms0 ; 12 /
1086   0554~                            ; = 48 / 24us
1087   0554~            ; There goes 984us and rest of the 1000us is spend here
1088   0554~             ld bc,40|$100 ; 10 / 
1089   0554~             dec de         ; 6 / 
1090   0554~             cp d           ; 4 / 
1091   0554~             jr nz,Delayms0 ; 12 / 
1092   0554~                            ; = 32 / 16us
1093   0554~             pop ix         ; 14 / 
1094   0554~             pop de         ; 10 / 
1095   0554~             pop bc         ; 10 / 
1096   0554~             pop af         ; 10 / 
1097   0554~             ret            ; 10 / 
1098   0554~                            ; = 54 / 
1099   0554~            ; end of Delayms
1100   0554             #endif
1101   0554             
1102   0554             #ifdef CPU_AT_4MHZ
1103   0554             ; *** Delayms
1104   0554             ; This loop waits amount of milliseconds which is stored in de
1105   0554             ; CPU should run @4MHz
1106   0554             ; There is always spend some extra clocks when this delay is initialized
1107   0554             ; and when it ends. These actions takes 30us+4.25us for calling
1108   0554             Delayms:        ; Clocks spend in instructions and time
1109   0554 F5           push af        ; 11 / 2.75us
1110   0555 C5           push bc        ; 11 / 2.75us
1111   0556 D5           push de        ; 11 / 2.75us
1112   0557 DD E5        push ix        ; 15 / 3.75us
1113   0559 AF           xor a          ; 4 / 1us
1114   055A 14           inc d          ; 4 / 1us , becose 1ms should be 1ms and so on...
1115   055B 01 7B 01     ld bc,123|$100 ; 10 / 2.5us
1116   055E             Delayms0:       ; = 66 / 16.5us
1117   055E             ; Here should be used enough clocks that one loop
1118   055E             ; would spend 1ms! NOP is not an option :)
1119   055E DD 2B        dec ix         ; 10 / 2.5us
1120   0560 0B           dec bc         ; 6 /1.5us
1121   0561 B8           cp b           ; 4 / 1us
1122   0562 20 FA        jr nz,Delayms0 ; 12 / 3us
1123   0564                             ; = 32 / 8us
1124   0564             ; There goes 992us and rest 8us of 1000us is spend here
1125   0564 01 7B 01     ld bc,123|$100 ; 10 / 2.5us
1126   0567 1B           dec de         ; 6 / 1.5us
1127   0568 BA           cp d           ; 4 / 1us
1128   0569 20 F3        jr nz,Delayms0 ; 12 / 3us
1129   056B                             ; = 32 / 8us
1130   056B DD E1        pop ix         ; 14 / 3.5us
1131   056D D1           pop de         ; 10 / 2.5us
1132   056E C1           pop bc         ; 10 / 2.5us
1133   056F F1           pop af         ; 10 / 2.5us
1134   0570 C9           ret            ; 10 / 2.5us
1135   0571                             ; = 54 / 13.5us
1136   0571             ; end of Delayms
1137   0571             #endif
1138   0571~            #ifdef CPU_AT_8MHZ
1139   0571~            ; *** Delayms
1140   0571~            ; This loop waits amount of milliseconds which is stored in de
1141   0571~            ; CPU should run @4MHz
1142   0571~            ; There is always spend some extra clocks when this delay is initialized
1143   0571~            ; and when it ends.
1144   0571~            Delayms:        ; Clocks spend in instructions and time
1145   0571~             push af        ; 11 / 1.375us
1146   0571~             push bc        ; 11 / 1.375us
1147   0571~             push de        ; 11 / 1.375us
1148   0571~             push ix        ; 15 / 1.875us
1149   0571~             xor a          ; 4 / 0.5us
1150   0571~             inc d          ; 4 / 0.5us , becose 1ms should be 1ms and so on...
1151   0571~             ld bc,199|$100 ; 10 / 1.25us
1152   0571~            Delayms0:       ; = 66 / 8.25us
1153   0571~            ; Here should be used enough clocks that one loop
1154   0571~            ; would spend 1ms! NOP is not an option :)
1155   0571~             nop            ; 4 / 0.5us
1156   0571~             nop            ; 4 / 0.5us
1157   0571~             dec ix         ; 10 / 1.25us
1158   0571~             dec bc         ; 6 / 0.75us
1159   0571~             cp b           ; 4 / 0.5us
1160   0571~             jr nz,Delayms0 ; 12 / 1.5us
1161   0571~                            ; = 40 / 5us
1162   0571~            ; There goes 995us and rest 5us of 1000us is spend here
1163   0571~             nop            ; 4 / 0.5us
1164   0571~             nop            ; 4 / 0.5us
1165   0571~             ld bc,199|$100 ; 10 / 1.25us
1166   0571~             dec de         ; 6 / 0.75us
1167   0571~             cp d           ; 4 / 0.5us
1168   0571~             jr nz,Delayms0 ; 12 / 1.5us
1169   0571~                            ; = 40 / 5us
1170   0571~             pop ix         ; 14 / 1.75us
1171   0571~             pop de         ; 10 / 1.25us
1172   0571~             pop bc         ; 10 / 1.25us
1173   0571~             pop af         ; 10 / 1.25us
1174   0571~             ret            ; 10 / 1.25us
1175   0571~                            ; = 54 / 6.625us
1176   0571~            ; end of Delayms
1177   0571             #endif
1178   0571             
1179   0571             ; *** CreateLog
1180   0571             ; Creates a log into log memory if there is enough space left
1181   0571             ; Log size in h as amount of 256B slices
1182   0571             ; Returns logs id in reg a, if a is 0 the there was no space left to create log
1183   0571             ; or there was too many logs
1184   0571             CreateLog:
1185   0571 3A 3C EA     ld a,(logs_curid)
1186   0574 FE 08        cp MAX_LOGS
1187   0576 3E 00        ld a,0
1188   0578 C8           ret z
1189   0579 BC           cp h
1190   057A C8           ret z
1191   057B 2E 00        ld l,0
1192   057D C5           push bc
1193   057E D5           push de
1194   057F E5           push hl
1195   0580 ED 5B 3E EA  ld de,(logs_cur)
1196   0584 01 00 F0     ld bc,$10000-LOG_MEMORY_SIZE
1197   0587 19           add hl,de
1198   0588 38 2F        jr c,cl_end
1199   058A 09           add hl,bc
1200   058B 38 2C        jr c,cl_end
1201   058D E1           pop hl
1202   058E E5           push hl 
1203   058F 19           add hl,de
1204   0590 22 3E EA     ld (logs_cur),hl
1205   0593 01 80 EC     ld bc,logs
1206   0596 09           add hl,bc
1207   0597 2B           dec hl
1208   0598 3E 18        ld a,EOLOG
1209   059A 77           ld (hl),a
1210   059B 2B           dec hl
1211   059C 3E 17        ld a,EOL
1212   059E 77           ld (hl),a
1213   059F             ; ex de,hl
1214   059F             ; add hl,bc
1215   059F             ; ld a,EOLOG
1216   059F             ; ld (hl),a
1217   059F 3A 3C EA     ld a,(logs_curid)
1218   05A2 3C           inc a
1219   05A3 32 3C EA     ld (logs_curid),a
1220   05A6 CB 27        sla a
1221   05A8 21 40 EA     ld hl,logs_ids
1222   05AB 06 00        ld b,0
1223   05AD 4F           ld c,a
1224   05AE 09           add hl,bc
1225   05AF ED 5B 3E EA  ld de,(logs_cur)
1226   05B3 73           ld (hl),e
1227   05B4 23           inc hl
1228   05B5 72           ld (hl),d
1229   05B6 3A 3C EA     ld a,(logs_curid)
1230   05B9             cl_end:
1231   05B9 E1           pop hl
1232   05BA D1           pop de
1233   05BB C1           pop bc
1234   05BC C9           ret
1235   05BD             ; end of CreateLog
1236   05BD             
1237   05BD             ; *** AddLog
1238   05BD             ; Logs id in reg a and add string's address in hl
1239   05BD             ; String lenght should not be more than 255 chars
1240   05BD             AddLog:
1241   05BD F5           push af
1242   05BE C5           push bc
1243   05BF D5           push de
1244   05C0 47           ld b,a
1245   05C1 3A 3C EA     ld a,(logs_curid)
1246   05C4 B8           cp b
1247   05C5 DA 34 06     jp c,al_end
1248   05C8 AF           xor a
1249   05C9 B8           cp b
1250   05CA CA 34 06     jp z,al_end
1251   05CD 3A 3D EA     ld a,(logs_status)
1252   05D0 FE 01        cp log_adding
1253   05D2 CA 34 06     jp z,al_end
1254   05D5 F6 01        or log_adding
1255   05D7 32 3D EA     ld (logs_status),a
1256   05DA             ; If string lenght is more than 255 chars this loop fails
1257   05DA             ; Failure is not fatal anyway, so let the 'user' do the checking
1258   05DA             ; for lenght of the string
1259   05DA 0E 00        ld c,0
1260   05DC             al_cnts:
1261   05DC 7E           ld a,(hl)
1262   05DD 23           inc hl
1263   05DE 0C           inc c
1264   05DF DA E7 05     jp c,al_cntover
1265   05E2 FE 17        cp EOL
1266   05E4 C2 DC 05     jp nz,al_cnts
1267   05E7             al_cntover:
1268   05E7 2B           dec hl
1269   05E8 2B           dec hl
1270   05E9 0D           dec c
1271   05EA CA 34 06     jp z,al_end
1272   05ED E5           push hl
1273   05EE C5           push bc
1274   05EF CB 20        sla b
1275   05F1 05           dec b
1276   05F2 05           dec b
1277   05F3 16 00        ld d,0
1278   05F5 58           ld e,b
1279   05F6 21 40 EA     ld hl,logs_ids
1280   05F9 19           add hl,de
1281   05FA 5E           ld e,(hl)
1282   05FB 23           inc hl
1283   05FC 56           ld d,(hl)
1284   05FD 23           inc hl
1285   05FE 79           ld a,c
1286   05FF 4E           ld c,(hl)
1287   0600 23           inc hl
1288   0601 46           ld b,(hl)
1289   0602 26 00        ld h,0
1290   0604 6F           ld l,a
1291   0605 19           add hl,de
1292   0606 E5           push hl
1293   0607 79           ld a,c
1294   0608 95           sub l
1295   0609 4F           ld c,a
1296   060A 78           ld a,b
1297   060B 9C           sbc a,h
1298   060C 47           ld b,a
1299   060D 21 80 EC     ld hl,logs
1300   0610 19           add hl,de
1301   0611 EB           ex de,hl
1302   0612 E1           pop hl
1303   0613 D5           push de
1304   0614 11 80 EC     ld de,logs
1305   0617 19           add hl,de
1306   0618 D1           pop de
1307   0619 ED B0        ldir
1308   061B C1           pop bc
1309   061C CB 20        sla b
1310   061E 16 00        ld d,0
1311   0620 58           ld e,b
1312   0621 21 40 EA     ld hl,logs_ids
1313   0624 19           add hl,de
1314   0625 5E           ld e,(hl)
1315   0626 23           inc hl
1316   0627 56           ld d,(hl)
1317   0628 21 80 EC     ld hl,logs
1318   062B 19           add hl,de
1319   062C 2B           dec hl
1320   062D 2B           dec hl
1321   062E EB           ex de,hl
1322   062F E1           pop hl
1323   0630 06 00        ld b,0
1324   0632 ED B8        lddr
1325   0634             al_end:
1326   0634 3A 3D EA     ld a,(logs_status)
1327   0637 E6 FE        and ~log_adding
1328   0639 32 3D EA     ld (logs_status),a
1329   063C D1           pop de
1330   063D C1           pop bc
1331   063E F1           pop af
1332   063F C9           ret
1333   0640             ; end of AddLog
1334   0640             
1335   0640             ; *** ViewLog
1336   0640             ; Log id in reg a
1337   0640             ViewLog:
1338   0640 F5           push af
1339   0641 C5           push bc
1340   0642 D5           push de
1341   0643 E5           push hl
1342   0644 4F           ld c,a
1343   0645 3A 3C EA     ld a,(logs_curid)
1344   0648 B9           cp c
1345   0649 DA 4B 07     jp c,vl_end
1346   064C AF           xor a
1347   064D B9           cp c
1348   064E CA 4B 07     jp z,vl_end
1349   0651 CB 21        sla c
1350   0653 0D           dec c
1351   0654 0D           dec c
1352   0655 06 00        ld b,0
1353   0657 21 40 EA     ld hl,logs_ids
1354   065A 09           add hl,bc
1355   065B 4E           ld c,(hl)
1356   065C 23           inc hl
1357   065D 46           ld b,(hl)
1358   065E 23           inc hl
1359   065F 5E           ld e,(hl)
1360   0660 23           inc hl
1361   0661 56           ld d,(hl)
1362   0662 7B           ld a,e
1363   0663 91           sub c
1364   0664 4F           ld c,a
1365   0665 7A           ld a,d
1366   0666 98           sbc a,b
1367   0667 47           ld b,a
1368   0668 3E 17        ld a,EOL
1369   066A 21 80 EC     ld hl,logs
1370   066D 19           add hl,de
1371   066E ED B9        cpdr
1372   0670 23           inc hl
1373   0671 23           inc hl
1374   0672 54           ld d,h
1375   0673 5D           ld e,l
1376   0674             ;
1377   0674 CD 5B 01     call reset_lcd
1378   0677 06 0C        ld b,%00001100         ; This sets cursor and cursor blinking off
1379   0679 CD 25 01     call set_lcd
1380   067C             ;
1381   067C CD F0 06     call vl_show
1382   067F             vl_start:
1383   067F 3E 17        ld a,Enter
1384   0681 32 1E EA     ld (key_pressed),a
1385   0684 3E 20        ld a,$20
1386   0686 32 20 EA     ld (key_delay),a
1387   0689 ED 4B 32 EA  ld bc,(RepeatDelay)
1388   068D ED 43 22 EA  ld (key_repeatdelay),bc
1389   0691 ED 4B 34 EA  ld bc,(RepeatRate)
1390   0695 ED 43 24 EA  ld (key_repeatrate),bc
1391   0699 3E FF        ld a,$ff
1392   069B 32 2A EA     ld (key_rset),a
1393   069E             ;
1394   069E             vl_loop:
1395   069E CD 77 02     call key_getkey
1396   06A1             ; Now test which key was pressed
1397   06A1 FE 17        cp Enter
1398   06A3 CA 4B 07     jp z,vl_end
1399   06A6 FE 11        cp CK1
1400   06A8 CA B3 06     jp z,vl_rollup
1401   06AB FE 13        cp CK3
1402   06AD CA D1 06     jp z,vl_rolldown
1403   06B0 C3 9E 06     jp vl_loop
1404   06B3             ;
1405   06B3             vl_rollup:
1406   06B3 7A           ld a,d
1407   06B4 BC           cp h
1408   06B5 20 0C        jr nz,vlu_dec
1409   06B7 7B           ld a,e
1410   06B8 BD           cp l
1411   06B9 20 08        jr nz,vlu_dec
1412   06BB CD F0 06     call vl_show
1413   06BE 3E 11        ld a,CK1
1414   06C0 C3 9E 06     jp vl_loop
1415   06C3             vlu_dec:
1416   06C3 3E 14        ld a,20
1417   06C5             vlu_dec20loop:
1418   06C5 2B           dec hl
1419   06C6 3D           dec a
1420   06C7 20 FC        jr nz,vlu_dec20loop;
1421   06C9 CD F0 06     call vl_show
1422   06CC 3E 11        ld a,CK1
1423   06CE C3 9E 06     jp vl_loop
1424   06D1             ;
1425   06D1             vl_rolldown:
1426   06D1 E5           push hl
1427   06D2 06 14        ld b,20
1428   06D4             vld_inc20loop:
1429   06D4 23           inc hl
1430   06D5 7E           ld a,(hl)
1431   06D6 FE 17        cp EOL
1432   06D8 28 10        jr z,vld_nroll
1433   06DA FE 18        cp EOLOG
1434   06DC 28 0C        jr z,vld_nroll
1435   06DE 05           dec b
1436   06DF 20 F3        jr nz,vld_inc20loop;
1437   06E1 CD F0 06     call vl_show
1438   06E4 3E 13        ld a,CK3
1439   06E6 C1           pop bc
1440   06E7 C3 9E 06     jp vl_loop
1441   06EA             vld_nroll:
1442   06EA 3E 13        ld a,CK3
1443   06EC E1           pop hl
1444   06ED C3 9E 06     jp vl_loop
1445   06F0             ;
1446   06F0             vl_show:
1447   06F0 E5           push hl
1448   06F1 0E 14        ld c,20
1449   06F3 3E 00        ld a,Line1
1450   06F5 CD C7 01     call setDDRAMa
1451   06F8 06 00        ld b,0
1452   06FA CD 97 01     call strn2lcd
1453   06FD 3E 19        ld a,NOEOL
1454   06FF B9           cp c
1455   0700 20 15        jr nz,vl_eolog
1456   0702 E5           push hl
1457   0703 0E 14        ld c,20
1458   0705 3E 40        ld a,Line2
1459   0707 CD C7 01     call setDDRAMa
1460   070A 06 01        ld b,1
1461   070C CD 97 01     call strn2lcd
1462   070F 3E 19        ld a,NOEOL
1463   0711 B9           cp c
1464   0712 20 03        jr nz,vl_eolog
1465   0714 E1           pop hl
1466   0715 E1           pop hl
1467   0716 C9           ret
1468   0717             vl_eolog:
1469   0717 AF           xor a
1470   0718 B8           cp b
1471   0719 28 16        jr z,vle_tend
1472   071B 3E 40        ld a,Line2
1473   071D CD C7 01     call setDDRAMa
1474   0720 21 FC 0F     ld hl,s_clearline
1475   0723 CD 86 01     call str2lcd
1476   0726 E1           pop hl 
1477   0727 3E 40        ld a,Line2
1478   0729 CD C7 01     call setDDRAMa
1479   072C CD 97 01     call strn2lcd
1480   072F E1           pop hl
1481   0730 C9           ret
1482   0731             vle_tend:
1483   0731 CD 7E 01     call clear_lcd
1484   0734 3E 00        ld a,Line1
1485   0736 CD C7 01     call setDDRAMa
1486   0739 E1           pop hl
1487   073A E5           push hl
1488   073B CD 97 01     call strn2lcd
1489   073E 3E 40        ld a,Line2
1490   0740 CD C7 01     call setDDRAMa
1491   0743 21 FC 0F     ld hl,s_clearline
1492   0746 CD 86 01     call str2lcd
1493   0749 E1           pop hl
1494   074A C9           ret
1495   074B             ;
1496   074B             vl_end:
1497   074B E1           pop hl
1498   074C D1           pop de
1499   074D C1           pop bc
1500   074E F1           pop af
1501   074F C9           ret
1502   0750             ; end of ViewLog
1503   0750             
1504   0750             ;**************************************************************
1505   0750             ; OS's main code start location
1506   0750             RESET:
1507   0750             ; After Reset we come here
1508   0750             ; Disable interrupts and couple of nops just for safe ;)
1509   0750 F3           di
1510   0751 00           nop
1511   0752 00           nop
1512   0753 00           nop
1513   0754              
1514   0754             ; Testing the 8kB RAM at address $e000-$ffff
1515   0754             ; Address $c000-$dfff also contains a 8kb RAM..
1516   0754             ; Should not be using stack in any way, becose don't
1517   0754             ; know if the memory is OK, or even exists really
1518   0754             ; The error test won't affect on running the os
1519   0754             ; really in any way. It just will inform the user
1520   0754             ; that there is bad memory in the system.
1521   0754 06 FF        ld b,$ff
1522   0756 21 00 20     ld hl,$2000
1523   0759 11 00 E0     ld de,$e000
1524   075C             ; Address pointer de and counter hl have now been set up
1525   075C             ; Start testing:
1526   075C             fill_loop0:
1527   075C 1A           ld a,(de)              ; store the original value into reg c
1528   075D 4F           ld c,a                 ;
1529   075E 3E AA        ld a,%10101010         ; first test pattern
1530   0760 12           ld (de),a
1531   0761 1A           ld a,(de)
1532   0762 FE AA        cp %10101010
1533   0764 79           ld a,c                 ; save the original value back
1534   0765 12           ld (de),a              ;
1535   0766 28 47        jr z,fill0             ; If OK then continue
1536   0768 7A           ld a,d                 ; Otherwise check where the error was found
1537   0769 E6 1C        and %00011100
1538   076B CB 3F        srl a
1539   076D CB 3F        srl a
1540   076F             ; Here is checked which 1kB page of the 8kB has faulty memory
1541   076F             ; The result is stored in register b
1542   076F FE 00        cp 0
1543   0771 28 1C        jr z,z00
1544   0773 FE 01        cp 1
1545   0775 28 1C        jr z,z01
1546   0777 FE 02        cp 2
1547   0779 28 1C        jr z,z02
1548   077B FE 03        cp 3
1549   077D 28 1C        jr z,z03
1550   077F FE 04        cp 4
1551   0781 28 1C        jr z,z04
1552   0783 FE 05        cp 5
1553   0785 28 1C        jr z,z05
1554   0787 FE 06        cp 6
1555   0789 28 1C        jr z,z06
1556   078B FE 07        cp 7
1557   078D 28 1C        jr z,z07
1558   078F             z00:
1559   078F CB 80        res 0,b
1560   0791 18 1C        jr fill0
1561   0793             z01:
1562   0793 CB 88        res 1,b
1563   0795 18 18        jr fill0
1564   0797             z02:
1565   0797 CB 90        res 2,b
1566   0799 18 14        jr fill0
1567   079B             z03:
1568   079B CB 98        res 3,b
1569   079D 18 10        jr fill0
1570   079F             z04:
1571   079F CB A0        res 4,b
1572   07A1 18 0C        jr fill0
1573   07A3             z05:
1574   07A3 CB A8        res 5,b
1575   07A5 18 08        jr fill0
1576   07A7             z06:
1577   07A7 CB B0        res 6,b
1578   07A9 18 04        jr fill0
1579   07AB             z07:
1580   07AB CB B8        res 7,b
1581   07AD 18 00        jr fill0
1582   07AF             
1583   07AF             fill0:
1584   07AF 1A           ld a,(de)              ; store the original value into reg c
1585   07B0 4F           ld c,a                 ;
1586   07B1 3E 55        ld a,%01010101         ; Second test pattern
1587   07B3 12           ld (de),a
1588   07B4 1A           ld a,(de)
1589   07B5 FE 55        cp %01010101
1590   07B7 79           ld a,c                 ; save the original value back
1591   07B8 12           ld (de),a              ;
1592   07B9 28 47        jr z,fill1             ; If OK then continue
1593   07BB 7A           ld a,d                 ; Otherwise check where the error was found
1594   07BC E6 1C        and %00011100
1595   07BE CB 3F        srl a
1596   07C0 CB 3F        srl a
1597   07C2             ; Again checking the 1kB page
1598   07C2 FE 00        cp 0
1599   07C4 28 1C        jr z,z10
1600   07C6 FE 01        cp 1
1601   07C8 28 1C        jr z,z11
1602   07CA FE 02        cp 2
1603   07CC 28 1C        jr z,z12
1604   07CE FE 03        cp 3
1605   07D0 28 1C        jr z,z13
1606   07D2 FE 04        cp 4
1607   07D4 28 1C        jr z,z14
1608   07D6 FE 05        cp 5
1609   07D8 28 1C        jr z,z15
1610   07DA FE 06        cp 6
1611   07DC 28 1C        jr z,z16
1612   07DE FE 07        cp 7
1613   07E0 28 1C        jr z,z17
1614   07E2             z10:
1615   07E2 CB 80        res 0,b
1616   07E4 18 1C        jr fill1
1617   07E6             z11:
1618   07E6 CB 88        res 1,b
1619   07E8 18 18        jr fill1
1620   07EA             z12:
1621   07EA CB 90        res 2,b
1622   07EC 18 14        jr fill1
1623   07EE             z13:
1624   07EE CB 98        res 3,b
1625   07F0 18 10        jr fill1
1626   07F2             z14:
1627   07F2 CB A0        res 4,b
1628   07F4 18 0C        jr fill1
1629   07F6             z15:
1630   07F6 CB A8        res 5,b
1631   07F8 18 08        jr fill1
1632   07FA             z16:
1633   07FA CB B0        res 6,b
1634   07FC 18 04        jr fill1
1635   07FE             z17:
1636   07FE CB B8        res 7,b
1637   0800 18 00        jr fill1
1638   0802              
1639   0802             fill1:
1640   0802 13           inc de
1641   0803 2D           dec l
1642   0804 C2 5C 07     jp nz,fill_loop0
1643   0807             ; Show the current position of test with the 8 LEDs
1644   0807             ; This just for fun ;)
1645   0807 78           ld a,b
1646   0808 CB 3F        srl a
1647   080A CB 3F        srl a
1648   080C CB 3F        srl a
1649   080E CB 3F        srl a
1650   0810 4F           ld c,a
1651   0811 78           ld a,b
1652   0812 CB 27        sla a
1653   0814 CB 27        sla a
1654   0816 CB 27        sla a
1655   0818 CB 27        sla a
1656   081A E6 F0        and $f0
1657   081C B1           or c
1658   081D 4F           ld c,a
1659   081E 7A           ld a,d
1660   081F E6 1C        and %00011100
1661   0821 CB 3F        srl a
1662   0823 CB 3F        srl a
1663   0825             ; Find out the 1kB page
1664   0825 FE 00        cp 0
1665   0827 28 2C        jr z,z24
1666   0829 FE 01        cp 1
1667   082B 28 2C        jr z,z25
1668   082D FE 02        cp 2
1669   082F 28 2C        jr z,z26
1670   0831 FE 03        cp 3
1671   0833 28 2C        jr z,z27
1672   0835 FE 04        cp 4
1673   0837 28 0C        jr z,z20
1674   0839 FE 05        cp 5
1675   083B 28 0C        jr z,z21
1676   083D FE 06        cp 6
1677   083F 28 0C        jr z,z22
1678   0841 FE 07        cp 7
1679   0843 28 0C        jr z,z23
1680   0845             z20:
1681   0845 CB 81        res 0,c
1682   0847 18 1C        jr test_position_end
1683   0849             z21:
1684   0849 CB 89        res 1,c
1685   084B 18 18        jr test_position_end
1686   084D             z22:
1687   084D CB 91        res 2,c
1688   084F 18 14        jr test_position_end
1689   0851             z23:
1690   0851 CB 99        res 3,c
1691   0853 18 10        jr test_position_end
1692   0855             z24:
1693   0855 CB A1        res 4,c
1694   0857 18 0C        jr test_position_end
1695   0859             z25:
1696   0859 CB A9        res 5,c
1697   085B 18 08        jr test_position_end
1698   085D             z26:
1699   085D CB B1        res 6,c
1700   085F 18 04        jr test_position_end
1701   0861             z27:
1702   0861 CB B9        res 7,c
1703   0863 18 00        jr test_position_end
1704   0865             
1705   0865             test_position_end:
1706   0865 79           ld a,c
1707   0866 D3 07        out (LEDs),a
1708   0868 25           dec h
1709   0869 C2 5C 07     jp nz,fill_loop0
1710   086C             
1711   086C             ; End of memory test
1712   086C             ; Show the result of the test with the 8 LEDs
1713   086C 78           ld a,b
1714   086D D3 07        out (LEDs),a
1715   086F             ; If there was found an error from memory in the test
1716   086F             ; then show 'EEEE'-string in the default 7segments
1717   086F FE FF        cp $ff
1718   0871 28 14        jr z,no_error_in_memory
1719   0873 3E C8        ld a,%11001000
1720   0875 D3 01        out (SSeg1),a
1721   0877 D3 02        out (SSeg2),a
1722   0879 D3 03        out (SSeg3),a
1723   087B D3 04        out (SSeg4),a
1724   087D 21 FF FF     ld hl,$ffff
1725   0880             error_delay_loop:
1726   0880 00           nop
1727   0881 2D           dec l
1728   0882 30 FC        jr nc,error_delay_loop
1729   0884 25           dec h
1730   0885 30 F9        jr nc,error_delay_loop
1731   0887             no_error_in_memory:
1732   0887             ; Now we set up the stack pointer
1733   0887 31 F0 FF     ld sp,StackPointerOrigin
1734   088A             ; Start by  initializing and blinking the default 7segments
1735   088A 3E FF        ld a,$ff
1736   088C D3 01        out (SSeg1),a
1737   088E D3 02        out (SSeg2),a
1738   0890 D3 03        out (SSeg3),a
1739   0892 D3 04        out (SSeg4),a
1740   0894             ; Also 'reset' the keyboard, just for safe
1741   0894 D3 05        out (KeyS),a
1742   0896             ; Let's do some blinking
1743   0896 11 F4 01     ld de,500      ; 500ms
1744   0899 CD 54 05     call Delayms   ; Wait a bit when the 7segments are off
1745   089C 3E 00        ld a,0
1746   089E D3 01        out (SSeg1),a
1747   08A0 D3 02        out (SSeg2),a
1748   08A2 D3 03        out (SSeg3),a
1749   08A4 D3 04        out (SSeg4),a
1750   08A6 11 F4 01     ld de,500
1751   08A9 CD 54 05     call Delayms   ; Wait a bit when the 7segments are on
1752   08AC 3E FF        ld a,$ff       ; Then reset the 7segments off
1753   08AE D3 01        out (SSeg1),a
1754   08B0 D3 02        out (SSeg2),a
1755   08B2 D3 03        out (SSeg3),a
1756   08B4 D3 04        out (SSeg4),a
1757   08B6             ; Now the memory error message in the LEDs should have been seeable
1758   08B6             ; enough long time so reset the LEDs also
1759   08B6 3E FF        leds_load($ff)
1759   08B8 D3 07       
1759   08BA 32 86 EB    
1760   08BD             ; Set up timer which creates NMI interrupt for system timing
1761   08BD             ; and clear uptime counter
1762   08BD             ; Set the NMI to happen every 1secs
1763   08BD             ; (Counter 0 clock must be 4MHz)
1764   08BD             ; Counter 0
1765   08BD 3E 37        ld a,%00110111
1766   08BF D3 A3        out (CounterC),a
1767   08C1 3E 00        ld a,$00
1768   08C3 D3 A0        out (Counter0),a
1769   08C5 3E 01        ld a,$01
1770   08C7 D3 A0        out (Counter0),a
1771   08C9             ; Counter 1
1772   08C9 3E 77        ld a,%01110111
1773   08CB D3 A3        out (CounterC),a
1774   08CD 3E 04        ld a,$04
1775   08CF D3 A1        out (Counter1),a
1776   08D1 3E 00        ld a,$00
1777   08D3 D3 A1        out (Counter1),a
1778   08D5             ; Counter 2
1779   08D5 3E B7        ld a,%10110111
1780   08D7 D3 A3        out (CounterC),a
1781   08D9 3E 96        ld a,$96
1782   08DB D3 A2        out (Counter2),a
1783   08DD 3E 99        ld a,$99
1784   08DF D3 A2        out (Counter2),a
1785   08E1             ; Uptime counter
1786   08E1 21 00 00     ld hl,0
1787   08E4 22 80 EB     ld (uptime),hl
1788   08E7 22 82 EB     ld (uptime+2),hl
1789   08EA 22 84 EB     ld (uptime+4),hl
1790   08ED             ; Set flash to page 0
1791   08ED AF           xor a
1792   08EE D3 C1        out (flashcom),a
1793   08F0             ; Reset logs and create system's default log
1794   08F0 AF           xor a
1795   08F1 32 3C EA     ld (logs_curid),a
1796   08F4 32 3D EA     ld (logs_status),a
1797   08F7 21 00 00     ld hl,0
1798   08FA 22 3E EA     ld (logs_cur),hl
1799   08FD 22 40 EA     ld (logs_ids),hl
1800   0900 21 00 04     ld hl,1024     ; 51,2 lines long, 20 characters per line, 1024bytes
1801   0903 CD 71 05     call CreateLog ; No checking if the log was even created
1802   0906 32 7F EA     ld (SystemLogId),a
1803   0909 3A 7F EA     ld a,(SystemLogId)
1804   090C 21 9F 13     ld hl,s_SysFirst
1805   090F CD BD 05     call AddLog
1806   0912 21 BA 13     ld hl,s_SysStartUp
1807   0915 CD BD 05     call AddLog
1808   0918             ; Set keyboard's default repeat delay and rate,
1809   0918             ; if not already set
1810   0918 3A 36 EA     ld a,(RepeatSet)
1811   091B FE 17        cp $17
1812   091D 28 11        jr z,j_RepeatSet
1813   091F 21 FF 0F     ld hl,_RepeatDelay
1814   0922 22 32 EA     ld (RepeatDelay),hl
1815   0925 21 FF 01     ld hl,_RepeatRate
1816   0928 22 34 EA     ld (RepeatRate),hl
1817   092B 3E 17        ld a,$17
1818   092D 32 36 EA     ld (RepeatSet),a
1819   0930             j_RepeatSet:
1820   0930             ; Some settings for hexedit
1821   0930 3E FF        ld a,$ff
1822   0932 32 0C EA     ld (b_he_undoset),a
1823   0935             ; Misc settings
1824   0935 AF           xor a
1825   0936 32 00 EA     ld (T0),a
1826   0939 32 01 EA     ld (T1),a
1827   093C 32 02 EA     ld (T2),a
1828   093F 32 03 EA     ld (T3),a
1829   0942 32 04 EA     ld (GT0),a
1830   0945 32 05 EA     ld (GT1),a
1831   0948             ; Set default interrupt mode
1832   0948 ED 56        im 1   ; INT is probably used by ethernet controller
1833   094A             ; Init 8255 PIO
1834   094A             ; Port B and port C lower 4bits to LCD-diplay
1835   094A             ; Port A and port C upper 4bits as inputs for now
1836   094A             ; Mode for 8255 is 0 for now
1837   094A 3E 98        ld a,%10011000
1838   094C D3 23        out (PIOCtrl),a
1839   094E 3E 00        ld a,$0
1840   0950 D3 21        out (LCDd),a
1841   0952 3E 01        ld a,%00000001
1842   0954 D3 22        out (LCDi),a
1843   0956             ; Init the LCD-display
1844   0956 CD 5B 01     call reset_lcd
1845   0959             ; Detect and init ethernet adapter
1846   0959             ; The ethernet adapter is not enabled here yet
1847   0959             ; Also init network and enable NIC
1848   0959 3A 7F EA     ld a,(SystemLogId)
1849   095C 21 C9 13     ld hl,s_SysProbeNIC
1850   095F CD BD 05     call AddLog
1851   0962 CD 62 14     call ethInit
1852   0965 21 FD 13     ld hl,s_SysNoNIC
1853   0968 FE 69        cp $69                 ; $69 should be NoNIC
1854   096A 28 06        jr z,sup_nonicfound
1855   096C CD 91 20     call net_init
1856   096F 21 E1 13     ld hl,s_SysNICfound
1857   0972             sup_nonicfound:
1858   0972 3A 7F EA     ld a,(SystemLogId)
1859   0975 CD BD 05     call AddLog
1860   0978             ; Put a string to the LCD
1861   0978 CD 7E 01     call clear_lcd
1862   097B 06 0E        ld b,%00001110         ; This sets cursor on and cursor blinking off
1863   097D CD 25 01     call set_lcd
1864   0980 21 97 0F     ld hl,s_OSstring
1865   0983 11 00 20     ld de,$2000
1866   0986 CD 86 01     call str2lcd
1867   0989 3E 40        ld a,Line2
1868   098B CD C7 01     call setDDRAMa
1869   098E 21 AB 0F     ld hl,s_version
1870   0991 11 00 20     ld de,$2000
1871   0994 CD 86 01     call str2lcd
1872   0997 06 0F        ld b,%00001111         ; This sets cursor and cursor blinking on
1873   0999 CD 25 01     call set_lcd
1874   099C 06 20        ld b,' '
1875   099E CD 3F 01     call char2lcd
1876   09A1             ; Wait for user to push Enter-button
1877   09A1 3E FE        ld a,%11111110
1878   09A3 D3 05        out (KeyS),a
1879   09A5             sup_waitEnter:
1880   09A5 DB 06        in a,(KeyR)
1881   09A7 CB 47        bit 0,a
1882   09A9 20 FA        jr nz,sup_waitEnter
1883   09AB             ; Start the default command prompt
1884   09AB 3A 7F EA     ld a,(SystemLogId)
1885   09AE 21 0C 14     ld hl,s_SysModeS
1886   09B1 CD BD 05     call AddLog
1887   09B4 3E FF        ld a,none
1888   09B6 32 1E EA     ld (key_pressed),a
1889   09B9             mcp_start:
1890   09B9 CD 7E 01     call clear_lcd         ; This clears the LCD and returns cursor to home
1891   09BC 06 0F        ld b,%00001111         ; This sets cursor and cursor blinking on
1892   09BE CD 25 01     call set_lcd           ;
1893   09C1 3E 00        ld a,Line1
1894   09C3 CD C7 01     call setDDRAMa
1895   09C6 21 C5 0F     ld hl,s_defprompt
1896   09C9 CD 86 01     call str2lcd
1897   09CC 3E 40        ld a,Line2
1898   09CE CD C7 01     call setDDRAMa
1899   09D1 06 3E        ld b,'>'
1900   09D3 CD 3F 01     call char2lcd
1901   09D6             ; Wait for user to give a command
1902   09D6             mcp_command:
1903   09D6 3E 80        ld a,FastKeyDelay
1904   09D8 32 20 EA     ld (key_delay),a
1905   09DB 21 00 00     ld hl,$0000
1906   09DE 22 22 EA     ld (key_repeatdelay),hl
1907   09E1 21 00 00     ld hl,$0000
1908   09E4 22 24 EA     ld (key_repeatrate),hl
1909   09E7 3E FF        ld a,$ff
1910   09E9 32 2A EA     ld (key_rset),a
1911   09EC             ;
1912   09EC             mcp_comloop:
1913   09EC CD 77 02     call key_getkey
1914   09EF             ; Now test which key was pressed
1915   09EF FE 17        cp Enter
1916   09F1 CA 5C 0A     jp z,mcp_Enter
1917   09F4 FE 10        cp CK0
1918   09F6 C2 01 0A     jp nz,mcp_nhelp
1919   09F9 21 D5 0F     ld hl,s_help
1920   09FC 0E 10        ld c,CK0
1921   09FE C3 44 0A     jp mcp_str2lcd
1922   0A01             mcp_nhelp:
1923   0A01 FE 11        cp CK1
1924   0A03 C2 0E 0A     jp nz,mcp_nhexedit
1925   0A06 21 DB 0F     ld hl,s_hexedit
1926   0A09 0E 11        ld c,CK1
1927   0A0B C3 44 0A     jp mcp_str2lcd
1928   0A0E             mcp_nhexedit:
1929   0A0E FE 12        cp CK2
1930   0A10 C2 1B 0A     jp nz,mcp_nuptime
1931   0A13 21 EF 0F     ld hl,s_viewuptime
1932   0A16 0E 12        ld c,CK2
1933   0A18 C3 44 0A     jp mcp_str2lcd
1934   0A1B             mcp_nuptime:
1935   0A1B FE 13        cp CK3
1936   0A1D C2 28 0A     jp nz,mcp_nlogs
1937   0A20 21 E4 0F     ld hl,s_viewlogs
1938   0A23 0E 13        ld c,CK3
1939   0A25 C3 44 0A     jp mcp_str2lcd
1940   0A28             mcp_nlogs:
1941   0A28             ;
1942   0A28 3E 40        ld a,Line2
1943   0A2A CD C7 01     call setDDRAMa
1944   0A2D 06 3E        ld b,'>'
1945   0A2F CD 3F 01     call char2lcd
1946   0A32 21 FC 0F     ld hl,s_clearline
1947   0A35 0E 13        ld c,19
1948   0A37 CD 97 01     call strn2lcd
1949   0A3A 3E 41        ld a,Line2+1
1950   0A3C CD C7 01     call setDDRAMa
1951   0A3F 0E FF        ld c,none
1952   0A41 C3 EC 09     jp mcp_comloop
1953   0A44             ;
1954   0A44             mcp_str2lcd:
1955   0A44 EB           ex de,hl
1956   0A45 3E 40        ld a,Line2
1957   0A47 CD C7 01     call setDDRAMa
1958   0A4A 21 FC 0F     ld hl,s_clearline
1959   0A4D CD 86 01     call str2lcd
1960   0A50 3E 40        ld a,Line2
1961   0A52 CD C7 01     call setDDRAMa
1962   0A55 EB           ex de,hl
1963   0A56 CD 86 01     call str2lcd
1964   0A59 C3 EC 09     jp mcp_comloop
1965   0A5C             ; ***
1966   0A5C             mcp_Enter
1967   0A5C 79           ld a,c
1968   0A5D FE FF        cp none
1969   0A5F CA D6 09     jp z,mcp_command
1970   0A62 0E FF        ld c,none
1971   0A64 FE 10        cp CK0
1972   0A66 CA 7B 0A     jp z,mcp_help
1973   0A69 FE 11        cp CK1
1974   0A6B CA 84 0A     jp z,mcp_hexedit
1975   0A6E FE 12        cp CK2
1976   0A70 CA 8A 0A     jp z,mcp_viewuptime
1977   0A73 FE 13        cp CK3
1978   0A75 CA 90 0A     jp z,mcp_viewlogs
1979   0A78 C3 EC 09     jp mcp_comloop
1980   0A7B             ; ***
1981   0A7B             mcp_help:
1982   0A7B 21 3B 10     ld hl,s_helptext
1983   0A7E CD 96 0A     call help_read
1984   0A81 C3 B9 09     jp mcp_start
1985   0A84             mcp_hexedit:
1986   0A84 CD 52 0B     call hexedit
1987   0A87 C3 B9 09     jp mcp_start
1988   0A8A             mcp_viewuptime:
1989   0A8A CD B3 0E     call ViewUptime
1990   0A8D C3 B9 09     jp mcp_start
1991   0A90             mcp_viewlogs:
1992   0A90 CD 2A 0E     call ViewLogs
1993   0A93 C3 B9 09     jp mcp_start
1994   0A96             ; *** help_read
1995   0A96             ; Help reader
1996   0A96             help_read:
1997   0A96 CD 5B 01     call reset_lcd
1998   0A99 F5           push af
1999   0A9A D5           push de
2000   0A9B 22 00 EA     ld (T0),hl
2001   0A9E             ;
2002   0A9E 3E 00        ld a,Line1
2003   0AA0 CD C7 01     call setDDRAMa
2004   0AA3 CD 86 01     call str2lcd
2005   0AA6 23           inc hl
2006   0AA7 7E           ld a,(hl)
2007   0AA8 16 02        ld d,$02
2008   0AAA FE 17        cp $17
2009   0AAC 28 13        jr z,hr_start
2010   0AAE 3E 40        ld a,Line2
2011   0AB0 CD C7 01     call setDDRAMa
2012   0AB3 CD 86 01     call str2lcd
2013   0AB6 23           inc hl
2014   0AB7 7E           ld a,(hl)
2015   0AB8 CD 48 0B     call hr_dec21hl
2016   0ABB FE 17        cp $17
2017   0ABD 28 02        jr z,hr_start
2018   0ABF 16 01        ld d,$01
2019   0AC1             hr_start:
2020   0AC1 3E 17        ld a,Enter
2021   0AC3 32 1E EA     ld (key_pressed),a
2022   0AC6 3E 20        ld a,$20
2023   0AC8 32 20 EA     ld (key_delay),a
2024   0ACB E5           push hl
2025   0ACC 2A 32 EA     ld hl,(RepeatDelay)
2026   0ACF 22 22 EA     ld (key_repeatdelay),hl
2027   0AD2 2A 34 EA     ld hl,(RepeatRate)
2028   0AD5 22 24 EA     ld (key_repeatrate),hl
2029   0AD8 E1           pop hl
2030   0AD9 3E FF        ld a,$ff
2031   0ADB 32 2A EA     ld (key_rset),a
2032   0ADE             ;
2033   0ADE             hr_loop:
2034   0ADE CD 77 02     call key_getkey
2035   0AE1             ; Now test which key was pressed
2036   0AE1 FE 17        cp Enter
2037   0AE3 CA 4F 0B     jp z,hr_end
2038   0AE6 FE 11        cp CK1
2039   0AE8 CA 2D 0B     jp z,hr_rollup
2040   0AEB FE 13        cp CK3
2041   0AED CA F3 0A     jp z,hr_rolldown
2042   0AF0 C3 DE 0A     jp hr_loop
2043   0AF3             ;
2044   0AF3             hr_rolldown:
2045   0AF3 3E 02        ld a,$02
2046   0AF5 BA           cp d
2047   0AF6 28 32        jr z,hr_rd_end
2048   0AF8             hr_rd_ru:
2049   0AF8 3E 00        ld a,Line1
2050   0AFA CD C7 01     call setDDRAMa
2051   0AFD CD 86 01     call str2lcd
2052   0B00 23           inc hl
2053   0B01 7E           ld a,(hl)
2054   0B02 16 02        ld d,$02
2055   0B04 FE 17        cp $17
2056   0B06 20 0F        jr nz,hr_rd_jp
2057   0B08 E5           push hl
2058   0B09 21 11 10     ld hl,s_endof
2059   0B0C 3E 40        ld a,Line2
2060   0B0E CD C7 01     call setDDRAMa
2061   0B11 CD 86 01     call str2lcd
2062   0B14 E1           pop hl
2063   0B15 18 13        jr hr_rd_end
2064   0B17             hr_rd_jp:
2065   0B17 3E 40        ld a,Line2
2066   0B19 CD C7 01     call setDDRAMa
2067   0B1C CD 86 01     call str2lcd
2068   0B1F 23           inc hl
2069   0B20 7E           ld a,(hl)
2070   0B21 CD 48 0B     call hr_dec21hl
2071   0B24 FE 17        cp $17
2072   0B26 28 02        jr z,hr_rd_end
2073   0B28 16 01        ld d,$01
2074   0B2A             hr_rd_end:
2075   0B2A C3 DE 0A     jp hr_loop
2076   0B2D             ;
2077   0B2D             hr_rollup:
2078   0B2D 1E 02        ld e,2
2079   0B2F             hr_ru_uploop:
2080   0B2F 3A 01 EA     ld a,(T1)
2081   0B32 BC           cp h
2082   0B33 20 07        jr nz,hr_ru_nu
2083   0B35 3A 00 EA     ld a,(T0)
2084   0B38 BD           cp l
2085   0B39 CA 45 0B     jp z,hr_ru_end
2086   0B3C             hr_ru_nu:
2087   0B3C CD 48 0B     call hr_dec21hl
2088   0B3F 1D           dec e
2089   0B40 20 ED        jr nz,hr_ru_uploop
2090   0B42 C3 F8 0A     jp hr_rd_ru
2091   0B45             hr_ru_end:
2092   0B45 C3 DE 0A     jp hr_loop
2093   0B48             hr_dec21hl:
2094   0B48 3E 15        ld a,21
2095   0B4A             hr_dec21hl_loop:
2096   0B4A 2B           dec hl
2097   0B4B 3D           dec a
2098   0B4C 20 FC        jr nz,hr_dec21hl_loop
2099   0B4E C9           ret
2100   0B4F             ;
2101   0B4F             hr_end:
2102   0B4F D1           pop de
2103   0B50 F1           pop af
2104   0B51 C9           ret
2105   0B52             ; end of help_read
2106   0B52             
2107   0B52             ; *** hexedit
2108   0B52             ; Hex editor
2109   0B52             hexedit:
2110   0B52 F5           push af
2111   0B53 C5           push bc
2112   0B54 D5           push de
2113   0B55 E5           push hl
2114   0B56             ;
2115   0B56 3A 08 EA     ld a,(b_he_addset)
2116   0B59 FE 17        cp $17
2117   0B5B 28 1D        jr z,he_addset
2118   0B5D 21 00 E0     ld hl,UMO
2119   0B60 22 10 EA     ld (w_he_jumpaddr),hl
2120   0B63 22 13 EA     ld (w_he_calladdr),hl
2121   0B66 2B           dec hl
2122   0B67 2B           dec hl
2123   0B68 22 06 EA     ld (w_he_address),hl
2124   0B6B 3E 17        ld a,$17
2125   0B6D 32 08 EA     ld (b_he_addset),a
2126   0B70 3E 00        ld a,$00
2127   0B72 32 0F EA     ld (b_he_input),a
2128   0B75 3E 00        ld a,$00
2129   0B77 32 0E EA     ld (b_he_output),a
2130   0B7A             he_addset:
2131   0B7A CD 7E 01     call clear_lcd
2132   0B7D 3E 00        ld a,Line1
2133   0B7F CD C7 01     call setDDRAMa
2134   0B82 21 07 13     ld hl,s_he_string
2135   0B85 CD 86 01     call str2lcd
2136   0B88 3E 40        ld a,Line2
2137   0B8A CD C7 01     call setDDRAMa
2138   0B8D 21 26 10     ld hl,s_enter
2139   0B90 CD 86 01     call str2lcd
2140   0B93             ; Wait for Enter-key be pressed
2141   0B93 3E 17        ld a,Enter
2142   0B95 32 1E EA     ld (key_pressed),a
2143   0B98 3E 10        ld a,$10
2144   0B9A 32 20 EA     ld (key_delay),a
2145   0B9D 21 00 00     ld hl,$0000
2146   0BA0 22 22 EA     ld (key_repeatdelay),hl
2147   0BA3 21 00 00     ld hl,$0000
2148   0BA6 22 24 EA     ld (key_repeatrate),hl
2149   0BA9 3E FF        ld a,$ff
2150   0BAB 32 2A EA     ld (key_rset),a
2151   0BAE             he_swaitEnter:
2152   0BAE CD 77 02     call key_getkey
2153   0BB1 FE 17        cp Enter
2154   0BB3 20 F9        jr nz,he_swaitEnter
2155   0BB5 3E 17        ld a,Enter
2156   0BB7             he_start:
2157   0BB7 32 1E EA     ld (key_pressed),a
2158   0BBA 3E 01        ld a,1
2159   0BBC 32 0D EA     ld (b_he_nibble),a
2160   0BBF CD 7E 01     call clear_lcd
2161   0BC2 06 0E        ld b,%00001110         ; This sets cursor on and cursor blinking off
2162   0BC4 CD 25 01     call set_lcd
2163   0BC7 2A 06 EA     ld hl,(w_he_address)
2164   0BCA CD C9 0D     call he_showmemory
2165   0BCD 3E 10        ld a,$10
2166   0BCF 32 20 EA     ld (key_delay),a
2167   0BD2 2A 32 EA     ld hl,(RepeatDelay)
2168   0BD5 22 22 EA     ld (key_repeatdelay),hl
2169   0BD8 2A 34 EA     ld hl,(RepeatRate)
2170   0BDB 22 24 EA     ld (key_repeatrate),hl
2171   0BDE 3E FF        ld a,$ff
2172   0BE0 32 2A EA     ld (key_rset),a
2173   0BE3             ;
2174   0BE3             he_loop:
2175   0BE3 CD 77 02     call key_getkey
2176   0BE6             ; Now test which key was pressed
2177   0BE6 FE 10        cp $10
2178   0BE8 DA 0E 0D     jp c,he_change
2179   0BEB FE 17        cp Enter
2180   0BED CA 25 0E     jp z,he_end
2181   0BF0 FE 10        cp CK0
2182   0BF2 C2 FE 0B     jp nz,he_nhelp
2183   0BF5 CD 6A 02     call key_testshift
2184   0BF8 CA AD 0C     jp z,he_help
2185   0BFB C3 8B 0D     jp he_setaddress
2186   0BFE             he_nhelp:
2187   0BFE FE 11        cp CK1
2188   0C00 C2 0C 0C     jp nz,he_nrollup
2189   0C03 CD 6A 02     call key_testshift
2190   0C06 CA E0 0C     jp z,he_rollup4
2191   0C09 C3 B8 0C     jp he_rollup
2192   0C0C             he_nrollup:
2193   0C0C FE 13        cp CK3
2194   0C0E C2 1A 0C     jp nz,he_nrolldown
2195   0C11 CD 6A 02     call key_testshift
2196   0C14 CA F7 0C     jp z,he_rolldown4
2197   0C17 C3 CC 0C     jp he_rolldown
2198   0C1A             he_nrolldown:
2199   0C1A FE 15        cp CK5
2200   0C1C CA 64 0D     jp z,he_undo
2201   0C1F FE 12        cp CK2
2202   0C21 C2 2D 0C     jp nz,he_noutput
2203   0C24 CD 6A 02     call key_testshift
2204   0C27 CA 9D 0D     jp z,he_jump
2205   0C2A C3 3E 0C     jp he_output
2206   0C2D             he_noutput:
2207   0C2D FE 14        cp CK4
2208   0C2F C2 3B 0C     jp nz,he_ninput
2209   0C32 CD 6A 02     call key_testshift
2210   0C35 CA A9 0D     jp z,he_call
2211   0C38 C3 74 0C     jp he_input
2212   0C3B             he_ninput:
2213   0C3B C3 E3 0B     jp he_loop
2214   0C3E             ; Ouput given value to given I/O-address
2215   0C3E             he_output:
2216   0C3E C5           push bc
2217   0C3F 4F           ld c,a
2218   0C40 3A 0E EA     ld a,(b_he_output)
2219   0C43 47           ld b,a
2220   0C44 79           ld a,c
2221   0C45 F5           push af
2222   0C46 E5           push hl
2223   0C47 CD 7E 01     call clear_lcd
2224   0C4A 3E 00        ld a,Line1
2225   0C4C CD C7 01     call setDDRAMa
2226   0C4F 21 40 13     ld hl,s_inputioaddr
2227   0C52 CD 86 01     call str2lcd
2228   0C55 E1           pop hl
2229   0C56 F1           pop af
2230   0C57 CD 1C 03     call key_getbvalue
2231   0C5A FE 15        cp CK5
2232   0C5C 28 12        jr z,he_op_end
2233   0C5E 48           ld c,b
2234   0C5F F5           push af
2235   0C60 78           ld a,b
2236   0C61 32 0E EA     ld (b_he_output),a
2237   0C64 F1           pop af
2238   0C65 06 00        ld b,$00
2239   0C67 CD 0A 03     call key_getbyte
2240   0C6A FE 15        cp CK5
2241   0C6C 28 02        jr z,he_op_end
2242   0C6E ED 41        out (c),b
2243   0C70             he_op_end:
2244   0C70 C1           pop bc
2245   0C71 C3 B7 0B     jp he_start
2246   0C74             ; Input value from given I/O-address
2247   0C74             he_input:
2248   0C74 C5           push bc
2249   0C75 4F           ld c,a
2250   0C76 3A 0F EA     ld a,(b_he_input)
2251   0C79 47           ld b,a
2252   0C7A 79           ld a,c
2253   0C7B F5           push af
2254   0C7C E5           push hl
2255   0C7D CD 7E 01     call clear_lcd
2256   0C80 3E 00        ld a,Line1
2257   0C82 CD C7 01     call setDDRAMa
2258   0C85 21 40 13     ld hl,s_inputioaddr
2259   0C88 CD 86 01     call str2lcd
2260   0C8B E1           pop hl
2261   0C8C F1           pop af
2262   0C8D CD 1C 03     call key_getbvalue
2263   0C90 FE 15        cp CK5
2264   0C92 28 15        jr z,he_ip_end
2265   0C94 48           ld c,b
2266   0C95 47           ld b,a
2267   0C96 79           ld a,c
2268   0C97 32 0F EA     ld (b_he_input),a
2269   0C9A ED 78        in a,(c)
2270   0C9C 0E 03        ld c,SSeg3
2271   0C9E B7           or a
2272   0C9F CD CB 00     call b_to_7seg
2273   0CA2 3E FF        ld a,$ff
2274   0CA4 D3 01        out (SSeg1),a
2275   0CA6 D3 02        out (SSeg2),a
2276   0CA8 78           ld a,b
2277   0CA9             he_ip_end:
2278   0CA9 C1           pop bc
2279   0CAA C3 B7 0B     jp he_start
2280   0CAD             ; Show Hex editor's help
2281   0CAD             he_help:
2282   0CAD 21 62 11     ld hl,s_he_help
2283   0CB0 CD 96 0A     call help_read
2284   0CB3 3E 17        ld a,Enter
2285   0CB5 C3 B7 0B     jp he_start
2286   0CB8             ; Roll memory up
2287   0CB8             he_rollup:
2288   0CB8 E5           push hl
2289   0CB9 2A 06 EA     ld hl,(w_he_address)
2290   0CBC 2B           dec hl
2291   0CBD 22 06 EA     ld (w_he_address),hl
2292   0CC0 3E 01        ld a,1
2293   0CC2 32 0D EA     ld (b_he_nibble),a
2294   0CC5 CD C9 0D     call he_showmemory
2295   0CC8 E1           pop hl
2296   0CC9 C3 E3 0B     jp he_loop
2297   0CCC             ; Roll memory down
2298   0CCC             he_rolldown:
2299   0CCC E5           push hl
2300   0CCD 2A 06 EA     ld hl,(w_he_address)
2301   0CD0 23           inc hl
2302   0CD1 22 06 EA     ld (w_he_address),hl
2303   0CD4 3E 01        ld a,1
2304   0CD6 32 0D EA     ld (b_he_nibble),a
2305   0CD9 CD C9 0D     call he_showmemory
2306   0CDC E1           pop hl
2307   0CDD C3 E3 0B     jp he_loop
2308   0CE0             ; Roll memory up by 4
2309   0CE0             he_rollup4:
2310   0CE0 E5           push hl
2311   0CE1 2A 06 EA     ld hl,(w_he_address)
2312   0CE4 2B           dec hl
2313   0CE5 2B           dec hl
2314   0CE6 2B           dec hl
2315   0CE7 2B           dec hl
2316   0CE8 22 06 EA     ld (w_he_address),hl
2317   0CEB 3E 01        ld a,1
2318   0CED 32 0D EA     ld (b_he_nibble),a
2319   0CF0 CD C9 0D     call he_showmemory
2320   0CF3 E1           pop hl
2321   0CF4 C3 E3 0B     jp he_loop
2322   0CF7             ; Roll memory down by 4
2323   0CF7             he_rolldown4:
2324   0CF7 E5           push hl
2325   0CF8 2A 06 EA     ld hl,(w_he_address)
2326   0CFB 23           inc hl
2327   0CFC 23           inc hl
2328   0CFD 23           inc hl
2329   0CFE 23           inc hl
2330   0CFF 22 06 EA     ld (w_he_address),hl
2331   0D02 3E 01        ld a,1
2332   0D04 32 0D EA     ld (b_he_nibble),a
2333   0D07 CD C9 0D     call he_showmemory
2334   0D0A E1           pop hl
2335   0D0B C3 E3 0B     jp he_loop
2336   0D0E             ; Change memory
2337   0D0E             he_change:
2338   0D0E E5           push hl
2339   0D0F C5           push bc
2340   0D10 2A 06 EA     ld hl,(w_he_address)
2341   0D13 23           inc hl
2342   0D14 23           inc hl
2343   0D15 46           ld b,(hl)
2344   0D16 4F           ld c,a
2345   0D17             ;
2346   0D17 3A 0D EA     ld a,(b_he_nibble)
2347   0D1A FE 00        cp 0
2348   0D1C 20 18        jr nz,he_ch_n0
2349   0D1E 78           ld a,b
2350   0D1F 32 09 EA     ld (b_he_undovalue),a
2351   0D22 22 0A EA     ld (w_he_undoaddr),hl
2352   0D25 E6 F0        and $f0
2353   0D27 47           ld b,a
2354   0D28 79           ld a,c
2355   0D29 E6 0F        and $0f
2356   0D2B B0           or b
2357   0D2C 77           ld (hl),a
2358   0D2D 3E 01        ld a,1
2359   0D2F 32 0D EA     ld (b_he_nibble),a
2360   0D32 23           inc hl
2361   0D33 C3 52 0D     jp he_ch_end
2362   0D36             he_ch_n0:
2363   0D36 78           ld a,b
2364   0D37 32 09 EA     ld (b_he_undovalue),a
2365   0D3A 22 0A EA     ld (w_he_undoaddr),hl
2366   0D3D E6 0F        and $0f
2367   0D3F 47           ld b,a
2368   0D40 79           ld a,c
2369   0D41 CB 27        sla a
2370   0D43 CB 27        sla a
2371   0D45 CB 27        sla a
2372   0D47 CB 27        sla a
2373   0D49 E6 F0        and $f0
2374   0D4B B0           or b
2375   0D4C 77           ld (hl),a
2376   0D4D 3E 00        ld a,0
2377   0D4F 32 0D EA     ld (b_he_nibble),a
2378   0D52             he_ch_end:
2379   0D52 3E 00        ld a,$00
2380   0D54 32 0C EA     ld (b_he_undoset),a
2381   0D57 2B           dec hl
2382   0D58 2B           dec hl
2383   0D59 22 06 EA     ld (w_he_address),hl
2384   0D5C CD C9 0D     call he_showmemory
2385   0D5F C1           pop bc
2386   0D60 E1           pop hl
2387   0D61 C3 E3 0B     jp he_loop
2388   0D64             ; Undo
2389   0D64             he_undo
2390   0D64 E5           push hl
2391   0D65 2A 0A EA     ld hl,(w_he_undoaddr)
2392   0D68 3A 0C EA     ld a,(b_he_undoset)
2393   0D6B FE FF        cp $ff
2394   0D6D 28 10        jr z,he_un_end
2395   0D6F C5           push bc
2396   0D70 3A 09 EA     ld a,(b_he_undovalue)
2397   0D73 46           ld b,(hl)
2398   0D74 77           ld (hl),a
2399   0D75 78           ld a,b
2400   0D76 32 09 EA     ld (b_he_undovalue),a
2401   0D79 3E 01        ld a,1
2402   0D7B 32 0D EA     ld (b_he_nibble),a
2403   0D7E C1           pop bc
2404   0D7F             he_un_end
2405   0D7F 2B           dec hl
2406   0D80 2B           dec hl
2407   0D81 22 06 EA     ld (w_he_address),hl
2408   0D84 CD C9 0D     call he_showmemory
2409   0D87 E1           pop hl
2410   0D88 C3 E3 0B     jp he_loop
2411   0D8B             ; Set address
2412   0D8B             he_setaddress:
2413   0D8B E5           push hl
2414   0D8C 2A 06 EA     ld hl,(w_he_address)
2415   0D8F 23           inc hl
2416   0D90 23           inc hl
2417   0D91 CD E1 03     call key_getaddress
2418   0D94 2B           dec hl
2419   0D95 2B           dec hl
2420   0D96 22 06 EA     ld (w_he_address),hl
2421   0D99 E1           pop hl
2422   0D9A C3 B7 0B     jp he_start
2423   0D9D             ; Jump to address
2424   0D9D             he_jump:
2425   0D9D 2A 10 EA     ld hl,(w_he_jumpaddr)
2426   0DA0 CD E1 03     call key_getaddress
2427   0DA3 FE 15        cp CK5
2428   0DA5 CA B7 0B     jp z,he_start
2429   0DA8 E9           jp (hl)
2430   0DA9             ; Call to address
2431   0DA9             he_call:
2432   0DA9 F5           push af
2433   0DAA E5           push hl
2434   0DAB 2A 13 EA     ld hl,(w_he_calladdr)
2435   0DAE CD E1 03     call key_getaddress
2436   0DB1 FE 15        cp CK5
2437   0DB3 28 0C        jr z,he_call_end
2438   0DB5 22 13 EA     ld (w_he_calladdr),hl
2439   0DB8 3A C6 0D     ld a,(he_call_jumpcmd)
2440   0DBB 32 12 EA     ld (b_he_calljump),a
2441   0DBE CD 12 EA     call b_he_calljump
2442   0DC1             he_call_end:
2443   0DC1 E1           pop hl
2444   0DC2 F1           pop af
2445   0DC3 C3 B7 0B     jp he_start
2446   0DC6             he_call_jumpcmd:
2447   0DC6 C3 00 00     jp $0000
2448   0DC9             ; Show 4bytes of memory contents, start address in hl
2449   0DC9             he_showmemory:
2450   0DC9 F5           push af
2451   0DCA C5           push bc
2452   0DCB             ;
2453   0DCB CD 7E 01     call clear_lcd
2454   0DCE 3E 00        ld a,Line1
2455   0DD0 CD C7 01     call setDDRAMa
2456   0DD3 CD F7 0D     call he_sm_show
2457   0DD6 2B           dec hl
2458   0DD7 2B           dec hl
2459   0DD8 46           ld b,(hl)
2460   0DD9 CD 3F 01     call char2lcd
2461   0DDC 23           inc hl
2462   0DDD 46           ld b,(hl)
2463   0DDE CD 3F 01     call char2lcd
2464   0DE1 23           inc hl
2465   0DE2 46           ld b,(hl)
2466   0DE3 CD 3F 01     call char2lcd
2467   0DE6 23           inc hl
2468   0DE7 46           ld b,(hl)
2469   0DE8 CD 3F 01     call char2lcd
2470   0DEB 2B           dec hl
2471   0DEC             
2472   0DEC 3E 40        ld a,Line2
2473   0DEE CD C7 01     call setDDRAMa
2474   0DF1 CD F7 0D     call he_sm_show
2475   0DF4             
2476   0DF4 C3 14 0E     jp he_sm_end
2477   0DF7             ;
2478   0DF7             he_sm_show:
2479   0DF7 0E 02        ld c,2
2480   0DF9             he_sm_loop:
2481   0DF9 7C           ld a,h
2482   0DFA CD FE 00     call byte2lcd
2483   0DFD 7D           ld a,l
2484   0DFE CD FE 00     call byte2lcd
2485   0E01 06 3A        ld b,':'
2486   0E03 CD 3F 01     call char2lcd
2487   0E06 7E           ld a,(hl)
2488   0E07 CD FE 00     call byte2lcd
2489   0E0A 06 20        ld b,' '
2490   0E0C CD 3F 01     call char2lcd
2491   0E0F 23           inc hl
2492   0E10 0D           dec c
2493   0E11 20 E6        jr nz,he_sm_loop
2494   0E13 C9           ret
2495   0E14             ;
2496   0E14             he_sm_end
2497   0E14 3A 0D EA     ld a,(b_he_nibble)
2498   0E17 47           ld b,a
2499   0E18 3E 46        ld a,Line2+6
2500   0E1A 90           sub b
2501   0E1B CD C7 01     call setDDRAMa
2502   0E1E 2B           dec hl
2503   0E1F 2B           dec hl
2504   0E20 2B           dec hl
2505   0E21 2B           dec hl
2506   0E22 C1           pop bc
2507   0E23 F1           pop af
2508   0E24 C9           ret
2509   0E25             ;
2510   0E25             he_end:
2511   0E25 E1           pop hl
2512   0E26 D1           pop de
2513   0E27 C1           pop bc
2514   0E28 F1           pop af
2515   0E29 C9           ret
2516   0E2A             ; end of hexedit
2517   0E2A             
2518   0E2A             ; *** ViewLogs
2519   0E2A             ViewLogs:
2520   0E2A F5           push af
2521   0E2B E5           push hl
2522   0E2C C5           push bc
2523   0E2D 3E 80        ld a,FastKeyDelay
2524   0E2F 32 20 EA     ld (key_delay),a
2525   0E32 CD 7E 01     call clear_lcd
2526   0E35 06 0C        ld b,%00001100         ; This sets cursor and cursor blinking off
2527   0E37 CD 25 01     call set_lcd
2528   0E3A 3A 3C EA     ld a,(logs_curid)
2529   0E3D FE 00        cp 0
2530   0E3F C2 53 0E     jp nz,vil_logsexist
2531   0E42 21 84 13     ld hl,s_nologs
2532   0E45 CD 86 01     call str2lcd
2533   0E48             vil_nwait:
2534   0E48 CD 77 02     call key_getkey
2535   0E4B FE 17        cp Enter
2536   0E4D C2 48 0E     jp nz,vil_nwait
2537   0E50 C3 AF 0E     jp vil_end
2538   0E53             vil_logsexist:
2539   0E53 3E 00        ld a,Line1
2540   0E55 CD C7 01     call setDDRAMa
2541   0E58 21 95 13     ld hl,s_viewslog
2542   0E5B CD 86 01     call str2lcd
2543   0E5E 3E 40        ld a,Line2
2544   0E60 CD C7 01     call setDDRAMa
2545   0E63 21 7D 13     ld hl,s_lognumber
2546   0E66 CD 86 01     call str2lcd
2547   0E69 0E 01        ld c,1
2548   0E6B             vil_selectloop:
2549   0E6B 3E 46        ld a,Line2+6
2550   0E6D CD C7 01     call setDDRAMa
2551   0E70 06 30        ld b,'0'
2552   0E72 79           ld a,c
2553   0E73 80           add a,b
2554   0E74 47           ld b,a
2555   0E75 CD 3F 01     call char2lcd
2556   0E78 CD 77 02     call key_getkey
2557   0E7B FE 11        cp CK1
2558   0E7D C2 88 0E     jp nz,vil_nCK1
2559   0E80 0D           dec c
2560   0E81 C2 6B 0E     jp nz,vil_selectloop
2561   0E84 0C           inc c
2562   0E85 C3 6B 0E     jp vil_selectloop
2563   0E88             vil_nCK1:
2564   0E88 FE 13        cp CK3
2565   0E8A C2 98 0E     jp nz,vil_nCK3
2566   0E8D 3A 3C EA     ld a,(logs_curid)
2567   0E90 B9           cp c
2568   0E91 CA 6B 0E     jp z,vil_selectloop
2569   0E94 0C           inc c
2570   0E95 C3 6B 0E     jp vil_selectloop
2571   0E98             vil_nCK3:
2572   0E98 FE 15        cp CK5
2573   0E9A C2 A0 0E     jp nz,vil_nCK5
2574   0E9D C3 AF 0E     jp vil_end
2575   0EA0             vil_nCK5:
2576   0EA0 FE 17        cp Enter
2577   0EA2 C2 6B 0E     jp nz,vil_selectloop
2578   0EA5 79           ld a,c
2579   0EA6 CD 40 06     call ViewLog
2580   0EA9 CD 7E 01     call clear_lcd
2581   0EAC C3 53 0E     jp vil_logsexist
2582   0EAF             vil_end:
2583   0EAF C1           pop bc
2584   0EB0 E1           pop hl
2585   0EB1 F1           pop af
2586   0EB2 C9           ret
2587   0EB3             ; end of ViewLogs
2588   0EB3             
2589   0EB3             ; *** ViewUptime
2590   0EB3             ViewUptime:
2591   0EB3 F5           push af
2592   0EB4 E5           push hl
2593   0EB5 C5           push bc
2594   0EB6 CD 7E 01     call clear_lcd
2595   0EB9 06 0C        ld b,%00001100         ; This sets cursor and cursor blinking off
2596   0EBB CD 25 01     call set_lcd
2597   0EBE 3E 00        ld a,Line1
2598   0EC0 CD C7 01     call setDDRAMa
2599   0EC3 21 5E 13     ld hl,s_uptime1
2600   0EC6 CD 86 01     call str2lcd
2601   0EC9             vu_wait:
2602   0EC9 3E 40        ld a,Line2
2603   0ECB CD C7 01     call setDDRAMa
2604   0ECE 3A 85 EB     ld a,(uptime+5)
2605   0ED1 CD FE 00     call byte2lcd
2606   0ED4 3A 84 EB     ld a,(uptime+4)
2607   0ED7 CD FE 00     call byte2lcd
2608   0EDA 3A 83 EB     ld a,(uptime+3)
2609   0EDD CD FE 00     call byte2lcd
2610   0EE0 06 64        ld b,'d'
2611   0EE2 CD 3F 01     call char2lcd
2612   0EE5 3A 82 EB     ld a,(uptime+2)
2613   0EE8 CD FE 00     call byte2lcd
2614   0EEB 06 68        ld b,'h'
2615   0EED CD 3F 01     call char2lcd
2616   0EF0 3A 81 EB     ld a,(uptime+1)
2617   0EF3 CD FE 00     call byte2lcd
2618   0EF6 06 6D        ld b,'m'
2619   0EF8 CD 3F 01     call char2lcd
2620   0EFB 3A 80 EB     ld a,(uptime+0)
2621   0EFE CD FE 00     call byte2lcd
2622   0F01 06 73        ld b,'s'
2623   0F03 CD 3F 01     call char2lcd
2624   0F06 CD D0 01     call key_scan
2625   0F09 21 1E EA     ld hl,key_pressed
2626   0F0C BE           cp (hl)
2627   0F0D CA C9 0E     jp z,vu_wait
2628   0F10 32 1E EA     ld (key_pressed),a
2629   0F13 FE 17        cp Enter
2630   0F15 C2 C9 0E     jp nz,vu_wait
2631   0F18 C1           pop bc
2632   0F19 E1           pop hl
2633   0F1A F1           pop af
2634   0F1B C9           ret
2635   0F1C             ; end of ViewUptime
2636   0F1C             
2637   0F1C             ; *** HandleNMI
2638   0F1C             HandleNMI:
2639   0F1C F3           di
2640   0F1D F5           push af
2641   0F1E C5           push bc
2642   0F1F E5           push hl
2643   0F20 3E B1        ld a,%10110001
2644   0F22 D3 A3        out (CounterC),a
2645   0F24 3E 96        ld a,$96
2646   0F26 D3 A2        out (Counter2),a
2647   0F28 3E 99        ld a,$99
2648   0F2A D3 A2        out (Counter2),a
2649   0F2C 3A 80 EB     ld a,(uptime)
2650   0F2F C6 01        add a,1
2651   0F31 27           daa
2652   0F32 32 80 EB     ld (uptime),a
2653   0F35 FE 60        cp $60
2654   0F37 C2 87 0F     jp nz,hn_incupend
2655   0F3A AF           xor a
2656   0F3B 32 80 EB     ld (uptime),a
2657   0F3E 3A 81 EB     ld a,(uptime+1)
2658   0F41 C6 01        add a,1
2659   0F43 27           daa
2660   0F44 32 81 EB     ld (uptime+1),a
2661   0F47 FE 60        cp $60
2662   0F49 C2 87 0F     jp nz,hn_incupend
2663   0F4C AF           xor a
2664   0F4D 32 81 EB     ld (uptime+1),a
2665   0F50 3A 82 EB     ld a,(uptime+2)
2666   0F53 C6 01        add a,1
2667   0F55 27           daa
2668   0F56 32 82 EB     ld (uptime+2),a
2669   0F59 FE 24        cp $24
2670   0F5B C2 87 0F     jp nz,hn_incupend
2671   0F5E AF           xor a
2672   0F5F 32 82 EB     ld (uptime+2),a
2673   0F62 3A 83 EB     ld a,(uptime+3)
2674   0F65 C6 01        add a,1
2675   0F67 27           daa
2676   0F68 32 83 EB     ld (uptime+3),a
2677   0F6B FE 00        cp $00
2678   0F6D C2 87 0F     jp nz,hn_incupend
2679   0F70 3A 84 EB     ld a,(uptime+4)
2680   0F73 C6 01        add a,1
2681   0F75 27           daa
2682   0F76 32 84 EB     ld (uptime+4),a
2683   0F79 FE 00        cp $00
2684   0F7B C2 87 0F     jp nz,hn_incupend
2685   0F7E 3A 85 EB     ld a,(uptime+5)
2686   0F81 C6 01        add a,1
2687   0F83 27           daa
2688   0F84 32 85 EB     ld (uptime+5),a
2689   0F87             hn_incupend:
2690   0F87 3A 86 EB     led_toggle(%00010000)
2690   0F8A EE 10       
2690   0F8C D3 07       
2690   0F8E 32 86 EB    
2691   0F91 E1           pop hl
2692   0F92 C1           pop bc
2693   0F93 F1           pop af
2694   0F94 FB           ei
2695   0F95 ED 45        retn
2696   0F97             ; end of HandleNMI
2697   0F97             
2698   0F97             ;**************************************************************
2699   0F97             ; Misc data, example character strings
2700   0F97 5A3830205765s_OSstring      .db "Z80 WestOS, by Duge",EOL
2700   0F9D 73744F532C206279204475676517
2701   0FAB 76657273696Fs_version       .db "version b0.70",EOL
2701   0FB1 6E2062302E373017
2702   0FB9 435055206861s_halted        .db "CPU halted.",EOL
2702   0FBF 6C7465642E17
2703   0FC5 496E70757420s_defprompt     .db "Input  command:",EOL
2703   0FCB 20636F6D6D616E643A17
2704   0FD5 3E68656C7017s_help          .db ">help",EOL
2705   0FDB 3E6865786564s_hexedit       .db ">hexedit",EOL
2705   0FE1 697417
2706   0FE4 3E7669657720s_viewlogs      .db ">view logs",EOL
2706   0FEA 6C6F677317
2707   0FEF 3E7669657720s_viewuptime    .db ">view uptime",EOL
2707   0FF5 757074696D6517
2708   0FFC 202020202020s_clearline     .db "                    ",EOL
2708   1002 202020202020202020202020202017
2709   1011 2A2D2D2D2D2Ds_endof         .db "*-------end--------*",EOL
2709   1017 2D2D656E642D2D2D2D2D2D2D2D2A17
2710   1026 507265737320s_enter         .db "Press Enter.........",EOL
2710   102C 456E7465722E2E2E2E2E2E2E2E2E17
2711   103B 235573652043s_helptext      .db "#Use CK1 and CK3 to ",EOL
2711   1041 4B3120616E6420434B3320746F2017
2712   1050 23726F6C6C20                .db "#roll up and down   ",EOL
2712   1056 757020616E6420646F776E20202017
2713   1065 434B303A2048                .db "CK0: Help           ",EOL
2713   106B 656C70202020202020202020202017
2714   107A 53686F772074                .db "Show this help      ",EOL
2714   1080 6869732068656C7020202020202017
2715   108F 434B313A2048                .db "CK1: Hexedit        ",EOL
2715   1095 657865646974202020202020202017
2716   10A4 4D656D6F7279                .db "Memory hex editor   ",EOL
2716   10AA 2068657820656469746F7220202017
2717   10B9 416C736F2066                .db "Also for I/O-usage  ",EOL
2717   10BF 6F7220492F4F2D7573616765202017
2718   10CE 434B323A2056                .db "CK2: View uptime    ",EOL
2718   10D4 69657720757074696D652020202017
2719   10E3 434B333A2056                .db "CK3: View logs      ",EOL
2719   10E9 696577206C6F677320202020202017
2720   10F8 53686966743A                .db "Shift:              ",EOL
2720   10FE 202020202020202020202020202017
2721   110D 557361676520                .db "Usage of Shift is   ",EOL
2721   1113 6F6620536869667420697320202017
2722   1122 6D61726B6564                .db "marked with ^X,     ",EOL
2722   1128 2077697468205E582C202020202017
2723   1137 776865726520                .db "where X is some key ",EOL
2723   113D 5820697320736F6D65206B65792017
2724   114C 235072657373                .db "#Press Enter to exit",EOL
2724   1152 20456E74657220746F206578697417
2725   1161 17                          .db EOL
2726   1162 2355703A434Bs_he_help       .db "#Up:CK1 Down:CK3    ",EOL
2726   1168 3120446F776E3A434B332020202017
2727   1177 456E7465723A                .db "Enter: Exit hexedit ",EOL
2727   117D 204578697420686578656469742017
2728   118C 434B303A2043                .db "CK0: Choose address ",EOL
2728   1192 686F6F736520616464726573732017
2729   11A1 434B323A2049                .db "CK2: I/O output     ",EOL
2729   11A7 2F4F206F7574707574202020202017
2730   11B6 5E434B323A20                .db "^CK2: Jump to n     ",EOL
2730   11BC 4A756D7020746F206E202020202017
2731   11CB 434B343A2049                .db "CK4: I/O input      ",EOL
2731   11D1 2F4F20696E70757420202020202017
2732   11E0 5E434B343A20                .db "^CK4: Call to n     ",EOL
2732   11E6 43616C6C20746F206E202020202017
2733   11F5 416674657220                .db "After this command  ",EOL
2733   11FB 7468697320636F6D6D616E64202017
2734   120A 746865207661                .db "the value read from ",EOL
2734   1210 6C756520726561642066726F6D2017
2735   121F 676976656E20                .db "given port is seen  ",EOL
2735   1225 706F7274206973207365656E202017
2736   1234 696E20377365                .db "in 7segments as hex.",EOL
2736   123A 676D656E7473206173206865782E17
2737   1249 434B313A2052                .db "CK1: Roll memory up ",EOL
2737   124F 6F6C6C206D656D6F72792075702017
2738   125E 5E434B313A20                .db "^CK1: Up by 4       ",EOL
2738   1264 557020627920342020202020202017
2739   1273 434B333A2052                .db "CK3: Roll mem. down ",EOL
2739   1279 6F6C6C206D656D2E20646F776E2017
2740   1288 5E434B333A20                .db "^CK3: Down by 4     ",EOL
2740   128E 446F776E2062792034202020202017
2741   129D 434B353A2055                .db "CK5: Undo           ",EOL
2741   12A3 6E646F202020202020202020202017
2742   12B2 556E646F2069                .db "Undo in most cases. ",EOL
2742   12B8 6E206D6F73742063617365732E2017
2743   12C7 302D463A2043                .db "0-F: Change memory  ",EOL
2743   12CD 68616E6765206D656D6F7279202017
2744   12DC 5E434B303A20                .db "^CK0: Help          ",EOL
2744   12E2 48656C702020202020202020202017
2745   12F1 235072657373                .db "#Press Enter to exit",EOL
2745   12F7 20456E74657220746F206578697417
2746   1306 17                          .db EOL
2747   1307 576573744F53s_he_string     .db "WestOS Hexedit v0.25",EOL
2747   130D 20486578656469742076302E323517
2748   131C 476976652061s_inputaddress  .db "Give address:",EOL
2748   1322 6464726573733A17
2749   132A 476976652077s_inputword     .db "Give word:",EOL
2749   1330 6F72643A17
2750   1335 476976652062s_inputbyte     .db "Give byte:",EOL
2750   133B 7974653A17
2751   1340 476976652049s_inputioaddr   .db "Give I/O-address:",EOL
2751   1346 2F4F2D616464726573733A17
2752   1352 476976652064s_inputdelay    .db "Give delay:",EOL
2752   1358 656C61793A17
2753   135E 53797374656Ds_uptime1       .db "System uptime:",EOL
2753   1364 20757074696D653A17
2754   136D 303030303064s_uptime2       .db "00000d00h00m00s",EOL
2754   1373 30306830306D30307317
2755   137D 3E4C6F672023s_lognumber     .db ">Log #",EOL
2755   1383 17
2756   1384 4E6F206C6F67s_nologs        .db "No logs created.",EOL
2756   138A 7320637265617465642E17
2757   1395 56696577206Cs_viewslog      .db "View log:",EOL
2757   139B 6F673A17
2758   139F 5A3830205765s_SysFirst      .db "Z80 WestOS b0.70 by Duge.",LOGSP,EOL
2758   13A5 73744F532062302E373020627920447567652EFF17
2759   13BA 537461727469s_SysStartUp    .db "Starting up..",LOGSP,EOL
2759   13C0 6E672075702E2EFF17
2760   13C9 50726F62696Es_SysProbeNIC   .db "Probing for NIC @ISA..",LOGSP,EOL
2760   13CF 6720666F72204E494320404953412E2EFF17
2761   13E1 4E494320666Fs_SysNICfound   .db "NIC found, see Net log(1).",LOGSP,EOL
2761   13E7 756E642C20736565204E6574206C6F672831292EFF17
2762   13FD 4E6F204E4943s_SysNoNIC      .db "No NIC found.",LOGSP,EOL
2762   1403 20666F756E642EFF17
2763   140C 476F696E6720s_SysModeS      .db "Going to start up-mode..",LOGSP,EOL
2763   1412 746F2073746172742075702D6D6F64652E2EFF17
2764   1426 435055206861s_SysHalt       .db "CPU halted.",LOGSP,EOL
2764   142C 6C7465642EFF17
2765   1433 435055207761s_SysHaltWake   .db "CPU waked up.",LOGSP,EOL
2765   1439 6B65642075702EFF17
2766   1442 303132333435hextolcd        .db '0','1','2','3','4','5','6','7','8','9'
2766   1448 36373839
2767   144C 414243444546                .db 'A','B','C','D','E','F'
2768   1452 81 B7 C2 92 hexto7segment   .db %10000001,%10110111,%11000010,%10010010
2769   1456 B4 98 88 B3                 .db %10110100,%10011000,%10001000,%10110011
2770   145A 80 90 A0 8C                 .db %10000000,%10010000,%10100000,%10001100
2771   145E C9 86 C8 E8                 .db %11001001,%10000110,%11001000,%11101000
2772   1462             ;**************************************************************
2773   1462             
2774   1462             #include "drivers.asm"
0001+  1462             ;**************************************************************
0002+  1462             ; Drivers
0003+  1462             ;.org $2000
0004+  1462             
0005+  1462             ; Enable some of these to use LEDs and 7segments for debugging
0006+  1462             #define DEBUG_DRIVERS   ; DEBUG when running drivers code
0007+  1462             
0008+  1462             ; Call-table for applications
0009+  1462             ethInit:
0010+  1462 C3 43 15     jp ethNICInit
0011+  1465             ethReset:
0012+  1465 E5           push hl
0013+  1466 2A BE EA     ld hl,(ejReset)
0014+  1469 E9           jp (hl)
0015+  146A             ethOpen:
0016+  146A E5           push hl
0017+  146B 2A C0 EA     ld hl,(ejOpen)
0018+  146E E9           jp (hl)
0019+  146F             ethEnable:
0020+  146F E5           push hl
0021+  1470 2A C2 EA     ld hl,(ejEnable)
0022+  1473 E9           jp (hl)
0023+  1474             ethDisable:
0024+  1474 E5           push hl
0025+  1475 2A C4 EA     ld hl,(ejDisable)
0026+  1478 E9           jp (hl)
0027+  1479             ethInterrupt:
0028+  1479 E5           push hl
0029+  147A 2A C6 EA     ld hl,(ejInterrupt)
0030+  147D E9           jp (hl)
0031+  147E             ethSend:
0032+  147E E5           push hl
0033+  147F 2A C8 EA     ld hl,(ejSend)
0034+  1482 E9           jp (hl)
0035+  1483             ;
0036+  1483             
0037+  1483             ; *******************************
0038+  1483             ; misc
0039+  1483             ; *******************************
0040+  1483             ;ethbase                 equ $40
0041+  1483             
0042+  1483             ; Ethernet NICs ID's
0043+  1483             NE1comp         equ $01
0044+  1483             NE2comp         equ $02
0045+  1483             NECcomp         equ $03
0046+  1483             NEBcomp         equ $04
0047+  1483             ; Coming... maybe.
0048+  1483             SMCultra        equ $11
0049+  1483             SMCEtherEZ      equ $12
0050+  1483             c3c509b         equ $21
0051+  1483             ;
0052+  1483             noNIC           equ $69
0053+  1483             
0054+  1483             eSending        equ $26
0055+  1483             eSended         equ $17
0056+  1483             eTimedOut       equ $69
0057+  1483             
0058+  1483             MAX_INTERRUPT_SERVICE   equ 10
0059+  1483             MAX_RECEIVE_SERVICE     equ 10
0060+  1483             
0061+  1483~            #ifdef CPU_AT_2MHZ
0062+  1483~            WaitForTimeout          equ 2800        ; Should be about 20ms
0063+  1483             #endif
0064+  1483             #ifdef CPU_AT_4MHZ
0065+  1483             WaitForTimeout          equ 5600        ; Should be about 20ms
0066+  1483             #endif
0067+  1483~            #ifdef CPU_AT_8MHZ
0068+  1483~            WaitForTimeout          equ 11200       ; Should be about 20ms
0069+  1483             #endif
0070+  1483             
0071+  1483 4E6F20457468s_NoNIC         .db "No Ethernet NIC",EOL
0071+  1489 65726E6574204E494317
0072+  1493 666F756E642E                .db "found.",EOL
0072+  1499 17
0073+  149A 50726F62696Es_NetProbeNIC   .db "Probing NIC...",EOL
0073+  14A0 67204E49432E2E2E17
0074+  14A9 4E6574204C6Fs_NetLogFirst   .db "Net Log Created.",LOGSP,EOL
0074+  14AF 6720437265617465642EFF17
0075+  14BB FF 17       s_LOGSP         .db LOGSP,EOL 
0076+  14BD FFFFFFFFFFFFtest_packet     .db $ff,$ff,$ff,$ff,$ff,$ff
0077+  14C3 004033389A42                .db $00,$40,$33,$38,$9a,$42
0078+  14C9 546573742070                .db "Test packet."
0078+  14CF 61636B65742E
0079+  14D5 53656E642062                .db "Send by Duge's Z80!!"
0079+  14DB 7920447567652773205A38302121
0080+  14E9 53656E642062                .db "Send by Duge's Z80!!"
0080+  14EF 7920447567652773205A38302121
0081+  14FD 53656E642062                .db "Send by Duge's Z80!!"
0081+  1503 7920447567652773205A38302121
0082+  1511 53656E642062                .db "Send by Duge's Z80!!"
0082+  1517 7920447567652773205A38302121
0083+  1525 080600010800                .db $08,$06,$00,$01,$08,$00
0084+  152B 060400010000                .db $06,$04,$00,$01,$00,$00
0085+  1531 000000176F70                .db $00,$00,$00,$17,$6f,$70
0086+  1537 711100000000                .db $71,$11,$00,$00,$00,$00
0087+  153D 00006F707163                .db $00,$00,$6f,$70,$71,$63
0088+  1543             
0089+  1543             ; *********************************
0090+  1543             ; some default routines for network
0091+  1543             ; *********************************
0092+  1543             ; ethNICInit
0093+  1543             ethNICInit:
0094+  1543 F3           di
0095+  1544 21 00 04     ld hl,1024
0096+  1547 CD 71 05     call CreateLog
0097+  154A 32 B5 EA     ld (NetLogId),a
0098+  154D 21 A9 14     ld hl,s_NetLogFirst
0099+  1550 CD BD 05     call AddLog
0100+  1553             ; Clear error counters
0101+  1553 21 00 00     ld hl,0
0102+  1556 22 E4 EA     ld (ethRxFrameErrs),hl ; rx frame errors
0103+  1559 22 E6 EA     ld (ethRxCrcErrs),hl   ; rx CRC errors
0104+  155C 22 E8 EA     ld (ethRxMissedErrs),hl; rx missed-errors
0105+  155F 22 EA EA     ld (ethTxCarrErrs),hl  ; tx carrier errors
0106+  1562 22 EC EA     ld (ethTxHBErrs),hl    ; tx heartbeat errors
0107+  1565 22 EE EA     ld (ethTxWindow),hl    ; tx window errors
0108+  1568 22 F0 EA     ld (ethRxOverErrs),hl  ; rx overrun errors
0109+  156B 22 F2 EA     ld (ethRxErrs),hl      ; rx errors      
0110+  156E 22 F4 EA     ld (ethRxFifoErrs),hl  ; rx fifo errors      
0111+  1571 22 F6 EA     ld (ethRxLenErrs),hl   ; rx fifo errors
0112+  1574 22 08 EB     ld (ethRxDropped),hl   ; rx dropped packets
0113+  1577             ;
0114+  1577 22 F8 EA     ld (ethRxPackets),hl   
0115+  157A 22 FA EA     ld (ethRxPackets+2),hl  
0116+  157D 22 FC EA     ld (ethTxPackets),hl      
0117+  1580 22 FE EA     ld (ethTxPackets+2),hl    
0118+  1583 22 00 EB     ld (ethRxBytes),hl    
0119+  1586 22 02 EB     ld (ethRxBytes+2),hl    
0120+  1589 22 04 EB     ld (ethTxBytes),hl        
0121+  158C 22 06 EB     ld (ethTxBytes+2),hl        
0122+  158F             ; Show search-text in LCD
0123+  158F 3A B5 EA     ld a,(NetLogId)
0124+  1592 21 9A 14     ld hl,s_NetProbeNIC
0125+  1595 CD BD 05     call AddLog
0126+  1598 21 BB 14     ld hl,s_LOGSP
0127+  159B CD BD 05     call AddLog
0128+  159E CD 7E 01     call clear_lcd
0129+  15A1 21 9A 14     ld hl,s_NetProbeNIC
0130+  15A4 CD 86 01     call str2lcd
0131+  15A7 11 E8 03     ld de,NormalMesg
0132+  15AA CD 54 05     call Delayms
0133+  15AD 3E 69        ld a,noNIC
0134+  15AF 32 81 EA     ld (ethdetect),a
0135+  15B2 3E E0        ld a,$e0
0136+  15B4 32 80 EA     ld (ethbase),a
0137+  15B7             ; Probe the NIC
0138+  15B7 CD 8A 18     call ne_probe           ; NEx000-compatible cards
0139+  15BA FE 69        cp noNIC
0140+  15BC 20 05        jr nz,ie_nicfound
0141+  15BE             ; call smc_probe
0142+  15BE             ; cp noNIC
0143+  15BE             ; jr nz,ie_nicfound
0144+  15BE 21 83 14     ld hl,s_NoNIC
0145+  15C1 3E 69        ld a,noNIC
0146+  15C3             ie_nicfound:
0147+  15C3 32 81 EA     ld (ethdetect),a
0148+  15C6 3A B5 EA     ld a,(NetLogId)
0149+  15C9 E5           push hl
0150+  15CA CD BD 05     call AddLog
0151+  15CD 21 BB 14     ld hl,s_LOGSP
0152+  15D0 CD BD 05     call AddLog
0153+  15D3 CD 7E 01     call clear_lcd
0154+  15D6 E1           pop hl
0155+  15D7 CD 86 01     call str2lcd
0156+  15DA 3E 40        ld a,Line2
0157+  15DC CD C7 01     call setDDRAMa
0158+  15DF 23           inc hl
0159+  15E0 CD 86 01     call str2lcd
0160+  15E3 11 E8 03     ld de,NormalMesg
0161+  15E6 CD 54 05     call Delayms
0162+  15E9 CD 7E 01     call clear_lcd
0163+  15EC             ; Enable the NIC
0164+  15EC 3A 81 EA     ld a,(ethdetect)
0165+  15EF FE 69        cp noNIC
0166+  15F1 CA F8 15     jp z,ie_nonic
0167+  15F4 CD 6A 14     call ethOpen
0168+  15F7 FB           ei
0169+  15F8             ie_nonic:
0170+  15F8 AF           xor a
0171+  15F9 32 82 EA     ld (ethtmp),a
0172+  15FC CD 7E 01     call clear_lcd
0173+  15FF 3A 81 EA     ld a,(ethdetect)
0174+  1602 C9           ret
0175+  1603             ; end of ethNICInit
0176+  1603             
0177+  1603             ;**************************************************************
0178+  1603             ;
0179+  1603             ; Drivers
0180+  1603             ; 
0181+  1603             ;**************************************************************
0182+  1603             
0183+  1603             
0184+  1603             ;**************************************************************
0185+  1603             ; Some routines used by 8390-compatible NICs
0186+  1603             
0187+  1603             ; Some generic ethernet register configurations.
0188+  1603             E8390_TX_IRQ_MASK	equ $a	; For register EN0_ISR 
0189+  1603             E8390_RX_IRQ_MASK	equ $5
0190+  1603             E8390_RXCONFIG		equ $4	; EN0_RXCR: broadcasts, no multicast,errors 
0191+  1603             E8390_RXOFF		equ $20	; EN0_RXCR: Accept no packets 
0192+  1603             E8390_TXCONFIG		equ $00	; EN0_TXCR: Normal transmit mode 
0193+  1603             E8390_TXOFF		equ $02	; EN0_TXCR: Transmitter off 
0194+  1603             
0195+  1603             ; Register accessed at EN_CMD, the 8390 base addr.  
0196+  1603             E8390_STOP	equ $01	; Stop and reset the chip 
0197+  1603             E8390_START	equ $02	; Start the chip, clear reset 
0198+  1603             E8390_TRANS	equ $04	; Transmit a frame 
0199+  1603             E8390_RREAD	equ $08	; Remote read 
0200+  1603             E8390_RWRITE	equ $10	; Remote write  
0201+  1603             E8390_NODMA	equ $20	; Remote DMA 
0202+  1603             E8390_PAGE0	equ $00	; Select page chip registers 
0203+  1603             E8390_PAGE1	equ $40	; using the two high-order bits 
0204+  1603             E8390_PAGE2	equ $80	; Page 3 is invalid. 
0205+  1603              
0206+  1603             E8390_CMD	equ $00  ; The command register (for all pages 
0207+  1603             ; Page 0 register offsets. 
0208+  1603             EN0_CLDALO	equ $01	; Low byte of current local dma addr  RD 
0209+  1603             EN0_STARTPG	equ $01	; Starting page of ring bfr WR 
0210+  1603             EN0_CLDAHI	equ $02	; High byte of current local dma addr  RD 
0211+  1603             EN0_STOPPG	equ $02	; Ending page +1 of ring bfr WR 
0212+  1603             EN0_BOUNDARY	equ $03	; Boundary page of ring bfr RD WR 
0213+  1603             EN0_TSR		equ $04	; Transmit status reg RD 
0214+  1603             EN0_TPSR	equ $04	; Transmit starting page WR 
0215+  1603             EN0_NCR		equ $05	; Number of collision reg RD 
0216+  1603             EN0_TCNTLO	equ $05	; Low  byte of tx byte count WR 
0217+  1603             EN0_FIFO	equ $06	; FIFO RD 
0218+  1603             EN0_TCNTHI	equ $06	; High byte of tx byte count WR 
0219+  1603             EN0_ISR		equ $07	; Interrupt status reg RD WR 
0220+  1603             EN0_CRDALO	equ $08	; low byte of current remote dma address RD 
0221+  1603             EN0_RSARLO	equ $08	; Remote start address reg 0 
0222+  1603             EN0_CRDAHI	equ $09	; high byte, current remote dma address RD 
0223+  1603             EN0_RSARHI	equ $09	; Remote start address reg 1 
0224+  1603             EN0_RCNTLO	equ $0a	; Remote byte count reg WR 
0225+  1603             EN0_RCNTHI	equ $0b	; Remote byte count reg WR 
0226+  1603             EN0_RSR		equ $0c	; rx status reg RD 
0227+  1603             EN0_RXCR	equ $0c	; RX configuration reg WR 
0228+  1603             EN0_TXCR	equ $0d	; TX configuration reg WR 
0229+  1603             EN0_COUNTER0	equ $0d	; Rcv alignment error counter RD 
0230+  1603             EN0_DCFG	equ $0e	; Data configuration reg WR 
0231+  1603             EN0_COUNTER1	equ $0e	; Rcv CRC error counter RD 
0232+  1603             EN0_IMR		equ $0f	; Interrupt mask reg WR 
0233+  1603             EN0_COUNTER2	equ $0f	; Rcv missed frame error counter RD 
0234+  1603             
0235+  1603             ; Bits in EN0_ISR - Interrupt status register 
0236+  1603             ENISR_RX	equ $01	; Receiver, no error 
0237+  1603             ENISR_TX	equ $02	; Transmitter, no error 
0238+  1603             ENISR_RX_ERR	equ $04	; Receiver, with error 
0239+  1603             ENISR_TX_ERR	equ $08	; Transmitter, with error 
0240+  1603             ENISR_OVER	equ $10	; Receiver overwrote the ring 
0241+  1603             ENISR_COUNTERS	equ $20	; Counters need emptying 
0242+  1603             ENISR_RDC	equ $40	; remote dma complete 
0243+  1603             ENISR_RESET	equ $80	; Reset completed 
0244+  1603             ENISR_ALL	equ $3f	; Interrupts we will enable 
0245+  1603             
0246+  1603             ; Bits in EN0_DCFG - Data config register 
0247+  1603             ENDCFG_WTS	equ $01	; word transfer mode selection 
0248+  1603             ENDCFG_BOS	equ $02	; byte order selection 
0249+  1603             
0250+  1603             ; Page 1 register offsets. 
0251+  1603             EN1_PHYS   equ $01	; This board's physical enet addr RD WR 
0252+  1603             ;EN1_PHYS_SHIFT(i  equ i+1 ; Get and set mac address 
0253+  1603             EN1_CURPAG equ $07	; Current memory page RD WR 
0254+  1603             EN1_MULT   equ $08	; Multicast filter mask array (8 bytes RD WR 
0255+  1603             ;EN1_MULT_SHIFT(i  equ 8+i ; Get and set multicast filter 
0256+  1603             
0257+  1603             ; Bits in received packet status byte and EN0_RSR
0258+  1603             ENRSR_RXOK	equ $01	; Received a good packet 
0259+  1603             ENRSR_CRC	equ $02	; CRC error 
0260+  1603             ENRSR_FAE	equ $04	; frame alignment error 
0261+  1603             ENRSR_FO	equ $08	; FIFO overrun 
0262+  1603             ENRSR_MPA	equ $10	; missed pkt 
0263+  1603             ENRSR_PHY	equ $20	; physical/multicast address 
0264+  1603             ENRSR_DIS	equ $40	; receiver disable. set in monitor mode 
0265+  1603             ENRSR_DEF	equ $80	; deferring 
0266+  1603             
0267+  1603             ; Transmitted packet status, EN0_TSR. 
0268+  1603             ENTSR_PTX equ $01	; Packet transmitted without error 
0269+  1603             ENTSR_ND  equ $02	; The transmit wasn't deferred. 
0270+  1603             ENTSR_COL equ $04	; The transmit collided at least once. 
0271+  1603             ENTSR_ABT equ $08  ; The transmit collided 16 times, and was deferred. 
0272+  1603             ENTSR_CRS equ $10	; The carrier sense was lost. 
0273+  1603             ENTSR_FU  equ $20  ; A "FIFO underrun" occurred during transmit. 
0274+  1603             ENTSR_CDH equ $40	; The collision detect "heartbeat" signal was lost. 
0275+  1603             ENTSR_OWC equ $80  ; There was an out-of-window collision. 
0276+  1603             
0277+  1603             ; Something from Writing drivers for DP8390 -datasheet
0278+  1603             ;command                 equ ethbase+$00
0279+  1603             ;pagestart               equ ethbase+$01
0280+  1603             ;pagestop                equ ethbase+$02
0281+  1603             ;boundary                equ ethbase+$03
0282+  1603             ;transmitstatus          equ ethbase+$04
0283+  1603             ;transmitpage            equ ethbase+$04
0284+  1603             ;transmitbytecount0      equ ethbase+$05
0285+  1603             ;ncr                     equ ethbase+$05
0286+  1603             ;transmitbytecount1      equ ethbase+$06
0287+  1603             ;interruptstatus         equ ethbase+$07
0288+  1603             ;current                 equ ethbase+$07
0289+  1603             ;remotestartaddress0     equ ethbase+$08
0290+  1603             ;crdma0                  equ ethbase+$08
0291+  1603             ;remotestartaddress1     equ ethbase+$09
0292+  1603             ;crdma1                  equ ethbase+$09
0293+  1603             ;remotebytecount0        equ ethbase+$0a
0294+  1603             ;remotebytecount1        equ ethbase+$0b
0295+  1603             ;receivestatus           equ ethbase+$0c
0296+  1603             ;receiveconfiguration    equ ethbase+$0c
0297+  1603             ;transmitconfiguration   equ ethbase+$0d
0298+  1603             ;fae_tally               equ ethbase+$0d
0299+  1603             ;dataconfiguration       equ ethbase+$0e
0300+  1603             ;crc_tally               equ ethbase+$0e
0301+  1603             ;interruptmask           equ ethbase+$0f
0302+  1603             ;miss_pkt_tally          equ ethbase+$0f
0303+  1603             ;ioport                  equ ethbase+$10
0304+  1603             
0305+  1603             ; *******************************
0306+  1603             ; DP8390_init
0307+  1603             ; Init 8390 registers to "default"
0308+  1603             
0309+  1603 383339302068dp_HWsavebad .db "8390 hw-address",$17
0309+  1609 772D6164647265737317
0310+  1613 736176652066             .db "save failed.",$17
0310+  1619 61696C65642E17
0311+  1620             
0312+  1620             ;
0313+  1620             jDP8390_init:
0314+  1620 E1           pop hl
0315+  1621             DP8390_init:
0316+  1621 F5           push af
0317+  1622 C5           push bc
0318+  1623 D5           push de
0319+  1624 E5           push hl
0320+  1625 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0321+  1627 08           eoutb(E8390_CMD)
0321+  1628 3A 80 EA    
0321+  162B C6 00       
0321+  162D 4F          
0321+  162E 08          
0321+  162F ED 79       
0322+  1631 3A AC EA     ld a,(ethwrdlen)
0323+  1634 FE 02        cp 2
0324+  1636 3E 48        ld a,$48
0325+  1638 20 02        jr nz,dp_bytelen
0326+  163A 3E 49        ld a,$49
0327+  163C             dp_bytelen:
0328+  163C 08           eoutb(EN0_DCFG)
0328+  163D 3A 80 EA    
0328+  1640 C6 0E       
0328+  1642 4F          
0328+  1643 08          
0328+  1644 ED 79       
0329+  1646 AF           xor a
0330+  1647 08           eoutb(EN0_RCNTLO)
0330+  1648 3A 80 EA    
0330+  164B C6 0A       
0330+  164D 4F          
0330+  164E 08          
0330+  164F ED 79       
0331+  1651 08           eoutb(EN0_RCNTHI)
0331+  1652 3A 80 EA    
0331+  1655 C6 0B       
0331+  1657 4F          
0331+  1658 08          
0331+  1659 ED 79       
0332+  165B 3E 20        ld a,E8390_RXOFF
0333+  165D 08           eoutb(EN0_RXCR)
0333+  165E 3A 80 EA    
0333+  1661 C6 0C       
0333+  1663 4F          
0333+  1664 08          
0333+  1665 ED 79       
0334+  1667 3E 02        ld a,E8390_TXOFF
0335+  1669 08           eoutb(EN0_TXCR)
0335+  166A 3A 80 EA    
0335+  166D C6 0D       
0335+  166F 4F          
0335+  1670 08          
0335+  1671 ED 79       
0336+  1673             ;
0337+  1673 3A B1 EA     ld a,(etxStartPage)
0338+  1676 08           eoutb(EN0_TPSR)
0338+  1677 3A 80 EA    
0338+  167A C6 04       
0338+  167C 4F          
0338+  167D 08          
0338+  167E ED 79       
0339+  1680 3A B2 EA     ld a,(erxStartPage)
0340+  1683 08           eoutb(EN0_STARTPG)
0340+  1684 3A 80 EA    
0340+  1687 C6 01       
0340+  1689 4F          
0340+  168A 08          
0340+  168B ED 79       
0341+  168D 3A B3 EA     ld a,(ethStopPage)
0342+  1690 3D           dec a
0343+  1691 08           eoutb(EN0_BOUNDARY)
0343+  1692 3A 80 EA    
0343+  1695 C6 03       
0343+  1697 4F          
0343+  1698 08          
0343+  1699 ED 79       
0344+  169B 3C           inc a
0345+  169C 08           eoutb(EN0_STOPPG)
0345+  169D 3A 80 EA    
0345+  16A0 C6 02       
0345+  16A2 4F          
0345+  16A3 08          
0345+  16A4 ED 79       
0346+  16A6 3E FF        ld a,$ff
0347+  16A8 08           eoutb(EN0_ISR)
0347+  16A9 3A 80 EA    
0347+  16AC C6 07       
0347+  16AE 4F          
0347+  16AF 08          
0347+  16B0 ED 79       
0348+  16B2 AF           xor a
0349+  16B3 08           eoutb(EN0_IMR)
0349+  16B4 3A 80 EA    
0349+  16B7 C6 0F       
0349+  16B9 4F          
0349+  16BA 08          
0349+  16BB ED 79       
0350+  16BD             ;
0351+  16BD 3E 61        ld a,E8390_NODMA+E8390_PAGE1+E8390_STOP
0352+  16BF 08           eoutb(E8390_CMD)
0352+  16C0 3A 80 EA    
0352+  16C3 C6 00       
0352+  16C5 4F          
0352+  16C6 08          
0352+  16C7 ED 79       
0353+  16C9             ; Set hardware address
0354+  16C9 AF           xor a
0355+  16CA 32 B0 EA     ld (ethT3),a
0356+  16CD 06 06        ld b,6
0357+  16CF 3A 80 EA     ld a,(ethbase)
0358+  16D2 C6 01        add a,EN1_PHYS
0359+  16D4 4F           ld c,a
0360+  16D5 21 A3 EA     ld hl,ethhwaddr
0361+  16D8             dp_hwset:
0362+  16D8 7E           ld a,(hl)
0363+  16D9 ED 79        out (c),a
0364+  16DB 57           ld d,a
0365+  16DC ED 78        in a,(c)
0366+  16DE 23           inc hl
0367+  16DF 0C           inc c
0368+  16E0 BA           cp d
0369+  16E1 28 05        jr z,dp_hwgood
0370+  16E3 3E 69        ld a,$69
0371+  16E5 32 B0 EA     ld (ethT3),a
0372+  16E8             dp_hwgood:
0373+  16E8 05           dec b
0374+  16E9 20 ED        jr nz,dp_hwset
0375+  16EB             ;
0376+  16EB 3A B0 EA     ld a,(ethT3)
0377+  16EE FE 00        cp 0
0378+  16F0 28 1B        jr z,dp_hwallgood
0379+  16F2 CD 7E 01     call clear_lcd
0380+  16F5 21 03 16     ld hl,dp_HWsavebad
0381+  16F8 CD 86 01     call str2lcd
0382+  16FB 3E 40        ld a,Line2
0383+  16FD CD C7 01     call setDDRAMa
0384+  1700 23           inc hl
0385+  1701 CD 86 01     call str2lcd
0386+  1704 11 E8 03     ld de,FastMesg
0387+  1707 CD 54 05     call Delayms
0388+  170A CD 7E 01     call clear_lcd
0389+  170D             dp_hwallgood:
0390+  170D 3A B2 EA     ld a,(erxStartPage)
0391+  1710 08           eoutb(EN1_CURPAG)
0391+  1711 3A 80 EA    
0391+  1714 C6 07       
0391+  1716 4F          
0391+  1717 08          
0391+  1718 ED 79       
0392+  171A 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0393+  171C 08           eoutb(E8390_CMD)
0393+  171D 3A 80 EA    
0393+  1720 C6 00       
0393+  1722 4F          
0393+  1723 08          
0393+  1724 ED 79       
0394+  1726             ;
0395+  1726 E1           pop hl
0396+  1727 D1           pop de
0397+  1728 C1           pop bc
0398+  1729 F1           pop af
0399+  172A C9           ret
0400+  172B             ; end of DP8390_init
0401+  172B             
0402+  172B             ; *******************************
0403+  172B             ; DP8390_enable
0404+  172B             jDP8390_enable:
0405+  172B E1           pop hl
0406+  172C             DP8390_enable:
0407+  172C F5           push af
0408+  172D C5           push bc
0409+  172E 3E FF        ld a,$ff
0410+  1730 08           eoutb(EN0_ISR)
0410+  1731 3A 80 EA    
0410+  1734 C6 07       
0410+  1736 4F          
0410+  1737 08          
0410+  1738 ED 79       
0411+  173A 3E 3F        ld a,ENISR_ALL
0412+  173C 08           eoutb(EN0_IMR)
0412+  173D 3A 80 EA    
0412+  1740 C6 0F       
0412+  1742 4F          
0412+  1743 08          
0412+  1744 ED 79       
0413+  1746 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0414+  1748 08           eoutb(E8390_CMD)
0414+  1749 3A 80 EA    
0414+  174C C6 00       
0414+  174E 4F          
0414+  174F 08          
0414+  1750 ED 79       
0415+  1752 3E 00        ld a,E8390_TXCONFIG
0416+  1754 08           eoutb(EN0_TXCR)
0416+  1755 3A 80 EA    
0416+  1758 C6 0D       
0416+  175A 4F          
0416+  175B 08          
0416+  175C ED 79       
0417+  175E 3E 04        ld a,E8390_RXCONFIG
0418+  1760 08           eoutb(EN0_RXCR)
0418+  1761 3A 80 EA    
0418+  1764 C6 0C       
0418+  1766 4F          
0418+  1767 08          
0418+  1768 ED 79       
0419+  176A C1           pop bc
0420+  176B F1           pop af
0421+  176C C9           ret
0422+  176D             ; end of DP8390_enable
0423+  176D             ;**************************************************************
0424+  176D             
0425+  176D             
0426+  176D             ;**************************************************************
0427+  176D             ; Drivers for NE1000/NE2000 (DP8390) compatible adapters
0428+  176D             ; Mostly copied from linux 2.4.5 kernels NE1000/NE2000 (8390) drivers
0429+  176D             ; (written by Donald Becker)
0430+  176D             
0431+  176D 4E4578303030ne_copyright .db "NEx000 drivers      ",$17
0431+  1773 206472697665727320202020202017
0432+  1782 427920447567             .db "By Duge. Mostly     ",$17
0432+  1788 652E204D6F73746C79202020202017
0433+  1797 636F70696564             .db "copied from linux   ",$17
0433+  179D 2066726F6D206C696E757820202017
0434+  17AC 6B65726E656C             .db "kernel drivers      ",$17
0434+  17B2 206472697665727320202020202017
0435+  17C1 777269747465             .db "written by          ",$17
0435+  17C7 6E2062792020202020202020202017
0436+  17D6 446F6E616C64             .db "Donald Becker.      ",$17,$17
0436+  17DC 204265636B65722E2020202020201717
0437+  17EC 4E6F204E455Bne_nodev     .db "No NE[1,2]000 found.",$17,$17
0437+  17F2 312C325D30303020666F756E642E1717
0438+  1802 526573657420ne_noreset   .db "Reset failed on",$17
0438+  1808 6661696C6564206F6E17
0439+  1812 4E455B312C32             .db "NE[1,2]000-NIC.",$17
0439+  1818 5D3030302D4E49432E17
0440+  1822 4E4531303030ne1_detected .db "NE1000-NIC",$17
0440+  1828 2D4E494317
0441+  182D 646574656374             .db "detected.",$17
0441+  1833 65642E17
0442+  1837 4E4532303030ne2_detected .db "NE2000-NIC",$17
0442+  183D 2D4E494317
0443+  1842 646574656374             .db "detected.",$17
0443+  1848 65642E17
0444+  184C 4E452D636F6DneC_detected .db "NE-compatible Ctron-",$17
0444+  1852 70617469626C65204374726F6E2D17
0445+  1861 4E4943206465             .db "NIC detected.",$17
0445+  1867 7465637465642E17
0446+  186F 426164204E45ne_badclone  .db "Bad NEx000 clone",$17
0446+  1875 7830303020636C6F6E6517
0447+  1880 646574656374             .db "detected.",$17
0447+  1886 65642E17
0448+  188A             
0449+  188A             ; #define's
0450+  188A             ;
0451+  188A             ; Weird stuff, but have no reason to change this 'grab' from
0452+  188A             ; the linux kernel, so leaving it like this
0453+  188A             ;
0454+  188A             #define TX_2X_PAGES 12
0455+  188A             #define TX_1X_PAGES 6
0456+  188A             ; Should always use two Tx slots to get back-to-back transmits.
0457+  188A             #define EI_PINGPONG
0458+  188A             #ifdef EI_PINGPONG
0459+  188A             #define TX_PAGES TX_2X_PAGES
0460+  188A~            #else
0461+  188A~            #define TX_PAGES TX_1X_PAGES
0462+  188A             #endif
0463+  188A             ;
0464+  188A             
0465+  188A             NE_BASE                 equ $00
0466+  188A             NE_CMD                  equ $00
0467+  188A             NE_DATAPORT             equ $10    ; NatSemi-defined port window offset. 
0468+  188A             NE_RESET                equ $1f    ; Issue a read to reset, a write to clear. 
0469+  188A             NE_IO_EXTENT            equ $20
0470+  188A             
0471+  188A             NE1SM_START_PG          equ $20    ; First page of TX buffer 
0472+  188A             NE1SM_STOP_PG           equ $40    ; Last page +1 of RX ring 
0473+  188A             NESM_START_PG           equ $40    ; First page of TX buffer 
0474+  188A             NESM_STOP_PG            equ $80    ; Last page +1 of RX ring 
0475+  188A             
0476+  188A             ; *******************************
0477+  188A             ; ne_probe
0478+  188A             ; Let's probe for NEx000-based card
0479+  188A             ne_probe:
0480+  188A 3A 80 EA     einb(0)
0480+  188D C6 00       
0480+  188F 4F          
0480+  1890 ED 78       
0481+  1892 32 AE EA     ld (ethT1),a
0482+  1895 FE FF        cp $ff
0483+  1897 20 03        jr nz,nepb_maybe0
0484+  1899 C3 C8 1A     jp nepb_nodev
0485+  189C             nepb_maybe0:
0486+  189C 3E 61        ld a,E8390_NODMA+E8390_PAGE1+E8390_STOP
0487+  189E 08           eoutb(E8390_CMD)
0487+  189F 3A 80 EA    
0487+  18A2 C6 00       
0487+  18A4 4F          
0487+  18A5 08          
0487+  18A6 ED 79       
0488+  18A8 3A 80 EA     einb($0d)
0488+  18AB C6 0D       
0488+  18AD 4F          
0488+  18AE ED 78       
0489+  18B0 32 AD EA     ld (ethT0),a
0490+  18B3 3E FF        ld a,$ff
0491+  18B5 08           eoutb($0d)
0491+  18B6 3A 80 EA    
0491+  18B9 C6 0D       
0491+  18BB 4F          
0491+  18BC 08          
0491+  18BD ED 79       
0492+  18BF 3E 20        ld a,E8390_NODMA+E8390_PAGE0
0493+  18C1 08           eoutb(E8390_CMD)
0493+  18C2 3A 80 EA    
0493+  18C5 C6 00       
0493+  18C7 4F          
0493+  18C8 08          
0493+  18C9 ED 79       
0494+  18CB 3A 80 EA     einb(EN0_COUNTER0)
0494+  18CE C6 0D       
0494+  18D0 4F          
0494+  18D1 ED 78       
0495+  18D3 FE 00        cp 0
0496+  18D5 28 1D        jr z,nepb_possibly0
0497+  18D7 3A AE EA     ld a,(ethT1)
0498+  18DA 08           eoutb(0)
0498+  18DB 3A 80 EA    
0498+  18DE C6 00       
0498+  18E0 4F          
0498+  18E1 08          
0498+  18E2 ED 79       
0499+  18E4 3A AD EA     ld a,(ethT0)
0500+  18E7 08           eoutb($0d)
0500+  18E8 3A 80 EA    
0500+  18EB C6 0D       
0500+  18ED 4F          
0500+  18EE 08          
0500+  18EF ED 79       
0501+  18F1 C3 C8 1A     jp nepb_nodev
0502+  18F4             nepb_possibly0:
0503+  18F4             #ifdef DEBUG_DRIVERS
0504+  18F4 3A 86 EB     led_set($01)
0504+  18F7 E6 FE       
0504+  18F9 D3 07       
0504+  18FB 32 86 EB    
0505+  18FE             #endif
0506+  18FE CD 62 20     call ne_reset          ; Reset
0507+  1901 FE 17        cp $17                 ; See if reset successful
0508+  1903 28 1B        jr z,nepb_resets       ;
0509+  1905 21 02 18     ld hl,ne_noreset
0510+  1908 CD 7E 01     call clear_lcd
0511+  190B CD 86 01     call str2lcd
0512+  190E 3E 40        ld a,Line2
0513+  1910 CD C7 01     call setDDRAMa
0514+  1913 23           inc hl
0515+  1914 CD 86 01     call str2lcd
0516+  1917 11 B8 0B     ld de,ErrorMesg
0517+  191A CD 54 05     call Delayms
0518+  191D CD 7E 01     call clear_lcd
0519+  1920             nepb_resets:
0520+  1920             #ifdef DEBUG_DRIVERS
0521+  1920 3A 86 EB     led_set($02)
0521+  1923 E6 FD       
0521+  1925 D3 07       
0521+  1927 32 86 EB    
0522+  192A             #endif
0523+  192A 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0524+  192C 08           eoutb(E8390_CMD)
0524+  192D 3A 80 EA    
0524+  1930 C6 00       
0524+  1932 4F          
0524+  1933 08          
0524+  1934 ED 79       
0525+  1936 3E 48        ld a,$48
0526+  1938 08           eoutb(EN0_DCFG)
0526+  1939 3A 80 EA    
0526+  193C C6 0E       
0526+  193E 4F          
0526+  193F 08          
0526+  1940 ED 79       
0527+  1942 AF           xor a
0528+  1943 08           eoutb(EN0_RCNTLO)
0528+  1944 3A 80 EA    
0528+  1947 C6 0A       
0528+  1949 4F          
0528+  194A 08          
0528+  194B ED 79       
0529+  194D 08           eoutb(EN0_RCNTHI)
0529+  194E 3A 80 EA    
0529+  1951 C6 0B       
0529+  1953 4F          
0529+  1954 08          
0529+  1955 ED 79       
0530+  1957 08           eoutb(EN0_IMR)
0530+  1958 3A 80 EA    
0530+  195B C6 0F       
0530+  195D 4F          
0530+  195E 08          
0530+  195F ED 79       
0531+  1961 3E FF        ld a,$ff
0532+  1963 08           eoutb(EN0_ISR)
0532+  1964 3A 80 EA    
0532+  1967 C6 07       
0532+  1969 4F          
0532+  196A 08          
0532+  196B ED 79       
0533+  196D 3E 20        ld a,E8390_RXOFF
0534+  196F 08           eoutb(EN0_RXCR)
0534+  1970 3A 80 EA    
0534+  1973 C6 0C       
0534+  1975 4F          
0534+  1976 08          
0534+  1977 ED 79       
0535+  1979 3E 02        ld a,E8390_TXOFF
0536+  197B 08           eoutb(EN0_TXCR)
0536+  197C 3A 80 EA    
0536+  197F C6 0D       
0536+  1981 4F          
0536+  1982 08          
0536+  1983 ED 79       
0537+  1985 3E 20        ld a,32
0538+  1987 08           eoutb(EN0_RCNTLO)
0538+  1988 3A 80 EA    
0538+  198B C6 0A       
0538+  198D 4F          
0538+  198E 08          
0538+  198F ED 79       
0539+  1991 AF           xor a
0540+  1992 08           eoutb(EN0_RCNTHI)
0540+  1993 3A 80 EA    
0540+  1996 C6 0B       
0540+  1998 4F          
0540+  1999 08          
0540+  199A ED 79       
0541+  199C 08           eoutb(EN0_RSARLO)
0541+  199D 3A 80 EA    
0541+  19A0 C6 08       
0541+  19A2 4F          
0541+  19A3 08          
0541+  19A4 ED 79       
0542+  19A6 08           eoutb(EN0_RSARHI)
0542+  19A7 3A 80 EA    
0542+  19AA C6 09       
0542+  19AC 4F          
0542+  19AD 08          
0542+  19AE ED 79       
0543+  19B0 3E 0A        ld a,E8390_RREAD+E8390_START
0544+  19B2 08           eoutb(E8390_CMD)
0544+  19B3 3A 80 EA    
0544+  19B6 C6 00       
0544+  19B8 4F          
0544+  19B9 08          
0544+  19BA ED 79       
0545+  19BC             ; Read station address PROM (SAPROM)
0546+  19BC 3E 02        ld a,2
0547+  19BE 32 AC EA     ld (ethwrdlen),a
0548+  19C1 06 10        ld b,16
0549+  19C3 21 83 EA     ld hl,ethsaprom
0550+  19C6 3A 80 EA     ld a,(ethbase)
0551+  19C9 C6 10        add a,NE_DATAPORT
0552+  19CB 4F           ld c,a
0553+  19CC             nepb_readsaprom:
0554+  19CC ED 78        in a,(c)
0555+  19CE 77           ld (hl),a
0556+  19CF 23           inc hl
0557+  19D0 57           ld d,a
0558+  19D1 ED 78        in a,(c)
0559+  19D3 77           ld (hl),a
0560+  19D4 23           inc hl
0561+  19D5 BA           cp d
0562+  19D6 28 18        jr z,nepb_wrdlen2
0563+  19D8             #ifdef DEBUG_DRIVERS
0564+  19D8 C5           push bc
0565+  19D9 0E 01        ld c,SSeg1
0566+  19DB CD CB 00     call b_to_7seg
0567+  19DE 7A           ld a,d
0568+  19DF 0E 03        ld c,SSeg3
0569+  19E1 CD CB 00     call b_to_7seg
0570+  19E4 C1           pop bc
0571+  19E5 11 E8 03     ld de,1000
0572+  19E8 CD 54 05     call Delayms
0573+  19EB             #endif
0574+  19EB 3E 01        ld a,1
0575+  19ED 32 AC EA     ld (ethwrdlen),a
0576+  19F0             nepb_wrdlen2:
0577+  19F0 05           dec b
0578+  19F1 20 D9        jr nz,nepb_readsaprom
0579+  19F3             ; Do some settings depending on if the NIC was detected as
0580+  19F3             ; 16bit or 8bit card
0581+  19F3 20 37        jr nz,nepb_byte
0582+  19F5             #ifdef DEBUG_DRIVERS
0583+  19F5 3A 86 EB     led_set($03)
0583+  19F8 E6 FC       
0583+  19FA D3 07       
0583+  19FC 32 86 EB    
0584+  19FF             #endif
0585+  19FF 01 83 EA     ld bc,ethsaprom
0586+  1A02 21 83 EA     ld hl,ethsaprom
0587+  1A05 16 10        ld d,16
0588+  1A07             nepb_wsaset:
0589+  1A07 7E           ld a,(hl)
0590+  1A08 02           ld (bc),a
0591+  1A09 03           inc bc
0592+  1A0A 23           inc hl
0593+  1A0B 23           inc hl
0594+  1A0C 15           dec d
0595+  1A0D 20 F8        jr nz,nepb_wsaset
0596+  1A0F             ;
0597+  1A0F 3E 49        ld a,$49
0598+  1A11 08           eoutb(EN0_DCFG)
0598+  1A12 3A 80 EA    
0598+  1A15 C6 0E       
0598+  1A17 4F          
0598+  1A18 08          
0598+  1A19 ED 79       
0599+  1A1B 3E 40        ld a,NESM_START_PG
0600+  1A1D 32 B1 EA     ld (etxStartPage),a
0601+  1A20 C6 0C        add a,TX_PAGES
0602+  1A22 32 B2 EA     ld (erxStartPage),a
0603+  1A25 3E 80        ld a,NESM_STOP_PG
0604+  1A27 32 B3 EA     ld (ethStopPage),a
0605+  1A2A 18 19        jr nepb_jbyte
0606+  1A2C             nepb_byte:
0607+  1A2C             #ifdef DEBUG_DRIVERS
0608+  1A2C 3A 86 EB     led_set($02)
0608+  1A2F E6 FD       
0608+  1A31 D3 07       
0608+  1A33 32 86 EB    
0609+  1A36             #endif
0610+  1A36 3E 20        ld a,NE1SM_START_PG
0611+  1A38 32 B1 EA     ld (etxStartPage),a
0612+  1A3B C6 0C        add a,TX_PAGES
0613+  1A3D 32 B2 EA     ld (erxStartPage),a
0614+  1A40 3E 40        ld a,NE1SM_STOP_PG
0615+  1A42 32 B3 EA     ld (ethStopPage),a
0616+  1A45             nepb_jbyte:
0617+  1A45             ; Save hardware-address
0618+  1A45 16 06        ld d,6
0619+  1A47 21 83 EA     ld hl,ethsaprom
0620+  1A4A 01 A3 EA     ld bc,ethhwaddr
0621+  1A4D             nepb_hwsave:
0622+  1A4D 7E           ld a,(hl)
0623+  1A4E 02           ld (bc),a
0624+  1A4F 23           inc hl
0625+  1A50 03           inc bc
0626+  1A51 15           dec d
0627+  1A52 20 F9        jr nz,nepb_hwsave
0628+  1A54 CD 21 16     call DP8390_init
0629+  1A57             ; Set up jump-table which is called by applications
0630+  1A57 21 61 20     ld hl,jne_reset
0631+  1A5A 22 BE EA     ld (ejReset),hl
0632+  1A5D 21 D0 1A     ld hl,jne_open
0633+  1A60 22 C0 EA     ld (ejOpen),hl
0634+  1A63 21 2B 17     ld hl,jDP8390_enable
0635+  1A66 22 C2 EA     ld (ejEnable),hl
0636+  1A69 21 20 16     ld hl,jDP8390_init
0637+  1A6C 22 C4 EA     ld (ejDisable),hl
0638+  1A6F 21 DD 1A     ld hl,jne_interrupt
0639+  1A72 22 C6 EA     ld (ejInterrupt),hl
0640+  1A75 21 33 1F     ld hl,jne_send
0641+  1A78 22 C8 EA     ld (ejSend),hl
0642+  1A7B             ; Save the NIC's ID
0643+  1A7B 3A 91 EA     ld a,(ethsaprom+14)
0644+  1A7E 47           ld b,a
0645+  1A7F 3A 92 EA     ld a,(ethsaprom+15)
0646+  1A82 B8           cp b
0647+  1A83 20 17        jr nz,nepb_nonex
0648+  1A85 FE 57        cp $57                 ; Check for NEx000-card
0649+  1A87 20 38        jr nz,nepb_badclone
0650+  1A89             nepb_copam:             ; If NE-compatible copam-card
0651+  1A89 3A AC EA     ld a,(ethwrdlen)
0652+  1A8C FE 02        cp 2                   ; Check if 16bit
0653+  1A8E 3E 02        ld a,NE2comp
0654+  1A90 21 37 18     ld hl,ne2_detected
0655+  1A93 28 3A        jr z,nepb_end          ; Jump, if was 16bit card (NE2000)
0656+  1A95 3E 01        ld a,NE1comp           ; in other case 8bit (NE1000)
0657+  1A97 21 22 18     ld hl,ne1_detected
0658+  1A9A 18 33        jr nepb_end
0659+  1A9C             nepb_nonex:
0660+  1A9C FE 00        cp $0
0661+  1A9E 20 05        jr nz,nepb_notcopam
0662+  1AA0 78           ld a,b
0663+  1AA1 FE 49        cp $49
0664+  1AA3 28 E4        jr z,nepb_copam        ; Card was detected as 'copam' NEx000-compatible
0665+  1AA5             nepb_notcopam:
0666+  1AA5 3A 83 EA     ld a,(ethsaprom+0)
0667+  1AA8 FE 00        cp $0
0668+  1AAA 20 15        jr nz,nepb_badclone
0669+  1AAC 3A 84 EA     ld a,(ethsaprom+1)
0670+  1AAF FE 00        cp $0
0671+  1AB1 20 0E        jr nz,nepb_badclone
0672+  1AB3 3A 85 EA     ld a,(ethsaprom+2)
0673+  1AB6 FE 1D        cp $1d
0674+  1AB8 20 07        jr nz,nepb_badclone
0675+  1ABA 3E 03        ld a,NECcomp           ; Ctron 8- or 16-bit NEx000-compatible card
0676+  1ABC 21 4C 18     ld hl,neC_detected     ; Detection between 8- and 16-bits left out
0677+  1ABF 18 0E        jr nepb_end            ; becose there no use for that information
0678+  1AC1             nepb_badclone:
0679+  1AC1 21 6F 18     ld hl,ne_badclone
0680+  1AC4 3E 04        ld a,NEBcomp
0681+  1AC6 18 07        jr nepb_end
0682+  1AC8             nepb_nodev:
0683+  1AC8 3E 69        ld a,noNIC
0684+  1ACA 21 EC 17     ld hl,ne_nodev
0685+  1ACD 18 00        jr nepb_end
0686+  1ACF             ;
0687+  1ACF             nepb_end:
0688+  1ACF C9           ret
0689+  1AD0             ; end of ne_probe
0690+  1AD0             
0691+  1AD0             ; *******************************
0692+  1AD0             ; ne_open
0693+  1AD0             jne_open:
0694+  1AD0 E1           pop hl
0695+  1AD1             ne_open:
0696+  1AD1 CD 62 20     call ne_reset
0697+  1AD4 CD 21 16     call DP8390_init
0698+  1AD7 CD 2C 17     call DP8390_enable
0699+  1ADA F5           push af
0700+  1ADB F1           pop af
0701+  1ADC C9           ret
0702+  1ADD             ; end of ne_open
0703+  1ADD             
0704+  1ADD             ; *******************************
0705+  1ADD             ; ne_interrupt
0706+  1ADD             jne_interrupt:
0707+  1ADD E1           pop hl
0708+  1ADE             ne_interrupt:
0709+  1ADE 00           nop
0710+  1ADF 00           nop
0711+  1AE0 F5           push af
0712+  1AE1 E5           push hl
0713+  1AE2 C5           push bc
0714+  1AE3 D5           push de
0715+  1AE4 3E 20        ld a,E8390_NODMA+E8390_PAGE0
0716+  1AE6 08           eoutb(NE_CMD)
0716+  1AE7 3A 80 EA    
0716+  1AEA C6 00       
0716+  1AEC 4F          
0716+  1AED 08          
0716+  1AEE ED 79       
0717+  1AF0 3E 0A        ld a,MAX_INTERRUPT_SERVICE
0718+  1AF2 32 7E EB     ld (NT2),a
0719+  1AF5             #ifdef DEBUG_DRIVERS
0720+  1AF5 3E FF        ld a,$ff
0721+  1AF7 D3 07        out (LEDs),a
0722+  1AF9 D3 01        out (SSeg1),a
0723+  1AFB D3 02        out (SSeg2),a
0724+  1AFD D3 03        out (SSeg3),a
0725+  1AFF D3 04        out (SSeg4),a
0726+  1B01 AF           xor a
0727+  1B02 F5           push af
0728+  1B03             #endif
0729+  1B03             nei_rloop:
0730+  1B03             #ifdef DEBUG_DRIVERS
0731+  1B03 F1           pop af
0732+  1B04 3C           inc a
0733+  1B05 F5           push af
0734+  1B06 F6 01        or 1
0735+  1B08 EE FF        xor $ff
0736+  1B0A D3 07        out (LEDs),a
0737+  1B0C             #endif
0738+  1B0C 3A 7E EB     ld a,(NT2)
0739+  1B0F 3D           dec a
0740+  1B10 CA 5C 1B     jp z,nei_end
0741+  1B13 32 7E EB     ld (NT2),a
0742+  1B16 3A 80 EA     einb(EN0_ISR)
0742+  1B19 C6 07       
0742+  1B1B 4F          
0742+  1B1C ED 78       
0743+  1B1E FE 00        cp 0
0744+  1B20 CA 5C 1B     jp z,nei_end
0745+  1B23 47           ld b,a
0746+  1B24 E6 10        and ENISR_OVER
0747+  1B26 C2 7D 1B     jp nz,nei_over
0748+  1B29 78           ld a,b
0749+  1B2A E6 01        and ENISR_RX
0750+  1B2C C2 66 1B     jp nz,nei_rx
0751+  1B2F 78           ld a,b
0752+  1B30 E6 04        and ENISR_RX_ERR
0753+  1B32 C2 66 1B     jp nz,nei_rxwitherr
0754+  1B35 78           ld a,b
0755+  1B36 E6 02        and ENISR_TX
0756+  1B38 C2 73 1B     jp nz,nei_tx
0757+  1B3B 78           ld a,b
0758+  1B3C E6 08        and ENISR_TX_ERR
0759+  1B3E C2 73 1B     jp nz,nei_txwitherr
0760+  1B41 78           ld a,b
0761+  1B42 E6 40        and ENISR_RDC
0762+  1B44 C2 11 1C     jp nz,nei_enisr
0763+  1B47 78           ld a,b
0764+  1B48 E6 20        and ENISR_COUNTERS
0765+  1B4A C2 27 1C     jp nz,nei_counters
0766+  1B4D             nei_loop:
0767+  1B4D 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0768+  1B4F 08           eoutb(E8390_CMD)
0768+  1B50 3A 80 EA    
0768+  1B53 C6 00       
0768+  1B55 4F          
0768+  1B56 08          
0768+  1B57 ED 79       
0769+  1B59 C3 03 1B     jp nei_rloop
0770+  1B5C             nei_end:
0771+  1B5C             #ifdef DEBUG_DRIVERS
0772+  1B5C F1           pop af
0773+  1B5D 3E FF        ld a,$ff
0774+  1B5F D3 07        out (LEDs),a
0775+  1B61             #endif
0776+  1B61 D1           pop de
0777+  1B62 C1           pop bc
0778+  1B63 E1           pop hl
0779+  1B64 F1           pop af
0780+  1B65 C9           ret
0781+  1B66             ;
0782+  1B66             nei_rx:
0783+  1B66             nei_rxwitherr:
0784+  1B66             #ifdef DEBUG_DRIVERS
0785+  1B66 3E 00        ld a,0
0786+  1B68 0E 01        ld c,SSeg1
0787+  1B6A CD B1 00     call n_to_7seg
0788+  1B6D             #endif
0789+  1B6D CD 69 1C     call ne_receive
0790+  1B70 C3 4D 1B     jp nei_loop
0791+  1B73             nei_tx:
0792+  1B73             nei_txwitherr:
0793+  1B73             #ifdef DEBUG_DRIVERS
0794+  1B73 3E 01        ld a,1
0795+  1B75 0E 01        ld c,SSeg1
0796+  1B77 CD B1 00     call n_to_7seg
0797+  1B7A             #endif
0798+  1B7A C3 4D 1B     jp nei_loop
0799+  1B7D             ; Handle receiver overrun
0800+  1B7D             nei_over:
0801+  1B7D             #ifdef DEBUG_DRIVERS
0802+  1B7D 3E 02        ld a,2
0803+  1B7F 0E 01        ld c,SSeg1
0804+  1B81 CD B1 00     call n_to_7seg
0805+  1B84             #endif
0806+  1B84 3A 80 EA     einb(E8390_CMD)
0806+  1B87 C6 00       
0806+  1B89 4F          
0806+  1B8A ED 78       
0807+  1B8C E6 04        and E8390_TRANS
0808+  1B8E 47           ld b,a
0809+  1B8F 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
0810+  1B91 08           eoutb(E8390_CMD)
0810+  1B92 3A 80 EA    
0810+  1B95 C6 00       
0810+  1B97 4F          
0810+  1B98 08          
0810+  1B99 ED 79       
0811+  1B9B 21 F0 EA     ld hl,ethRxOverErrs
0812+  1B9E 23           inc hl
0813+  1B9F 22 F0 EA     ld (ethRxOverErrs),hl
0814+  1BA2 11 0A 00     ld de,10
0815+  1BA5 CD 54 05     call Delayms
0816+  1BA8 3A 80 EA     ld a,(ethbase)
0817+  1BAB C6 0A        add a,EN0_RCNTLO
0818+  1BAD 4F           ld c,a
0819+  1BAE AF           xor a
0820+  1BAF ED 79        out (c),a
0821+  1BB1 0C           inc c
0822+  1BB2 ED 79        out (c),a
0823+  1BB4 B8           cp b
0824+  1BB5 CA C9 1B     jp z,neio_notrans
0825+  1BB8 3A 80 EA     einb(EN0_ISR)
0825+  1BBB C6 07       
0825+  1BBD 4F          
0825+  1BBE ED 78       
0826+  1BC0 E6 0A        and ENISR_TX+ENISR_TX_ERR
0827+  1BC2 FE 00        cp 0
0828+  1BC4 CA C9 1B     jp z,neio_notrans
0829+  1BC7 06 00        ld b,0
0830+  1BC9             neio_notrans:
0831+  1BC9 3E 02        ld a,E8390_TXOFF
0832+  1BCB 08           eoutb(EN0_TXCR)
0832+  1BCC 3A 80 EA    
0832+  1BCF C6 0D       
0832+  1BD1 4F          
0832+  1BD2 08          
0832+  1BD3 ED 79       
0833+  1BD5 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0834+  1BD7 08           eoutb(E8390_CMD)
0834+  1BD8 3A 80 EA    
0834+  1BDB C6 00       
0834+  1BDD 4F          
0834+  1BDE 08          
0834+  1BDF ED 79       
0835+  1BE1 CD 69 1C     call ne_receive
0836+  1BE4 3E 10        ld a,ENISR_OVER
0837+  1BE6 08           eoutb(EN0_ISR)
0837+  1BE7 3A 80 EA    
0837+  1BEA C6 07       
0837+  1BEC 4F          
0837+  1BED 08          
0837+  1BEE ED 79       
0838+  1BF0 3A 00 00     ld a,(E8390_TXCONFIG)
0839+  1BF3 08           eoutb(EN0_TXCR)
0839+  1BF4 3A 80 EA    
0839+  1BF7 C6 0D       
0839+  1BF9 4F          
0839+  1BFA 08          
0839+  1BFB ED 79       
0840+  1BFD AF           xor a
0841+  1BFE B8           cp b
0842+  1BFF CA 0E 1C     jp z,neio_noretrans
0843+  1C02 3E 26        ld a,E8390_NODMA+E8390_PAGE0+E8390_START+E8390_TRANS
0844+  1C04 08           eoutb(E8390_CMD)
0844+  1C05 3A 80 EA    
0844+  1C08 C6 00       
0844+  1C0A 4F          
0844+  1C0B 08          
0844+  1C0C ED 79       
0845+  1C0E             neio_noretrans:
0846+  1C0E C3 4D 1B     jp nei_loop
0847+  1C11             ; Ignore any RDC
0848+  1C11             nei_enisr:
0849+  1C11             #ifdef DEBUG_DRIVERS
0850+  1C11 3E 03        ld a,3
0851+  1C13 0E 01        ld c,SSeg1
0852+  1C15 CD B1 00     call n_to_7seg
0853+  1C18             #endif
0854+  1C18 3E 40        ld a,ENISR_RDC
0855+  1C1A 08           eoutb(EN0_ISR)
0855+  1C1B 3A 80 EA    
0855+  1C1E C6 07       
0855+  1C20 4F          
0855+  1C21 08          
0855+  1C22 ED 79       
0856+  1C24 C3 4D 1B     jp nei_loop
0857+  1C27             ; Update counters
0858+  1C27             nei_counters:
0859+  1C27             #ifdef DEBUG_DRIVERS
0860+  1C27 3E 04        ld a,4
0861+  1C29 0E 01        ld c,SSeg1
0862+  1C2B CD B1 00     call n_to_7seg
0863+  1C2E             #endif
0864+  1C2E 3A 80 EA     ld a,(ethbase)
0865+  1C31 C6 0D        add a,EN0_COUNTER0
0866+  1C33 4F           ld c,a
0867+  1C34 ED 68        in l,(c)
0868+  1C36 26 00        ld h,0
0869+  1C38 ED 5B E4 EA  ld de,(ethRxFrameErrs)
0870+  1C3C 19           add hl,de
0871+  1C3D 22 E4 EA     ld (ethRxFrameErrs),hl
0872+  1C40 0C           inc c
0873+  1C41 ED 68        in l,(c)
0874+  1C43 26 00        ld h,0
0875+  1C45 ED 5B E6 EA  ld de,(ethRxCrcErrs)
0876+  1C49 19           add hl,de
0877+  1C4A 22 E6 EA     ld (ethRxCrcErrs),hl
0878+  1C4D 0C           inc c
0879+  1C4E ED 68        in l,(c)
0880+  1C50 26 00        ld h,0
0881+  1C52 ED 5B E8 EA  ld de,(ethRxMissedErrs)
0882+  1C56 19           add hl,de
0883+  1C57 22 E8 EA     ld (ethRxMissedErrs),hl
0884+  1C5A 3E 20        ld a,ENISR_COUNTERS
0885+  1C5C 08           eoutb(EN0_ISR)
0885+  1C5D 3A 80 EA    
0885+  1C60 C6 07       
0885+  1C62 4F          
0885+  1C63 08          
0885+  1C64 ED 79       
0886+  1C66 C3 4D 1B     jp nei_loop
0887+  1C69             ; end of ne_interrupt
0888+  1C69             
0889+  1C69             ; *******************************
0890+  1C69             ; ne_receive
0891+  1C69             ne_receive:
0892+  1C69 F5           push af
0893+  1C6A E5           push hl
0894+  1C6B C5           push bc
0895+  1C6C D5           push de
0896+  1C6D 3E 0A        ld a,MAX_RECEIVE_SERVICE
0897+  1C6F 32 7F EB     ld (NT3),a
0898+  1C72             ner_loop:
0899+  1C72 3A 7F EB     ld a,(NT3)
0900+  1C75 3D           dec a
0901+  1C76 CA 0D 1F     jp z,ner_end
0902+  1C79 32 7F EB     ld (NT3),a
0903+  1C7C             ;
0904+  1C7C 3E 60        ld a,E8390_NODMA+E8390_PAGE1
0905+  1C7E 08           eoutb(E8390_CMD)
0905+  1C7F 3A 80 EA    
0905+  1C82 C6 00       
0905+  1C84 4F          
0905+  1C85 08          
0905+  1C86 ED 79       
0906+  1C88 3A 80 EA     einb(EN1_CURPAG)
0906+  1C8B C6 07       
0906+  1C8D 4F          
0906+  1C8E ED 78       
0907+  1C90 47           ld b,a
0908+  1C91 32 7C EB     ld (NT0),a
0909+  1C94 3E 20        ld a,E8390_NODMA+E8390_PAGE0
0910+  1C96 08           eoutb(E8390_CMD)
0910+  1C97 3A 80 EA    
0910+  1C9A C6 00       
0910+  1C9C 4F          
0910+  1C9D 08          
0910+  1C9E ED 79       
0911+  1CA0 3A 80 EA     einb(EN0_BOUNDARY)
0911+  1CA3 C6 03       
0911+  1CA5 4F          
0911+  1CA6 ED 78       
0912+  1CA8 3C           inc a
0913+  1CA9 5F           ld e,a
0914+  1CAA 32 7D EB     ld (NT1),a
0915+  1CAD 3A B3 EA     ld a,(ethStopPage)
0916+  1CB0 3D           dec a
0917+  1CB1 BB           cp e
0918+  1CB2 D2 B9 1C     jp nc,ner_notbigger
0919+  1CB5 3A B2 EA     ld a,(erxStartPage)
0920+  1CB8 5F           ld e,a
0921+  1CB9             ner_notbigger:
0922+  1CB9 78           ld a,b
0923+  1CBA BB           cp e
0924+  1CBB CA 0D 1F     jp z,ner_end
0925+  1CBE             ; Now grab the 8390 header
0926+  1CBE 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
0927+  1CC0 08           eoutb(E8390_CMD)
0927+  1CC1 3A 80 EA    
0927+  1CC4 C6 00       
0927+  1CC6 4F          
0927+  1CC7 08          
0927+  1CC8 ED 79       
0928+  1CCA 3E 04        ld a,pkthdr_size
0929+  1CCC 47           ld b,a
0930+  1CCD 08           eoutb(EN0_RCNTLO)
0930+  1CCE 3A 80 EA    
0930+  1CD1 C6 0A       
0930+  1CD3 4F          
0930+  1CD4 08          
0930+  1CD5 ED 79       
0931+  1CD7 AF           xor a
0932+  1CD8 08           eoutb(EN0_RCNTHI)
0932+  1CD9 3A 80 EA    
0932+  1CDC C6 0B       
0932+  1CDE 4F          
0932+  1CDF 08          
0932+  1CE0 ED 79       
0933+  1CE2 08           eoutb(EN0_RSARLO)
0933+  1CE3 3A 80 EA    
0933+  1CE6 C6 08       
0933+  1CE8 4F          
0933+  1CE9 08          
0933+  1CEA ED 79       
0934+  1CEC 7B           ld a,e
0935+  1CED 08           eoutb(EN0_RSARHI)
0935+  1CEE 3A 80 EA    
0935+  1CF1 C6 09       
0935+  1CF3 4F          
0935+  1CF4 08          
0935+  1CF5 ED 79       
0936+  1CF7 3E 0A        ld a,E8390_RREAD+E8390_START
0937+  1CF9 08           eoutb(E8390_CMD)
0937+  1CFA 3A 80 EA    
0937+  1CFD C6 00       
0937+  1CFF 4F          
0937+  1D00 08          
0937+  1D01 ED 79       
0938+  1D03 3A 80 EA     ld a,(ethbase)
0939+  1D06 C6 10        add a,NE_DATAPORT
0940+  1D08 4F           ld c,a
0941+  1D09 21 16 EB     ld hl,pkthdr
0942+  1D0C 3A AC EA     ld a,(ethwrdlen)
0943+  1D0F FE 02        cp 2
0944+  1D11 C2 25 1D     jp nz,ner_hdrbybyte
0945+  1D14 CB 38        srl b
0946+  1D16             ner_wloop:
0947+  1D16 ED 78        in a,(c)
0948+  1D18 77           ld (hl),a
0949+  1D19 23           inc hl
0950+  1D1A DB C0        in a,(ethcom)
0951+  1D1C 77           ld (hl),a
0952+  1D1D 23           inc hl
0953+  1D1E 05           dec b
0954+  1D1F C2 16 1D     jp nz,ner_wloop
0955+  1D22 C3 2D 1D     jp ner_hdrcopied
0956+  1D25             ner_hdrbybyte:
0957+  1D25 ED 78        in a,(c)
0958+  1D27 77           ld (hl),a
0959+  1D28 23           inc hl
0960+  1D29 05           dec b
0961+  1D2A C2 16 1D     jp nz,ner_wloop
0962+  1D2D             ner_hdrcopied:
0963+  1D2D 3E 40        ld a,ENISR_RDC
0964+  1D2F 08           eoutb(EN0_ISR)
0964+  1D30 3A 80 EA    
0964+  1D33 C6 07       
0964+  1D35 4F          
0964+  1D36 08          
0964+  1D37 ED 79       
0965+  1D39             ;
0966+  1D39 2A 18 EB     ld hl,(pkthdr_count)
0967+  1D3C 54           ld d,h
0968+  1D3D 3E 04        ld a,pkthdr_size
0969+  1D3F             ner_pkthdrdec:
0970+  1D3F 2B           dec hl
0971+  1D40 3D           dec a
0972+  1D41 20 FC        jr nz,ner_pkthdrdec
0973+  1D43 22 18 EB     ld (pkthdr_count),hl
0974+  1D46 14           inc d
0975+  1D47 7B           ld a,e
0976+  1D48 82           add a,d
0977+  1D49 ED 5B 17 EB  ld de,(pkthdr_next)
0978+  1D4D             ; Bogosity test
0979+  1D4D             ; Aaargh!! This kind of testing can be awful to do with assembly:
0980+  1D4D             ; (cut from ne.c, linux kernel drivers)
0981+  1D4D             ; "if (rx_frame.next != next_frame
0982+  1D4D             ;   && rx_frame.next != next_frame + 1
0983+  1D4D             ;   && rx_frame.next != next_frame - num_rx_pages
0984+  1D4D             ;   && rx_frame.next != next_frame + 1 - num_rx_pages) {"
0985+  1D4D             ;
0986+  1D4D             ;rx_frame.next != next_frame 
0987+  1D4D BB           cp e
0988+  1D4E CA 84 1D     jp z,ner_bogend
0989+  1D51             ;rx_frame.next != next_frame + 1
0990+  1D51 3C           inc a
0991+  1D52 BB           cp e
0992+  1D53 CA 84 1D     jp z,ner_bogend
0993+  1D56             ;rx_frame.next != next_frame + 1 - num_rx_pages
0994+  1D56 ED 4B B3 EA  ld bc,(ethStopPage)
0995+  1D5A 81           add a,c
0996+  1D5B ED 4B B2 EA  ld bc,(erxStartPage)
0997+  1D5F 91           sub c
0998+  1D60 BB           cp e
0999+  1D61 CA 84 1D     jp z,ner_bogend
1000+  1D64             ;rx_frame.next != next_frame - num_rx_pages
1001+  1D64 3D           dec a
1002+  1D65 BB           cp e
1003+  1D66 CA 84 1D     jp z,ner_bogend
1004+  1D69             ;
1005+  1D69 3A 7C EB     ld a,(NT0)
1006+  1D6C 32 B4 EA     ld (ethCurrentPage),a
1007+  1D6F 3D           dec a
1008+  1D70 08           eoutb(EN0_BOUNDARY)
1008+  1D71 3A 80 EA    
1008+  1D74 C6 03       
1008+  1D76 4F          
1008+  1D77 08          
1008+  1D78 ED 79       
1009+  1D7A 2A F2 EA     ld hl,(ethRxErrs)
1010+  1D7D 23           inc hl
1011+  1D7E 22 F2 EA     ld (ethRxErrs),hl
1012+  1D81 C3 72 1C     jp ner_loop
1013+  1D84             ; bogosity test end
1014+  1D84             ner_bogend:
1015+  1D84 3A 19 EB     ld a,(pkthdr_count+1)
1016+  1D87 FE 00        cp $00
1017+  1D89 C2 A5 1D     jp nz,ner_bigpkt
1018+  1D8C 3A 18 EB     ld a,(pkthdr_count)
1019+  1D8F FE 3C        cp $3c
1020+  1D91 D2 B8 1D     jp nc,ner_pktsizeok
1021+  1D94             ner_pktsizenok:
1022+  1D94 2A F2 EA     ld hl,(ethRxErrs)
1023+  1D97 23           inc hl
1024+  1D98 22 F2 EA     ld (ethRxErrs),hl
1025+  1D9B 2A F6 EA     ld hl,(ethRxLenErrs)
1026+  1D9E 23           inc hl
1027+  1D9F 22 F6 EA     ld (ethRxLenErrs),hl
1028+  1DA2 C3 DF 1E     jp ner_nend
1029+  1DA5             ner_bigpkt:
1030+  1DA5 ED 5B 18 EB  ld de,(pkthdr_count)
1031+  1DA9 3E 05        ld a,$05
1032+  1DAB BA           cp d
1033+  1DAC DA 94 1D     jp c,ner_pktsizenok
1034+  1DAF C2 B8 1D     jp nz,ner_pktsizeok
1035+  1DB2 3E EE        ld a,$ee
1036+  1DB4 BB           cp e
1037+  1DB5 DA 94 1D     jp c,ner_pktsizenok
1038+  1DB8             ner_pktsizeok:
1039+  1DB8             ;
1040+  1DB8 3A 16 EB     ld a,(pkthdr_stat)
1041+  1DBB E6 0F        and $0f
1042+  1DBD FE 01        cp ENRSR_RXOK
1043+  1DBF C2 C2 1E     jp nz,ner_else
1044+  1DC2             ; The packet is really a packet and it's OK!!!
1045+  1DC2             ; Now it can be handled!
1046+  1DC2             ; Copy the packet from NIC to local memory
1047+  1DC2             ; Same as linux drivers ne_block_input-routine
1048+  1DC2             ; First check for free space in packet buffer
1049+  1DC2             #ifdef DEBUG_DRIVERS
1050+  1DC2 3E 00        ld a,0
1051+  1DC4 0E 02        ld c,SSeg2
1052+  1DC6 CD B1 00     call n_to_7seg
1053+  1DC9             #endif
1054+  1DC9 2A 18 EB     ld hl,(pkthdr_count)
1055+  1DCC 22 F8 CF     ld (netDataLen),hl
1056+  1DCF CD 94 20     call net_checkspace
1057+  1DD2 FE FF        cp nBufNoSpace
1058+  1DD4 CA 5E 1E     jp z,ner_nospace
1059+  1DD7             ;
1060+  1DD7 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
1061+  1DD9 08           eoutb(NE_CMD)
1061+  1DDA 3A 80 EA    
1061+  1DDD C6 00       
1061+  1DDF 4F          
1061+  1DE0 08          
1061+  1DE1 ED 79       
1062+  1DE3 3A 18 EB     ld a,(pkthdr_count)
1063+  1DE6 08           eoutb(EN0_RCNTLO)
1063+  1DE7 3A 80 EA    
1063+  1DEA C6 0A       
1063+  1DEC 4F          
1063+  1DED 08          
1063+  1DEE ED 79       
1064+  1DF0 3A 19 EB     ld a,(pkthdr_count+1)
1065+  1DF3 08           eoutb(EN0_RCNTHI)
1065+  1DF4 3A 80 EA    
1065+  1DF7 C6 0B       
1065+  1DF9 4F          
1065+  1DFA 08          
1065+  1DFB ED 79       
1066+  1DFD 3E 04        ld a,pkthdr_size
1067+  1DFF 08           eoutb(EN0_RSARLO)
1067+  1E00 3A 80 EA    
1067+  1E03 C6 08       
1067+  1E05 4F          
1067+  1E06 08          
1067+  1E07 ED 79       
1068+  1E09 3A 7D EB     ld a,(NT1)
1069+  1E0C 08           eoutb(EN0_RSARHI)
1069+  1E0D 3A 80 EA    
1069+  1E10 C6 09       
1069+  1E12 4F          
1069+  1E13 08          
1069+  1E14 ED 79       
1070+  1E16 3E 0A        ld a,E8390_RREAD+E8390_START
1071+  1E18 08           eoutb(NE_CMD)
1071+  1E19 3A 80 EA    
1071+  1E1C C6 00       
1071+  1E1E 4F          
1071+  1E1F 08          
1071+  1E20 ED 79       
1072+  1E22             ; Registers ready, start copying
1073+  1E22 ED 5B 18 EB  ld de,(pkthdr_count)
1074+  1E26 ED 53 F8 CF  ld (netDataLen),de
1075+  1E2A 3A 80 EA     ld a,(ethbase)
1076+  1E2D C6 10        add a,NE_DATAPORT
1077+  1E2F 32 FD CF     ld (netIOCopyPort),a
1078+  1E32 3E 00        ld a,nBufCopyIO
1079+  1E34 32 FC CF     ld (netCopyType),a
1080+  1E37             #ifdef DEBUG_DRIVERS
1081+  1E37 3E 01        ld a,1
1082+  1E39 0E 02        ld c,SSeg2
1083+  1E3B CD B1 00     call n_to_7seg
1084+  1E3E             #endif
1085+  1E3E CD 97 20     call net_allocbuffer
1086+  1E41 FE FF        cp nBufNoSpace
1087+  1E43 C2 77 1E     jp nz,ner_copyok
1088+  1E46             ; Should this be handled in this way?
1089+  1E46             ; Anyway something is really wrong if this is needed
1090+  1E46 3E 21        ld a,E8390_NODMA+E8390_PAGE0+E8390_STOP
1091+  1E48 08           eoutb(NE_CMD)
1091+  1E49 3A 80 EA    
1091+  1E4C C6 00       
1091+  1E4E 4F          
1091+  1E4F 08          
1091+  1E50 ED 79       
1092+  1E52 3E 22        ld a,E8390_NODMA+E8390_PAGE0+E8390_START
1093+  1E54 08           eoutb(NE_CMD)
1093+  1E55 3A 80 EA    
1093+  1E58 C6 00       
1093+  1E5A 4F          
1093+  1E5B 08          
1093+  1E5C ED 79       
1094+  1E5E             ner_nospace:
1095+  1E5E             #ifdef DEBUG_DRIVERS
1096+  1E5E 3E 02        ld a,2
1097+  1E60 0E 02        ld c,SSeg2
1098+  1E62 CD B1 00     call n_to_7seg
1099+  1E65             #endif
1100+  1E65 2A 08 EB     ld hl,(ethRxDropped)
1101+  1E68 23           inc hl
1102+  1E69 22 08 EB     ld (ethRxDropped),hl
1103+  1E6C             #ifdef DEBUG_DRIVERS
1104+  1E6C 3A 08 EB     ld a,(ethRxDropped)
1105+  1E6F 0E 03        ld c,SSeg3
1106+  1E71 CD CB 00     call b_to_7seg
1107+  1E74             #endif
1108+  1E74 C3 0D 1F     jp ner_end
1109+  1E77             ner_copyok:
1110+  1E77             #ifdef DEBUG_DRIVERS
1111+  1E77 3E 03        ld a,3
1112+  1E79 0E 02        ld c,SSeg2
1113+  1E7B CD B1 00     call n_to_7seg
1114+  1E7E             #endif
1115+  1E7E 3E 40        ld a,ENISR_RDC
1116+  1E80 08           eoutb(EN0_ISR)
1116+  1E81 3A 80 EA    
1116+  1E84 C6 07       
1116+  1E86 4F          
1116+  1E87 08          
1116+  1E88 ED 79       
1117+  1E8A             ; Update rx packet counter and rx byte counter
1118+  1E8A 2A F8 EA     ld hl,(ethRxPackets)
1119+  1E8D 11 01 00     ld de,1
1120+  1E90 19           add hl,de
1121+  1E91 22 F8 EA     ld (ethRxPackets),hl
1122+  1E94 2A FA EA     ld hl,(ethRxPackets+2)
1123+  1E97 1E 00        ld e,0
1124+  1E99 ED 5A        adc hl,de
1125+  1E9B 22 FA EA     ld (ethRxPackets+2),hl
1126+  1E9E 2A 00 EB     ld hl,(ethRxBytes)
1127+  1EA1 ED 5B 18 EB  ld de,(pkthdr_count)
1128+  1EA5 19           add hl,de
1129+  1EA6 22 00 EB     ld (ethRxBytes),hl
1130+  1EA9 2A 02 EB     ld hl,(ethRxBytes+2)
1131+  1EAC 11 00 00     ld de,0
1132+  1EAF ED 5A        adc hl,de
1133+  1EB1 22 02 EB     ld (ethRxBytes+2),hl
1134+  1EB4             #ifdef DEBUG_DRIVERS
1135+  1EB4 3A F8 EA     ld a,(ethRxPackets)
1136+  1EB7 0E 03        ld c,SSeg3
1137+  1EB9 CD CB 00     call b_to_7seg
1138+  1EBC             #endif
1139+  1EBC             ; Call packet handler
1140+  1EBC CD A0 20     call net_handlepacket
1141+  1EBF C3 DF 1E     jp ner_nend
1142+  1EC2             ;
1143+  1EC2             ner_else:
1144+  1EC2             #ifdef DEBUG_DRIVERS
1145+  1EC2 3E 04        ld a,4
1146+  1EC4 0E 02        ld c,SSeg2
1147+  1EC6 CD B1 00     call n_to_7seg
1148+  1EC9             #endif
1149+  1EC9 2A F2 EA     ld hl,(ethRxErrs)
1150+  1ECC 23           inc hl
1151+  1ECD 22 F2 EA     ld (ethRxErrs),hl
1152+  1ED0 3A 16 EB     ld a,(pkthdr_stat)
1153+  1ED3 E6 08        and ENRSR_FO
1154+  1ED5 CA DF 1E     jp z,ner_nend
1155+  1ED8 2A F4 EA     ld hl,(ethRxFifoErrs)
1156+  1EDB 23           inc hl
1157+  1EDC 22 F4 EA     ld (ethRxFifoErrs),hl
1158+  1EDF             ner_nend:
1159+  1EDF             #ifdef DEBUG_DRIVERS
1160+  1EDF 3E 05        ld a,5
1161+  1EE1 0E 02        ld c,SSeg2
1162+  1EE3 CD B1 00     call n_to_7seg
1163+  1EE6             #endif
1164+  1EE6 3A B3 EA     ld a,(ethStopPage)
1165+  1EE9 3D           dec a
1166+  1EEA 21 17 EB     ld hl,pkthdr_next
1167+  1EED BE           cp (hl)
1168+  1EEE D2 FB 1E     jp nc,nerp_nbadbad
1169+  1EF1             #ifdef DEBUG_DRIVERS
1170+  1EF1 3E 06        ld a,6
1171+  1EF3 0E 02        ld c,SSeg2
1172+  1EF5 CD B1 00     call n_to_7seg
1173+  1EF8             #endif
1174+  1EF8 21 B2 EA     ld hl,erxStartPage
1175+  1EFB             nerp_nbadbad:
1176+  1EFB 7E           ld a,(hl)
1177+  1EFC 32 B4 EA     ld (ethCurrentPage),a
1178+  1EFF 3D           dec a
1179+  1F00 08           eoutb(EN0_BOUNDARY)
1179+  1F01 3A 80 EA    
1179+  1F04 C6 03       
1179+  1F06 4F          
1179+  1F07 08          
1179+  1F08 ED 79       
1180+  1F0A C3 72 1C     jp ner_loop
1181+  1F0D             ;
1182+  1F0D             ner_end:
1183+  1F0D 3E 05        ld a,ENISR_RX+ENISR_RX_ERR
1184+  1F0F 08           eoutb(EN0_ISR)
1184+  1F10 3A 80 EA    
1184+  1F13 C6 07       
1184+  1F15 4F          
1184+  1F16 08          
1184+  1F17 ED 79       
1185+  1F19 D1           pop de
1186+  1F1A C1           pop bc
1187+  1F1B E1           pop hl
1188+  1F1C F1           pop af
1189+  1F1D C9           ret
1190+  1F1E             ; end of ne_receive
1191+  1F1E             
1192+  1F1E             ; *******************************
1193+  1F1E             ; ne_send
1194+  1F1E             ; Packet's address in ethDataAddr, lenght in
1195+  1F1E             ; ethDataLen and start page in ethDataPage
1196+  1F1E 54696D656F75nes_timeout     .db "Timeout for Tx RDC.",LOGSP,EOL
1196+  1F24 7420666F72205478205244432EFF17
1197+  1F33             
1198+  1F33             jne_send:
1199+  1F33 E1           pop hl
1200+  1F34             ne_send:
1201+  1F34 3A 80 EA     einb(NE_CMD)           ; Is NIC already sending?
1201+  1F37 C6 00       
1201+  1F39 4F          
1201+  1F3A ED 78       
1202+  1F3C FE 26        cp $26
1203+  1F3E 3E 26        ld a,eSending          ; If, return eSending in reg a
1204+  1F40 C8           ret z                  ;
1205+  1F41 C5           push bc
1206+  1F42 D5           push de
1207+  1F43 E5           push hl
1208+  1F44 F3           di
1209+  1F45 3A AC EA     ld a,(ethwrdlen)
1210+  1F48 FE 02        cp 2                   ; Check for odd byte count if
1211+  1F4A C2 58 1F     jp nz,nes_nodd         ; in word mode (is this needed really?)
1212+  1F4D 2A D2 EA     ld hl,(ethDataLen)
1213+  1F50 23           inc hl
1214+  1F51 7D           ld a,l
1215+  1F52 E6 FE        and $fe
1216+  1F54 6F           ld l,a
1217+  1F55 22 D2 EA     ld (ethDataLen),hl
1218+  1F58             nes_nodd:
1219+  1F58 3E 22        ld a,E8390_PAGE0+E8390_START+E8390_NODMA
1220+  1F5A 08           eoutb(NE_CMD)
1220+  1F5B 3A 80 EA    
1220+  1F5E C6 00       
1220+  1F60 4F          
1220+  1F61 08          
1220+  1F62 ED 79       
1221+  1F64 3E 40        ld a,ENISR_RDC
1222+  1F66 08           eoutb(EN0_ISR)
1222+  1F67 3A 80 EA    
1222+  1F6A C6 07       
1222+  1F6C 4F          
1222+  1F6D 08          
1222+  1F6E ED 79       
1223+  1F70 3A D2 EA     ld a,(ethDataLen)
1224+  1F73 08           eoutb(EN0_RCNTLO)
1224+  1F74 3A 80 EA    
1224+  1F77 C6 0A       
1224+  1F79 4F          
1224+  1F7A 08          
1224+  1F7B ED 79       
1225+  1F7D 3A D3 EA     ld a,(ethDataLen+1)
1226+  1F80 08           eoutb(EN0_RCNTHI)
1226+  1F81 3A 80 EA    
1226+  1F84 C6 0B       
1226+  1F86 4F          
1226+  1F87 08          
1226+  1F88 ED 79       
1227+  1F8A 3A D4 EA     ld a,(ethDataPage)
1228+  1F8D 08           eoutb(EN0_RSARLO)
1228+  1F8E 3A 80 EA    
1228+  1F91 C6 08       
1228+  1F93 4F          
1228+  1F94 08          
1228+  1F95 ED 79       
1229+  1F97 3A D5 EA     ld a,(ethDataPage+1)
1230+  1F9A 08           eoutb(EN0_RSARHI)
1230+  1F9B 3A 80 EA    
1230+  1F9E C6 09       
1230+  1FA0 4F          
1230+  1FA1 08          
1230+  1FA2 ED 79       
1231+  1FA4 3E 12        ld a,E8390_RWRITE+E8390_START
1232+  1FA6 08           eoutb(NE_CMD)
1232+  1FA7 3A 80 EA    
1232+  1FAA C6 00       
1232+  1FAC 4F          
1232+  1FAD 08          
1232+  1FAE ED 79       
1233+  1FB0 3A 80 EA     ld a,(ethbase)
1234+  1FB3 C6 10        add a,NE_DATAPORT
1235+  1FB5 4F           ld c,a
1236+  1FB6             ; Now copy the data into NIC
1237+  1FB6 3A AC EA     ld a,(ethwrdlen)
1238+  1FB9 FE 02        cp 2																			; Is the card 16bit or 8bit?
1239+  1FBB C2 E0 1F     jp nz,nes_sendbybyte   ; Is the card 8- or 16-bit
1240+  1FBE ED 5B D2 EA  ld de,(ethDataLen)
1241+  1FC2 CB 3A        srl d                  ; Divide de's value by 2
1242+  1FC4 CB 1B        rr e
1243+  1FC6 14           inc d
1244+  1FC7 2A D0 EA     ld hl,(ethDataAddr)
1245+  1FCA             nes_sendbyword:
1246+  1FCA 46           ld b,(hl)
1247+  1FCB 23           inc hl
1248+  1FCC 7E           ld a,(hl)
1249+  1FCD 23           inc hl
1250+  1FCE D3 C0        out (ethcom),a
1251+  1FD0 ED 41        out (c),b
1252+  1FD2 1D           dec e
1253+  1FD3 C2 CA 1F     jp nz,nes_sendbyword
1254+  1FD6 15           dec d
1255+  1FD7 C2 CA 1F     jp nz,nes_sendbyword
1256+  1FDA AF           xor a                  ; Must stay in page 0 of flash, because
1257+  1FDB D3 C0        out (ethcom),a         ; lot's of network code is there
1258+  1FDD C3 E8 1F     jp nes_nsend
1259+  1FE0             nes_sendbybyte:
1260+  1FE0             ; 8-bit card not supported yet
1261+  1FE0 AF           xor a                  ; Must stay in page 0 of flash, because
1262+  1FE1 D3 C0        out (ethcom),a         ; lot's of network code is there
1263+  1FE3 3E 17        ld a,eSended
1264+  1FE5 C3 5A 20     jp nes_end
1265+  1FE8             nes_nsend:
1266+  1FE8 3A 80 EA     ld a,(ethbase)
1267+  1FEB C6 07        add a,EN0_ISR
1268+  1FED 4F           ld c,a
1269+  1FEE 21 E0 15     ld hl,WaitForTimeout
1270+  1FF1             nes_wait:               ; Should wait here about 20ms
1271+  1FF1 2B           dec hl
1272+  1FF2 7C           ld a,h
1273+  1FF3 FE 00        cp 0
1274+  1FF5 CA 43 20     jp z,nes_timedout
1275+  1FF8 ED 78        in a,(c)
1276+  1FFA E6 40        and ENISR_RDC
1277+  1FFC CA F1 1F     jp z,nes_wait
1278+  1FFF             nes_pos:
1279+  1FFF 3E 40        ld a,ENISR_RDC
1280+  2001 08           eoutb((EN0_ISR)
1280+  2002 3A 80 EA    
1280+  2005 C6 07       
1280+  2007 4F          
1280+  2008 08          
1280+  2009 ED 79       
1281+  200B 3A D5 EA     ld a,(ethDataPage+1)
1282+  200E 08           eoutb(EN0_TPSR)
1282+  200F 3A 80 EA    
1282+  2012 C6 04       
1282+  2014 4F          
1282+  2015 08          
1282+  2016 ED 79       
1283+  2018 3A D2 EA     ld a,(ethDataLen)
1284+  201B 08           eoutb(EN0_TCNTLO)
1284+  201C 3A 80 EA    
1284+  201F C6 05       
1284+  2021 4F          
1284+  2022 08          
1284+  2023 ED 79       
1285+  2025 3A D3 EA     ld a,(ethDataLen+1)
1286+  2028 08           eoutb(EN0_TCNTHI)
1286+  2029 3A 80 EA    
1286+  202C C6 06       
1286+  202E 4F          
1286+  202F 08          
1286+  2030 ED 79       
1287+  2032 3E 26        ld a,E8390_NODMA+E8390_TRANS+E8390_START
1288+  2034 08           eoutb(NE_CMD)
1288+  2035 3A 80 EA    
1288+  2038 C6 00       
1288+  203A 4F          
1288+  203B 08          
1288+  203C ED 79       
1289+  203E 3E 17        ld a,eSended
1290+  2040 C3 5A 20     jp nes_end
1291+  2043             nes_timedout:
1292+  2043 3A B5 EA     ld a,(NetLogId)
1293+  2046 21 1E 1F     ld hl,nes_timeout
1294+  2049 CD BD 05     call AddLog            ; This message is seen in Net log(1)
1295+  204C CD 62 20     call ne_reset
1296+  204F CD 21 16     call DP8390_init
1297+  2052 CD 2C 17     call DP8390_enable
1298+  2055 3E 69        ld a,eTimedOut
1299+  2057 C3 5A 20     jp nes_end
1300+  205A             nes_end:
1301+  205A F5           push af
1302+  205B F1           pop af
1303+  205C E1           pop hl
1304+  205D D1           pop de
1305+  205E C1           pop bc
1306+  205F FB           ei
1307+  2060 C9           ret
1308+  2061             
1309+  2061             ; end of ne_send
1310+  2061             
1311+  2061             ; *******************************
1312+  2061             ; ne_reset
1313+  2061             jne_reset:
1314+  2061 E1           pop hl
1315+  2062             ne_reset:
1316+  2062 C5           push bc
1317+  2063 E5           push hl
1318+  2064 3A 80 EA     ld a,(ethbase)
1319+  2067 C6 1F        add a,NE_RESET
1320+  2069 4F           ld c,a
1321+  206A ED 78        in a,(c)
1322+  206C ED 79        out (c),a
1323+  206E 21 00 10     ld hl,$1000
1324+  2071 3A 80 EA     ld a,(ethbase)
1325+  2074 C6 07        add a,EN0_ISR
1326+  2076 4F           ld c,a
1327+  2077             ners_wait:
1328+  2077 2B           dec hl
1329+  2078 7C           ld a,h
1330+  2079 FE 00        cp 0
1331+  207B 28 0F        jr z,ners_failed
1332+  207D ED 78        in a,(c)
1333+  207F E6 80        and ENISR_RESET
1334+  2081 28 F4        jr z,ners_wait
1335+  2083 3E FF        ld a,$ff
1336+  2085 ED 79        out (c),a
1337+  2087 3E 17        ld a,$17
1338+  2089 E1           pop hl
1339+  208A C1           pop bc
1340+  208B C9           ret
1341+  208C             ners_failed:
1342+  208C 3E 69        ld a,$69
1343+  208E E1           pop hl
1344+  208F C1           pop bc
1345+  2090 C9           ret
1346+  2091             ; end of ne_reset
1347+  2091             
1348+  2091             ; end of NEx000 compatible adapters driver
1349+  2091             ;**************************************************************
1350+  2091             
1351+  2091             ; end of Drivers
1352+  2091             ;**************************************************************
2775   2091             #include "flash.asm"
0001+  2091             ;**************************************************************
0002+  2091             ;
0003+  2091             ; FLASH.asm
0004+  2091             ;       version 008
0005+  2091             ;
0006+  2091             ; Here is routines and such for network mostly
0007+  2091             ; Some other miscellaneous code also... 
0008+  2091             
0009+  2091             ; Enable some of these to use LEDs and 7segments for debugging
0010+  2091             ;#define DEBUG_MM        ; DEBUG when running memory manager code
0011+  2091             ;#define DEBUG_TCPIP     ; DEBUG when running TCP/IP code
0012+  2091             
0013+  2091             ;#define ALONE
0014+  2091             
0015+  2091~            #ifdef ALONE
0016+  2091~            #include "OSdef.h"
0017+  2091~            #include "drivers.asm"
0018+  2091             #endif
0019+  2091             
0020+  2091             ; Jump table
0021+  2091             net_init:
0022+  2091 C3 83 22     jp nnet_init
0023+  2094             net_checkspace:
0024+  2094 C3 DD 20     jp nnet_checkspace
0025+  2097             net_allocbuffer:
0026+  2097 C3 29 21     jp nnet_allocbuffer
0027+  209A             net_freebuffer:
0028+  209A C3 38 22     jp nnet_freebuffer
0029+  209D             net_resetbuf:
0030+  209D C3 A3 20     jp nnet_resetbuf
0031+  20A0             net_handlepacket:
0032+  20A0 C3 88 22     jp nnet_handlepacket
0033+  20A3             
0034+  20A3             ;**************************************************************
0035+  20A3             ;
0036+  20A3             ; code for TCP/IP & ARP support
0037+  20A3             ;
0038+  20A3             ;**************************************************************
0039+  20A3             
0040+  20A3             ; #defines
0041+  20A3             #define ARP_PACKET $0806
0042+  20A3             #define IP_PACKET  $0800
0043+  20A3             ;
0044+  20A3             #define HWTYPE_ETH 1            ; No support for others than ethernet (probably)
0045+  20A3             #define OPCODE_ARPREQ 1         ; ARP-request
0046+  20A3             #define OPCODE_ARPREP 2         ; ARP-reply
0047+  20A3             ;
0048+  20A3             #define nBufPages 12
0049+  20A3             #define nBufTocs 8
0050+  20A3             #define nBufTocMaxPages 6
0051+  20A3             #define nBufPageSize 256
0052+  20A3             #define nBufMaxSize nBufTocMaxPages*nBufPageSize
0053+  20A3             #define nBuf1TocSize 10
0054+  20A3             #define nBufTocSize nBufTocs*nBuf1TocSize
0055+  20A3             ;
0056+  20A3             #define nBufTocStat 0           ;byte
0057+  20A3             #define nBufTocNPages 1         ;byte
0058+  20A3             #define nBufTocSize 2           ;word
0059+  20A3             #define nBufTocPages  4         ;6 bytes
0060+  20A3             ;
0061+  20A3             #define nBufferRead 1
0062+  20A3             #define nBufferWrite 2
0063+  20A3             #define nBufPageReserved 1
0064+  20A3             #define nBufTocReserved 1
0065+  20A3             ; ARP table
0066+  20A3             #define nArpTables 16
0067+  20A3             #define nArp1TabSize 12
0068+  20A3             #define nArpTabSize nArpTables*nArp1TabSize
0069+  20A3             #define nArpTabStat 0           ;byte
0070+  20A3             #define nArpTabDate 1           ;byte
0071+  20A3             #define nArpTabMAC 2            ;6 bytes
0072+  20A3             #define nArpTabIp 8             ;4 bytes
0073+  20A3             
0074+  20A3             ;
0075+  20A3             nBufCopyIO      equ 0
0076+  20A3             nBufCopyMem     equ 1
0077+  20A3             nBufNoSpace     equ $ff
0078+  20A3             nBufNoId        equ $ff
0079+  20A3             ;
0080+  20A3             nArpDate        equ 40
0081+  20A3             
0082+  20A3             ; RAM at address $c000-$dfff
0083+  20A3             NETB            equ $c000       ;4KB of RAM for use of network
0084+  20A3             NETBL           equ NETB+$1000
0085+  20A3             ;
0086+  20A3             netBuffer       equ NETB+0      ;Reserves 12*256 bytes as buffer for received
0087+  20A3                                             ;and queue transmit packets
0088+  20A3             ;
0089+  20A3             netBufToc       equ NETB+3072   ;8*10 bytes
0090+  20A3             netArpTable     equ NETB+3152   ;16*12 bytes
0091+  20A3             ;
0092+  20A3             netMacAddress   equ NETBL-31    ;6 bytes, for MAC address
0093+  20A3             netIpAddress    equ NETBL-25    ;4 bytes, for IP address
0094+  20A3             netBufStat      equ NETBL-21    ;12 bytes, 1 for each buffer page
0095+  20A3             netBufUsedPages equ NETBL-9     ;byte
0096+  20A3             netDataLen      equ NETBL-8     ;word
0097+  20A3             netDataAddr     equ NETBL-6     ;word
0098+  20A3             netCopyType     equ NETBL-4     ;byte
0099+  20A3             netIOCopyPort   equ NETBL-3     ;byte
0100+  20A3             netBufStatus    equ NETBL-2     ;byte
0101+  20A3             netBufTemp      equ NETBL-1     ;byte
0102+  20A3             netBufTocId     equ NETBL-0     ;byte
0103+  20A3             
0104+  20A3             ;**************************************************************
0105+  20A3             ; Network buffer memory manager
0106+  20A3             
0107+  20A3             ; *******************************
0108+  20A3             ; net_resetbuf
0109+  20A3             nnet_resetbuf:
0110+  20A3 F5           push af
0111+  20A4 C5           push bc
0112+  20A5 E5           push hl
0113+  20A6 01 4F 00     ld bc,nBufTocSize-1
0114+  20A9 21 00 CC     ld hl,netBufToc
0115+  20AC 11 01 CC     ld de,netBufToc+1
0116+  20AF 36 00        ld (hl),0
0117+  20B1 ED B0        ldir
0118+  20B3 01 0B 00     ld bc,nBufPages-1
0119+  20B6 21 EB CF     ld hl,netBufStat
0120+  20B9 11 EC CF     ld de,netBufStat+1
0121+  20BC 36 00        ld (hl),0
0122+  20BE ED B0        ldir
0123+  20C0 01 BF 00     ld bc,nArpTabSize-1
0124+  20C3 21 50 CC     ld hl,netArpTable
0125+  20C6 11 51 CC     ld de,netArpTable+1
0126+  20C9 36 00        ld (hl),0
0127+  20CB ED B0        ldir
0128+  20CD AF           xor a
0129+  20CE 32 F7 CF     ld (netBufUsedPages),a
0130+  20D1 32 FE CF     ld (netBufStatus),a
0131+  20D4 3E FF        ld a,nBufNoSpace
0132+  20D6 32 00 D0     ld (netBufTocId),a
0133+  20D9 E1           pop hl
0134+  20DA C1           pop bc
0135+  20DB F1           pop af
0136+  20DC C9           ret
0137+  20DD             ; end of net_resetbuf
0138+  20DD             
0139+  20DD             ; *******************************
0140+  20DD             ; net_checkspace
0141+  20DD             ; Checks for free space in network buffer and if there is
0142+  20DD             ; enough space returns free TOC's ID in (netBudTocId) and
0143+  20DD             ; reg a, otherwise returns nBufNoSpace in reg a
0144+  20DD             nnet_checkspace:
0145+  20DD C5           push bc
0146+  20DE D5           push de
0147+  20DF E5           push hl
0148+  20E0~            #ifdef DEBUG_MM
0149+  20E0~             ld a,1
0150+  20E0~             ld c,SSeg1
0151+  20E0~             call n_to_7seg
0152+  20E0             #endif
0153+  20E0 ED 4B F8 CF  ld bc,(netDataLen)
0154+  20E4 AF           xor a
0155+  20E5 B8           cp b
0156+  20E6 C2 EF 20     jp nz,ntc_nzero
0157+  20E9 B9           cp c
0158+  20EA 3E FF        ld a,nBufNoSpace
0159+  20EC CA 25 21     jp z,ntc_end
0160+  20EF             ntc_nzero:
0161+  20EF 0B           dec bc
0162+  20F0 3E 06        ld a,nBufMaxSize/256
0163+  20F2 B8           cp b
0164+  20F3 3E FF        ld a,nBufNoSpace
0165+  20F5 DA 25 21     jp c,ntc_end
0166+  20F8 CA 25 21     jp z,ntc_end
0167+  20FB 04           inc b
0168+  20FC 3A F7 CF     ld a,(netBufUsedPages)
0169+  20FF 80           add a,b
0170+  2100 3D           dec a
0171+  2101 FE 0C        cp nBufPages
0172+  2103 3E FF        ld a,nBufNoSpace
0173+  2105 D2 25 21     jp nc,ntc_end
0174+  2108 21 00 CC     ld hl,netBufToc+nBufTocStat
0175+  210B 11 0A 00     ld de,nBuf1TocSize
0176+  210E 0E 08        ld c,nBufTocs
0177+  2110 AF           xor a
0178+  2111             ntc_findfreetoc:
0179+  2111 BE           cp (hl)
0180+  2112 CA 1F 21     jp z,ntc_fftoc
0181+  2115 19           add hl,de
0182+  2116 0D           dec c
0183+  2117 C2 11 21     jp nz,ntc_findfreetoc
0184+  211A 3E FF        ld a,nBufNoSpace
0185+  211C C3 25 21     jp ntc_end
0186+  211F             ntc_fftoc:
0187+  211F 3E 08        ld a,nBufTocs
0188+  2121 91           sub c
0189+  2122 32 00 D0     ld (netBufTocId),a
0190+  2125             ntc_end:
0191+  2125~            #ifdef DEBUG_MM
0192+  2125~             ld a,2
0193+  2125~             ld c,SSeg1
0194+  2125~             call n_to_7seg
0195+  2125             #endif
0196+  2125 C1           pop bc
0197+  2126 D1           pop de
0198+  2127 E1           pop hl
0199+  2128 C9           ret
0200+  2129             ; end of net_checkspace
0201+  2129             
0202+  2129             ; *******************************
0203+  2129             ; net_allocbuffer
0204+  2129             ; This routine is mostly used by network drivers
0205+  2129             ; Allocates buffer with size stored in (netDataLen) and
0206+  2129             ; copies data to that buffer from address found in
0207+  2129             ; (netDataAddr), returns buffer id (netBufTocId).
0208+  2129             ; Type of copy must be stored in (netCopyType) and port
0209+  2129             ; which to copy from in (netIOCopyPort), types are memory
0210+  2129             ; and io.
0211+  2129             ; If there is no space left returns nBufNoSpace in reg a
0212+  2129             nnet_allocbuffer:
0213+  2129 3A FE CF     ld a,(netBufStatus)            ; This should not happen!
0214+  212C FE 00        cp 0                           ; (That the buffer is already in use)
0215+  212E 3E FF        ld a,nBufNoSpace
0216+  2130 C0           ret nz
0217+  2131 3E 02        ld a,nBufferWrite
0218+  2133 32 FE CF     ld (netBufStatus),a
0219+  2136 C5           push bc
0220+  2137 D5           push de
0221+  2138 E5           push hl
0222+  2139~            #ifdef DEBUG_MM
0223+  2139~             ld a,1
0224+  2139~             ld c,SSeg2
0225+  2139~             call n_to_7seg
0226+  2139~             xor a
0227+  2139~             out (SSeg3),a
0228+  2139             #endif
0229+  2139 ED 4B F8 CF  ld bc,(netDataLen)
0230+  213D AF           xor a
0231+  213E B8           cp b
0232+  213F C2 48 21     jp nz,nta_nzero
0233+  2142 B9           cp c
0234+  2143 3E FF        ld a,nBufNoSpace
0235+  2145 CA 2E 22     jp z,nta_end
0236+  2148             nta_nzero:
0237+  2148 0B           dec bc
0238+  2149 3E 06        ld a,nBufMaxSize/256
0239+  214B B8           cp b
0240+  214C 3E FF        ld a,nBufNoSpace
0241+  214E DA 2E 22     jp c,nta_end
0242+  2151 CA 2E 22     jp z,nta_end
0243+  2154 04           inc b
0244+  2155 3A F7 CF     ld a,(netBufUsedPages)
0245+  2158 80           add a,b
0246+  2159 3D           dec a
0247+  215A FE 0C        cp nBufPages
0248+  215C 3E FF        ld a,nBufNoSpace
0249+  215E D2 2E 22     jp nc,nta_end
0250+  2161 21 00 CC     ld hl,netBufToc+nBufTocStat
0251+  2164 11 0A 00     ld de,nBuf1TocSize
0252+  2167 0E 08        ld c,nBufTocs
0253+  2169 AF           xor a
0254+  216A             nta_findfreetoc:
0255+  216A BE           cp (hl)
0256+  216B CA 78 21     jp z,nta_fftoc
0257+  216E 19           add hl,de
0258+  216F 0D           dec c
0259+  2170 C2 6A 21     jp nz,nta_findfreetoc
0260+  2173 3E FF        ld a,nBufNoSpace
0261+  2175 C3 2E 22     jp nta_end
0262+  2178             nta_fftoc:
0263+  2178             ; There is free TOC and enough free pages (free space)
0264+  2178             ; Now copy the data and set up TOC
0265+  2178~            #ifdef DEBUG_MM
0266+  2178~             push bc
0267+  2178~             ld a,4
0268+  2178~             ld c,SSeg2
0269+  2178~             call n_to_7seg
0270+  2178~             pop bc
0271+  2178             #endif
0272+  2178 3E 08        ld a,nBufTocs
0273+  217A 91           sub c
0274+  217B 32 00 D0     ld (netBufTocId),a             ; Save TOC ID
0275+  217E 3A F7 CF     ld a,(netBufUsedPages)
0276+  2181 80           add a,b
0277+  2182 32 F7 CF     ld (netBufUsedPages),a
0278+  2185 3E 01        ld a,nBufTocReserved
0279+  2187 77           ld (hl),a
0280+  2188 23           inc hl
0281+  2189 70           ld (hl),b
0282+  218A 78           ld a,b
0283+  218B 32 FF CF     ld (netBufTemp),a
0284+  218E 23           inc hl
0285+  218F ED 5B F8 CF  ld de,(netDataLen)
0286+  2193 73           ld (hl),e
0287+  2194 23           inc hl
0288+  2195 72           ld (hl),d
0289+  2196 23           inc hl
0290+  2197 EB           ex de,hl
0291+  2198 21 EA CF     ld hl,netBufStat-1
0292+  219B 0E 0D        ld c,nBufPages+1
0293+  219D D9           exx
0294+  219E ED 5B FA CF  ld de,(netDataAddr)
0295+  21A2 D9           exx
0296+  21A3 AF           xor a
0297+  21A4             nta_pgloop:
0298+  21A4 23           inc hl
0299+  21A5 0D           dec c
0300+  21A6 BE           cp (hl)
0301+  21A7 C2 A4 21     jp nz,nta_pgloop
0302+  21AA 3E 01        ld a,nBufPageReserved
0303+  21AC 77           ld (hl),a
0304+  21AD 3E 0C        ld a,nBufPages
0305+  21AF 91           sub c
0306+  21B0 12           ld (de),a
0307+  21B1 13           inc de
0308+  21B2 D9           exx
0309+  21B3 21 00 C0     ld hl,netBuffer
0310+  21B6 84           add a,h
0311+  21B7 67           ld h,a
0312+  21B8 3A FC CF     ld a,(netCopyType)
0313+  21BB FE 00        cp nBufCopyIO
0314+  21BD C2 1E 22     jp nz,nta_copyfrommem
0315+  21C0             nta_copyfromio:
0316+  21C0~            #ifdef DEBUG_MM
0317+  21C0~             ld a,1
0318+  21C0~             ld c,SSeg3
0319+  21C0~             call n_to_7seg
0320+  21C0             #endif
0321+  21C0 ED 4B FD CF  ld bc,(netIOCopyPort)
0322+  21C4 3A AC EA     ld a,(ethwrdlen)
0323+  21C7 FE 02        cp 2
0324+  21C9 C2 00 22     jp nz,nte_cpbybyte
0325+  21CC 06 80        ld b,$80
0326+  21CE 3A FF CF     ld a,(netBufTemp)
0327+  21D1 3D           dec a
0328+  21D2 32 FF CF     ld (netBufTemp),a
0329+  21D5 C2 DE 21     jp nz,nte_cpbyword
0330+  21D8 3A F8 CF     ld a,(netDataLen)
0331+  21DB CB 3F        srl a
0332+  21DD 47           ld b,a
0333+  21DE             nte_cpbyword:
0334+  21DE ED 78        in a,(c)
0335+  21E0 77           ld (hl),a
0336+  21E1 23           inc hl
0337+  21E2 DB C0        in a,(ethcom)
0338+  21E4 77           ld (hl),a
0339+  21E5 23           inc hl
0340+  21E6 05           dec b
0341+  21E7 C2 DE 21     jp nz,nte_cpbyword
0342+  21EA 3A FF CF     ld a,(netBufTemp)
0343+  21ED FE 00        cp 0
0344+  21EF C2 FD 21     jp nz,nte_cpwnlast
0345+  21F2 3A F8 CF     ld a,(netDataLen)
0346+  21F5 E6 01        and 1
0347+  21F7 CA FD 21     jp z,nte_cpwnlast
0348+  21FA ED 78        in a,(c)
0349+  21FC 77           ld (hl),a
0350+  21FD             nte_cpwnlast:
0351+  21FD C3 12 22     jp nte_iocpend
0352+  2200             nte_cpbybyte:
0353+  2200 06 00        ld b,0
0354+  2202 3A FF CF     ld a,(netBufTemp)
0355+  2205 3D           dec a
0356+  2206 32 FF CF     ld (netBufTemp),a
0357+  2209 C2 10 22     jp nz,nte_cpbnlast
0358+  220C 3A F8 CF     ld a,(netDataLen)
0359+  220F 47           ld b,a
0360+  2210             nte_cpbnlast:
0361+  2210 ED B2        inir                   ; Copy one page from io
0362+  2212             nte_iocpend:
0363+  2212 D9           exx
0364+  2213~            #ifdef DEBUG_MM
0365+  2213~             push bc
0366+  2213~             ld a,2
0367+  2213~             ld c,SSeg3
0368+  2213~             call n_to_7seg
0369+  2213~             pop bc
0370+  2213             #endif
0371+  2213 AF           xor a
0372+  2214 05           dec b
0373+  2215 C2 A4 21     jp nz,nta_pgloop
0374+  2218 3A 00 D0     ld a,(netBufTocId)
0375+  221B C3 2E 22     jp nta_end
0376+  221E             nta_copyfrommem:
0377+  221E~            #ifdef DEBUG_MM
0378+  221E~             ld a,4
0379+  221E~             ld c,SSeg3
0380+  221E~             call n_to_7seg
0381+  221E             #endif
0382+  221E 01 00 01     ld bc,$100
0383+  2221 EB           ex de,hl
0384+  2222 ED B0        ldir                   ; Copy one page from mem
0385+  2224 EB           ex de,hl
0386+  2225 D9           exx
0387+  2226~            #ifdef DEBUG_MM
0388+  2226~             push bc
0389+  2226~             ld a,5
0390+  2226~             ld c,SSeg3
0391+  2226~             call n_to_7seg
0392+  2226~             pop bc
0393+  2226             #endif
0394+  2226 AF           xor a
0395+  2227 05           dec b
0396+  2228 C2 A4 21     jp nz,nta_pgloop
0397+  222B 3A 00 D0     ld a,(netBufTocId)
0398+  222E             nta_end:
0399+  222E 47           ld b,a
0400+  222F~            #ifdef DEBUG_MM
0401+  222F~             ld a,8
0402+  222F~             ld c,SSeg2
0403+  222F~             call n_to_7seg
0404+  222F             #endif
0405+  222F AF           xor a
0406+  2230 32 FE CF     ld (netBufStatus),a
0407+  2233 78           ld a,b
0408+  2234 E1           pop hl
0409+  2235 D1           pop de
0410+  2236 C1           pop bc
0411+  2237 C9           ret
0412+  2238             ; end of net_allocbuffer
0413+  2238             
0414+  2238             ; *******************************
0415+  2238             ; net_freebuffer
0416+  2238             ; Marks free a TOC which ID must be stored in netBufTocId
0417+  2238             nnet_freebuffer:
0418+  2238 F5           push af
0419+  2239 C5           push bc
0420+  223A DD E5        push ix
0421+  223C FD E5        push iy
0422+  223E DD 21 00 CC  ld ix,netBufToc
0423+  2242 01 0A 00     ld bc,nBuf1TocSize
0424+  2245 3A 00 D0     ld a,(netBufTocId)
0425+  2248 3C           inc a
0426+  2249             ntf_gettotoc:
0427+  2249 3D           dec a
0428+  224A CA 52 22     jp z,ntf_gottotoc
0429+  224D DD 09        add ix,bc
0430+  224F C3 49 22     jp ntf_gettotoc
0431+  2252             ntf_gottotoc:
0432+  2252 DD 7E 00     ld a,(ix+nBufTocStat)
0433+  2255 FE 00        cp 0
0434+  2257 CA 7C 22     jp z,ntf_end
0435+  225A AF           xor a
0436+  225B 47           ld b,a
0437+  225C DD 77 00     ld (ix+nBufTocStat),a
0438+  225F DD 4E 01     ld c,(ix+nBufTocNPages)
0439+  2262 3A F7 CF     ld a,(netBufUsedPages)
0440+  2265 91           sub c
0441+  2266 32 F7 CF     ld (netBufUsedPages),a
0442+  2269 79           ld a,c
0443+  226A FD 21 EB CF  ld iy,netBufStat
0444+  226E             ntf_markpagesfree:
0445+  226E DD 4E 04     ld c,(ix+nBufTocPages)
0446+  2271 FD 09        add iy,bc
0447+  2273 FD 70 00     ld (iy),b
0448+  2276 DD 23        inc ix
0449+  2278 3D           dec a
0450+  2279 C2 6E 22     jp nz,ntf_markpagesfree
0451+  227C             ntf_end:
0452+  227C FD E1        pop iy
0453+  227E DD E1        pop ix
0454+  2280 C1           pop bc
0455+  2281 F1           pop af
0456+  2282 C9           ret
0457+  2283             ; end of net_freebuffer
0458+  2283             
0459+  2283             ; end of Memory manager
0460+  2283             ;**************************************************************
0461+  2283             
0462+  2283             ; *******************************
0463+  2283             ; net_init
0464+  2283             nnet_init:
0465+  2283 CD 9D 20     call net_resetbuf
0466+  2286 FB           ei
0467+  2287 C9           ret
0468+  2288             ; end of nnet_init
0469+  2288             
0470+  2288             ; *******************************
0471+  2288             ; net_handlepacket
0472+  2288             ; Should be called when a packet arrives from network
0473+  2288             ; Packet TOC ID must be stored in netBufTocId
0474+  2288             nnet_handlepacket:
0475+  2288 F5           push af
0476+  2289 C5           push bc
0477+  228A D5           push de
0478+  228B E5           push hl
0479+  228C FD E5        push iy
0480+  228E DD E5        push ix
0481+  2290             
0482+  2290             
0483+  2290             ; Now the packet should be handled and the buffer can be set free
0484+  2290 3A 00 D0     ld a,(netBufTocId)
0485+  2293 CD 9A 20     call net_freebuffer
0486+  2296             ;
0487+  2296 DD E1        pop ix
0488+  2298 FD E1        pop iy
0489+  229A E1           pop hl
0490+  229B D1           pop de
0491+  229C C1           pop bc
0492+  229D F1           pop af
0493+  229E C9           ret
0494+  229F             ; end of net_handlepacket
0495+  229F             
0496+  229F             ; *******************************
0497+  229F             ; arp_update
0498+  229F             ; Updates ARP-table
0499+  229F             arp_update:
0500+  229F             ; Pushs and pops should be enabled if this routine
0501+  229F             ; is called from else where than net_handlepacket
0502+  229F             ; push af
0503+  229F             ; push bc
0504+  229F             ; push de
0505+  229F             ; push hl
0506+  229F             ; push iy
0507+  229F             ; push ix
0508+  229F 0E 11        ld c,nArpTables+1
0509+  22A1 16 00        ld d,0
0510+  22A3 1E 0C        ld e,nArp1TabSize
0511+  22A5 DD 21 44 CC  ld ix,netArpTable-nArp1TabSize
0512+  22A9             aup_findupdate:
0513+  22A9 AF           xor a
0514+  22AA DD 19        add ix,de
0515+  22AC 0D           dec c
0516+  22AD CA DD 22     jp z,aup_noold
0517+  22B0 DD BE 00     cp (ix+nArpTabStat)
0518+  22B3 CA A9 22     jp z,aup_findupdate
0519+  22B6 3A E7 CF     ld a,(netIpAddress)
0520+  22B9 DD BE 08     cp (ix+nArpTabIp)
0521+  22BC C2 A9 22     jp nz,aup_findupdate
0522+  22BF 3A E8 CF     ld a,(netIpAddress+1)
0523+  22C2 DD BE 09     cp (ix+nArpTabIp+1)
0524+  22C5 C2 A9 22     jp nz,aup_findupdate
0525+  22C8 3A E9 CF     ld a,(netIpAddress+2)
0526+  22CB DD BE 0A     cp (ix+nArpTabIp+2)
0527+  22CE C2 A9 22     jp nz,aup_findupdate
0528+  22D1 3A EA CF     ld a,(netIpAddress+3)
0529+  22D4 DD BE 0B     cp (ix+nArpTabIp+3)
0530+  22D7 C2 A9 22     jp nz,aup_findupdate
0531+  22DA C3 3C 23     jp aup_end
0532+  22DD             aup_noold:
0533+  22DD 0E 11        ld c,nArpTables+1
0534+  22DF 16 00        ld d,0
0535+  22E1 1E 0C        ld e,nArp1TabSize
0536+  22E3 DD 21 44 CC  ld ix,netArpTable-nArp1TabSize
0537+  22E7 AF           xor a
0538+  22E8             aup_findempty:
0539+  22E8 DD 19        add ix,de
0540+  22EA 0D           dec c
0541+  22EB CA F7 22     jp z,aup_noempty
0542+  22EE DD BE 00     cp (ix+nArpTabStat)
0543+  22F1 C2 E8 22     jp nz,aup_findempty
0544+  22F4 C3 28 23     jp aup_ipend
0545+  22F7             aup_noempty:
0546+  22F7 0E 10        ld c,nArpTables
0547+  22F9 16 00        ld d,0
0548+  22FB 1E 0C        ld e,nArp1TabSize
0549+  22FD FD 21 50 CC  ld iy,netArpTable
0550+  2301 DD 21 50 CC  ld ix,netArpTable
0551+  2305 DD 7E 28     ld a,(ix+nArpDate)
0552+  2308             aup_findoldest:
0553+  2308 FD 19        add iy,de
0554+  230A 0D           dec c
0555+  230B CA 28 23     jp z,aup_ipend
0556+  230E FD BE 01     cp (iy+nArpTabDate)
0557+  2311 DA 08 23     jp c,aup_findoldest
0558+  2314 AF           xor a
0559+  2315 FD BE 00     cp (iy+nArpTabStat)
0560+  2318 DD 7E 01     ld a,(ix+nArpTabDate)
0561+  231B CA 08 23     jp z,aup_findoldest
0562+  231E FD E5        push iy
0563+  2320 DD E1        pop ix
0564+  2322 DD 7E 01     ld a,(ix+nArpTabDate)
0565+  2325 C3 08 23     jp aup_findoldest
0566+  2328             aup_ipend:
0567+  2328 ED 4B E7 CF  ld bc,(netIpAddress)
0568+  232C ED 5B E9 CF  ld de,(netIpAddress+2)
0569+  2330 DD 71 08     ld (ix+nArpTabIp),c
0570+  2333 DD 70 09     ld (ix+nArpTabIp+1),b
0571+  2336 DD 73 0A     ld (ix+nArpTabIp+2),e
0572+  2339 DD 72 0B     ld (ix+nArpTabIp+3),d
0573+  233C             aup_end:
0574+  233C 3E 28        ld a,nArpDate
0575+  233E ED 4B E1 CF  ld bc,(netMacAddress)
0576+  2342 ED 5B E3 CF  ld de,(netMacAddress+2)
0577+  2346 2A E5 CF     ld hl,(netMacAddress+4)
0578+  2349 DD 77 00     ld (ix+nArpTabStat),a
0579+  234C DD 77 01     ld (ix+nArpTabDate),a
0580+  234F DD 71 02     ld (ix+nArpTabMAC),c
0581+  2352 DD 70 03     ld (ix+nArpTabMAC+1),b
0582+  2355 DD 73 04     ld (ix+nArpTabMAC+2),e
0583+  2358 DD 72 05     ld (ix+nArpTabMAC+3),d
0584+  235B DD 75 06     ld (ix+nArpTabMAC+4),l
0585+  235E DD 74 07     ld (ix+nArpTabMAC+5),h
0586+  2361             ; pop ix
0587+  2361             ; pop iy
0588+  2361             ; pop hl
0589+  2361             ; pop de
0590+  2361             ; pop bc
0591+  2361             ; pop af
0592+  2361 C9           ret
0593+  2362             ; end of arp_update
0594+  2362             
0595+  2362             ; end of TCP/IP & ARP
0596+  2362             ;**************************************************************
0597+  2362~            #ifdef ALONE
0598+  2362~            .end
0599+  2362             #endif
2776   2362             
2777   2362             .end
2778   2362             
tasm: Number of errors = 0
